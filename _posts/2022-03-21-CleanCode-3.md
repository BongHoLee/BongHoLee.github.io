---
layout: post
title: Clean Code - 3장 함수 훑기
author: Bong5
categories: [Keywords, Keywords/OOP, Others/Design, ProgramingLanguage/Java, Books/CleanCode]
--- 

### 들어가며

깊게 고민해볼 내용도 있고 (개인적으로) 조금 비판적인 의견이 생기는 내용도 있었다.

가장 유념해야 할 문장을 꼽자면 아래와 같다.

> **지정된 함수 이름 아래에서 `추상화 수준이 하나인 단계`만 수행**한다면 그 함수는 **한 가지 작업만 수행**한다고 볼 수 있다. 어쨋거나 우리가 함수를 만드는 이유는, 큰 개념을(다시말해, 함수 이름을) **다음 추상화 수준에서 여러 단계로 나눠 수행**하기 위해서...
>

함수를 넘어 클래스, 아니 어떻게 보면 **책임, 응집도, 추상화**와 같은 객체지향의 중요한 개념을 설명하는 문장이 아닐까 싶다.

조금 샛길로 빠지자면 `하나의 책임을 수행`한다는 의미가 명확하지 않고 어렴풋이나마 이해했다고 착각했다.
그래서 스프링의 여러 코드(DispatcherServlet 등)이 구조상으로 **Mapper도 호출하고.. Adapter도 호출하고..** 하나의 책임을 수행하는게 아니라 응집도가 낮은게 아닐까 생각했다.

하지만 곰곰히 되살펴보니 `추상화 수준이 하나`인 책임을 수행한다.

다시말해 여러 객체들에 대한 정보를 알아야 하기 때문에 자칫 결합도가 높고 응집도가 낮은 것 처럼 생각할 수 있지만 **DispatcherServlet이라는 객체의 추상화 수준에 맞는 정보(객체들)를 알고 있고 해당 객체에 단순히 메시지를 전송**한다.

적절한 추상화 수준을 고려하지 않고 무조건적으로 나눠도 오히려 문제가 생긴다는 것을 깨달았다.

<br>

### 작게 만들어라!

> 함수를 만드는 첫 번째 규칙은 `작게`다. 두 번째 규칙은 `더 작게`다.
>

위 말은 **하나의 추상화 수준만 남게끔 작게**만들라는 의미다.

아래 코드를 살펴보자.

<script src="https://gist.github.com/BongHoLee/63f82a22faed785f8061b3de238a90da.js"></script>

위 코드는 나름대로 여러 함수를 호출하고 있어서 작게 쪼개진 것 처럼 보이지만, 아쉬운 부분들이 있다.

**서로 다른 추상화 단계가 공존**한다는 것이다.

위 코드는 **두 개의 추상화 단계**가 존재한다.

1. 전체 페이지를 렌더링하는 높은 추상화 단계
2. 각각의 세부 페이지를 렌더링하는 낮은 추상화 단계

우리는 추상화 단계에 따라 함수를 추출할 수 있다. (물론 이후에 별도의 클래스로 추출도 가능하다.)

<script src="https://gist.github.com/BongHoLee/fe74427712b92c54616586e43c6f527a.js"></script>

위 코드는 한 가지만 수행하는 작은 함수다.

**함수가 하나의 이야기를 표현하고 다음 무대를 준비**한다.

그리고 `블록과 들여쓰기는 한 줄`로 표현하고 거기서 함수를 호출한다.

이 말은 **중첩 구조가 생길만큼 함수가 커져서는 안된다는 의미**다.

> 함수는 `한 가지`를 해야한다. 그 `한 가지`를 잘해야한다. 그 `한 가지`만을 해야한다.
>

위 충고에서 문제라면 그 `한 가지`가 무엇인지를 알기 어렵다는 것인데 위 코드는 어쩌면 `세 가지`를 한다고 주장할 수 있다.

1. 페이지가 테스트 페이지인지 판단
2. 그렇다면 설정 페이지와 해제 페이지를 삽입
3. 페이지를 HTML로 렌더링

조금 주의깊게 살펴보면 **위 세 단계는 `지정된 함수 이름 아래서 추상화 수준이 하나`다.**

⇒ `renderPageWithSetupAndTearDowns`라는 함수 이름 아래 동일한 추상화 수준의 프로세스를 수행한다.

> `지정된 함수 이름` 아래에서 `추상화 수준이 하나인 단계만 수행`한다면 그 함수는 `한 가지 작업`만을 한다고 볼 수 있다.
>

함수가 `한 가지`만 하는지 판단하는 방법이 있다. **의미있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈**이다.

즉 **동일한 추상화 수준에서 더이상 쪼갤 수 없을 때 까지 작게** 만드는 것이 핵심이다.

<br>

### 함수 당 추상화 수준은 하나로

함수가 확실히 `한 가지` 작업만 하려면 **함수 내 모든 `문장의 추상화 수준이 동일`해야 한다.**

한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

**특정 표현이 `근본 개념`인지 `세부 사항`인지 헷갈리기 때문**이다.

**내려가기 규칙**

코드는 위에서 아래로 이야기처럼 읽혀야 좋다. **한 함수 다음에는 추상화 수준이 한 단계 낮은 함수**가 온다. 즉 위에서 아래로 프로그램을 읽으면서 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

이것을 `내려가기 규칙`이라 부른다.

추상화 수준이 하나인 함수를 구현하기란 쉽지 않다. 하지만 **짧으면서도 `한 가지`만 하는 함수**를 만드는 것이 매우 중요하다.

**많은 분기(Switch, if~else)**

분기문이 많은 구조는 여러 이유로 폐해다.

**각 분기에 따라 서로 다른 기능을 하기 때문에 `변경의 원인`과 `변경의 주기`가 서로 다르다.**

따라서 **응집도가 낮고 결합도가 높은 구조**가 양산될 공산이 크다.

아래 예제를 보자.

<script src="https://gist.github.com/BongHoLee/d4641304f6f99fdef15f6476eba4d64e.js"></script>

위 코드에서 `새 직원`을 추가한다고 가정해보자.

`Employee`도 수정되어야 할 것이고 위 함수에 `case` 절을 덧붙여야 한다.

그리고 `한 가지` 작업만 수행하지도 않는다.  따라서 `변경의 주기`가 다르고 `변경의 원인`이 다양하다. 즉 `SRP` 원칙을 위반한다.

마찬가지로 `OCP` 원칙에도 위배된다. 새 직원이 추가될 때 마다 수정이 되어야 하기 때문이다.

**가장 심각한 문제는 각 함수와 구조가 동일한 함수가 무한정 존재할 수 있음**이다.

`isPayDay(Employee e, Date date)`라는 함수가 어떤 모양일지 상상이 된다.

`deliverPay(Employee e, Money money)`라는 함수 역시 동일한 구조일 것이다.

즉, **안좋은 품질의 코드가 양산**된다는 점이 가장 큰 문제다.

**조건 분기는 다형 객체를 생성하는 경우에만 허락**

말 그대로다. `Factory` 패턴에 대해서만 많은 분기절을 허락하자.

<script src="https://gist.github.com/BongHoLee/3b5058ac8e6b3a2b2aa0a771bdcfedef.js"></script>

<br>

### 함수 인수

인수는 어렵다. 인수는 개념을 이해하기 어렵게 만든다. 가장 좋은건 **인수가 없는 함수**다.

하지만 이는 불가능에 가깝다. 단순히 명확성을 위해 인수를 모두 객체의 속성으로 떠넘긴다면 **불필요한 정보를 객체가 알아야 하는** 구조가 되어 `캡슐화, 응집도, 결합도` 측면에서 품질이 저하될 여지가 있다.

결국 **경험과 고민을 통해 가장 적절한 해답**을 찾는 수 밖에 없다. 이번에는 고민을 조금이나마 줄여주기 위한 몇 가지 가이드를 소개한다.

**객체의 속성으로 두는 방법을 고려**

이를테면 `includePageInfo(StringBuffer pageText)`와 같은 함수가 있다고 가정했을 때 **함수 명과 인수의 추상화 수준이 다르다.**

왜 페이지 정보를 포함하는 함수에 `pageText`라는 인수가 필요한지 함수 내부를 확인하거나 `pageText`에 대한 문맥을 알지 못하면 이해하기가 어렵다.

이런 경우 만일 해당 인수(`content`)가 객체의 속성으로 두어도 품질에 문제가 없다면 좋은 선택지가 된다.

**많이 쓰는 단항 함수**

함수에 인수를 한 개 넘기는 이유로 가장 흔한 이유는 두 가지다.

- **인수에 질문을 던지는 경우**
    - `boolean fileExists("MyFile")`
- **인수를 변환해 결과를 반환**하는 경우
    - `InputStream fileOpen("MyFile")`

위와 같은 두 가지 경우는 사용자가 당연하게 받아들인다. `무엇`을 하는지 굳이 내부를 들여다보지 않아도 파악된다.

다시말해 위와같은 경우가 아니라면 단항함수를 가급적 피한다.

예를들어 `void includeSetupPageInto(StringBuffer pageText)`와 같은 함수를 살펴보자.

위 함수는 **입력 인수로 전달된 pageText에 내용이 추가되어 반환되는 함수다.**

그러나 전달된 인수가 `출력 인수`의 역할까지 겸하고 있는 것은 어색하다.

⇒ **입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.**

즉, `StringBuffer includeSetupPageInto(StringBuffer pageText)`가 그나마 낫다.

물론 위 규칙을 어기는 상황도 더러 존재한다. 대표적으로 **MVC 모델**에서 `Model`은 각 계층에 걸쳐 **입력 인수로 전달되지만 클라이언트는 출력 인수로써 기대**하는 함수가 더러 있다.

**플래그 인수**

`플래그 인수는 추하다.` 가장 피해야 할, 없어야 마땅한, 리팩토링의 1순위 대상인 구조다.

**함수가 한꺼번에 여러가지를 처리한다. 근데 그 처리 방식은 코드를 들여다 봐야만 확인이 가능하다.**

**이항 함수**

인수가 2개인 함수는 1개인 함수보다 이해하기 어렵다.

예를들어 `writeField(name)`은 `writedField(outputStream, name)`보다 이해하기 쉽다.

`outputStream`과 `name` 사이에는 어떤 연관성도 보이지 않는다. 추상화 수준이 동일한지도 모르겠다. 자연적인 순서가 존재하지가 않는다.

이런 경우 가능하면 **단항함수로 변경하도록 노력**해야 한다.

- `writedField` 메서드를 `outputStream` 클래스의 멤버함수로 만들어 `outputStream.writedField(name)`으로 호출
- `outputStream`을 현재 클래스의 `멤버 변수`로 만들어 인수로 넘기지 않는 방법.
- `FieldWriter`라는 새로운 클래스를 만들어 생성자에서 `outputStream`을 받고 `write` 메서드를 구현

⇒ **위와 같은 방법들은 한번 고민해봄직한 내용들이다.**

**인수 객체**

인수가 2~3개 필요하다면 **일부를 독자적인 (데이터)클래스로 만들 가능성을 짚어본다.**

물론 **인수들 사이에 연관성이 명확**해야 한다.

<br>

### 사이드 이펙트를 일으키지 마라.

`사이드 이펙트`는 거짓말이다. **함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른짓**을 한다.

때로는 예상치 못하게 객체의 속성을 변경한다.

대부분의 경우 `시간적 결합`이나 `순서 종속성`을 초래한다.

<script src="https://gist.github.com/BongHoLee/311dc2a4ed3e6b127febd78b5e65beb1.js"></script>

위 코드에서 함수가 일으키는 사이드이펙트는 `Session.initialize()` 호출이다. `checkPassword` 함수는 이름 그대로 암호를 확인한다. **이름만 봐서는 세션을 초기화 한다는 사실이 드러나지 않는다.**

그래서 함수 이름만 보고 함수를 호출하는 클라이언트는 기존 세션 정보를 지워버릴 위험에 처한다.

이런 사이드이펙트가 `시간적인 결합`을 초래한다. 즉, **checkPassword 함수는 특정 상황에서만 호출이 가능**하다. 다시말해 **세션을 초기화해도 괜찮은 경우에만 호출**이 가능하다.

자칫 잘못 호출하면 의도치않게 세션정보가 날아간다.

**시간적인 결합은 혼란을 일으킨다. 특히 부수 효과로 숨겨진 경우에는 더더욱 혼란이 커진다.**

→ 시간적인 결합이 피룡하다면 함수 이름에 분명히 명시한다.

**출력 인수**

일반적으로 출력 인수는 피해야 한다. **함수에서 상태를 변경해야 한다면 `함수가 속한 객체의 상태`를 변경하는 방식이 더 나을 수 있다.**

<br>

### 명령과 조회를 분리

함수를 `뭔가를 수행`하거나 `뭔가에 답`하거나 둘 중 하나만 해야한다.

**둘 다 하면 안된다.**

**객체의 상태를 변경(명령)하거나 객체의 정보를 반환(조회)하거나 둘 중 하나**다.

<br>

### 오류 코드보다 예외를 사용

`명령 함수`에서 오류코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

`if (deletePage(page) == E_OK)`

오류코드를 반환하면 클라이언트는 오류코드를 곧바로 처리해야 한다는 문제에 부딪힌다.

<script src="https://gist.github.com/BongHoLee/104bea2d94287b6f5da5f62003b6e2fa.js"></script>

반면 오류코드 대신 예외를 사용하면 **오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔**해진다.

<script src="https://gist.github.com/BongHoLee/b03e59c6ee8bd4844ce9a160363a55d8.js"></script>

**Try/Catch 블록 추출하기**

`try/catch` 블록을 별도 함수로 뽑아내는 것이 좋다.

<script src="https://gist.github.com/BongHoLee/16b3b145122f4cbfcdbdb88a0cc20533.js"></script>

위에서 `delete` 함수는 모든 오류를 처리한다 그래서 코드를 이해하기 쉽다. 이렇게 정상 동작과 오류 처리 동작(`ExceptionHandler`)를 구분하면 코드를 이해하고 수정하기 쉬워진다.

**오류 처리도 한 가지 작업이다.**

함수는 `한 가지` 작업만 해야한다. 오류 처리도 `한 가지` 작업에 해당한다. 따라서 **오류 처리하는 함수는 오류만 처리**해야 한다.

**Error.java 의존성 자석**

`오류 코드를 반환`한다는 이야기는 클래스든 Enum이든 **어디선가 오류 코드를 정의**한다는 의미다.

<script src="https://gist.github.com/BongHoLee/0005a88cd43219144d16fee503157e39.js"></script>

위와같은 클래스는 `의존성 자석`이다. 다른 클래스에서 `Error enum`을 사용해야 하므로 이 클래스가 변경된다면 사용하는 클래스 전부를 다시 컴파일하고 재배치 해야할 수 있다.

**오류코드 대신에 예외를 사용하면 새 예외는 `Exception` 클래스를 상속**한다. 따라서 `OCP` 원칙을 위배하지 않고 쉽게 추가할 수 있다.