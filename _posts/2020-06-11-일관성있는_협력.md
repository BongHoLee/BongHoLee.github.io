---
layout: post
title: 일관성있는 협력
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

객체는 `협력`을 위해 존재한다. `협력`은 객체가 존재하는 이유와 `문맥`을 제공한다. 잘 설계된 애플리케이션은 이해하기가 쉽고 수정이 용이하며 재사용 가능한 협력의 모임이다. 객체지향 설계의 목표는 적절한 책임을 수행하는 **객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것이다.**

애플리케이션을 개발하다 보면 `유사한 요구사항을 반복적으로 추가하거나 수정`하게 되는 경우가 발생한다. 이때 `객체들의 협력 구조`가 서로 다른 경우에는 코드를 이해하기도 어렵고 코드 수정으로 인해 버그가 발생할 위험도 높아진다. **유사한 요구사항을 계속 추가해야하는 상황에서 각 협력이 서로 다른 패턴을 따를 경우에는 전체적인 설계의 일관성이 서서히 무너지게 된다.**

객체지향 패러다임의 장점은 `설계를 재사용`할 수 있다는 것이다. 하지만 재사용은 공짜로 얻어지지 않는다. **재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.** 일관성은 설계에 드는 비용을 감소시킨다. 과거의 해결 방법을 반복적으로 사용해서 유사한 기능을 구현하는 데 드는 시간과 노력을 대폭 줄일 수 있기 때문이다. `일관성 있는 설계`가 가져다 주는 더 큰 이익은 `코드가 이해하기가 쉬워진다는 것`이다. 특정한 문제를 유사한 방법으로 해결하고 있다는 사실을 알면 문제를 이해하는것 만으로도 코드의 구조를 예상할 수 있게된다.

**가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라.** 객체들의 협력이 전제척으로 일관성 있는 유사한 패턴을 따른다면 시스템을 이해하고 확장하기 위해 요구되는 정신적인 부담을 크게 줄일 수 있다. 지금 보고 있는 코드가 얼마 전에 봤던 코드와 유사하다는 사실을 아는 순간 새로운 코드가 직관적인 모습으로 다가오는 것을 느끼게 될 거싱다.

`일관성 있는 협력 패턴`을 적용하면 여러분의 코드가 이해하기 쉽고 직관적이며 유연해진다는 것이 이번 장의 주제다. 코드를 살펴보는 것으로 시작하자.

---

## 핸드폰 과금 시스템 변경하기

### 기본 정책 확장

앞서 11장에서 구현한 `핸드폰 과금 시스템`의 요금 정책을 수정해야 한다고 가정하자. 지금까지 `기본 정책`에는 `일반 요금제`와 `심야 할인 요금제`의 두 가지 종류가 있었다. 이번 장에서는 `기본 정책`을 아래 표와 같이 4가지 방식으로 확장할 것이다. `부가 정책`에 대한 요구사항은 변화가 없다.

| 유형 | 형식 | 예 |
| ---- | ---- | ---- |
| 고정요금 방식 | A초당 B원 | 10초당 18원 |
| 시간대별 방식 | A시 부터 B시까지 C초당 D원 <br> B시부터 C시까지 C초당 E원 | 00시부터 19시까지 10초당 18원 <br> 19시부터 24시까지 10초당 15원 |
| 요일별 방식 | 평일에는 A초당 B원 <br> 공휴일에는 A초당 C원 | 평일에는 10초당 38원 <br> 공휴일에는 10초당 19원 |
| 구간별 방식 | 초기 A분 동안 B초당 C원 <br> A분 ~ D분까지 B초당 D원 <br> D분 초과 시 B초당 E원 | 초기 1분동안 10초당 50원 <br> 초기 1분 이후 10초당 20원 |

`기본 정책`을 구성하는 4가지 방식에 관해 간단히 살펴보자.

- **고정요금 방식** : 일정 시간 단위로 동일한 요금을 부과하는 방식이다. 모든 통화에 대해 동일하게 10초당 9원을 부과하는 방식이 고정요금 방식의 예에 해당한다 기존의 '일반 요금제'와 동일하다.

- **시간대별 방식** : 하루 24시간을 특정한 시간 구간으로 나눈 후 각 구간별로 서로 다른 요금을 부과하는 방식이다. 예를 들어, 0시 ~ 19시 까지는 10초당 18원을, 19시 ~ 24시까지는 10초당 15원의 요금을 부과하는 방식이다. 기존의 '심야 할인 요금제'는 밤 10시를 기준으로 요금을 부과한 시간대별 방식이다.

- **요일별 방식** : 요일별로 요금을 차등 부과하는 방식이다. 이 방식을 사용하면 월요일부터 금요일까지는 10초당 38원을, 토요일과 일요일에는 10초당 19원을 부과하는 요금제를 만들 수 있다.

- **구간별 방식** : 전체 통화 시간을 일정한 통화 시간에 따라 나누고 각 구간별로 요금을 차등 부과하는 방식이다. 예를들어, 통화 구간을 초기 1분과 1분 이후로 나눈 후 초기 1분 동안은 10초당 50원을, 그 이후에는 10초당 20원을 부과하는 방식이 구간별 방식에 해당한다. 만약 어떤 사용자의 전체 통화 시간이 60분이라면 처음 1분에 대해서는 10초당 50원이 부과되고 나머지 59분에 대해서는 10초당 20원의 요금이 부과될 것이다.

아래 그림은 11장에서 요금 정책을 설명하면서 사용한 그림을 수정한 것으로서 새로운 기본 정책을 적용할 때 조합 가능한 모든 경우의 수를 나타낸 것이다.

<img src="/assets/img/consistency1.PNG" width="100%" height="auto">

아래 그림은 이번 장에서 구현하게 될 클래스 구조를 그림으로 나타낸 것이다. 짙은 색으로 표현된 클래스들이 `새로운 기본 정책`을 구현한 클래스들이다. 고졍요금 방식은 `FixedFeePolicy`, 시간대별 방식은 `TimeOfDayDiscountPolicy`, 요일별 방식은 `DayOfWeekDiscountPolicy`, 구간별 방식은 `DurationDiscountPolicy`라는 이름의 클래스로 구현할 것이다.

<img src="/assets/img/consistency2.PNG" width="100%" height="auto">

### 고정요금 방식 구현하기

가장 간단한 `고정요금 방식`부터 시작해보자. 고정요금 방식은 기존의 일반요금제와 동일하기 때문에 기존의 `RegularPolicy` 클래스의 이름을 `FixedFeePolicy`로 수정하기만 하면 된다.

<script src="https://gist.github.com/BongHoLee/9b8cb7599bd95b5f34d90a4e5d4ebac1.js"></script>

### 시간대별 방식 구현하기

`시간대별 방식`에 따라 요금을 계산하기 위해서는 통화 기간을 정해진 시간대별로 나눈 후 각 시간대별로 서로 다른 계산 규칙을 적용해야 한다. 아래 그림은 0시부터 19시까지의 통화에 대해서는 10초당 18원의 요금을 부과하고, 19시부터 24시 까지는 10초당 15원의 요금을 부과하는 시간대별 방식을 나타낸 것이다. 가입자가 18시부터 20시까지 2시간 동안 통화를 했다면 18시부터 19시까지 1시간 동안의 통화에 대해서는 10초당 18원의 요금이 부과되고, 19시부터 20시까지 1시간 동안의 통화에 대해서는 10초당 15원의 요금이 부과된다.

<img src="/assets/img/consistency3.PNG" width="100%" height="auto">

여기서 한 가지 고려해야 할 조건이 있다. 만약 통화가 여러 날에 걸쳐서 이뤄진다면 어떻게 될까? 아래 그림처럼 3일에 걸쳐 통화를 한 가입자가 있다고 가정해보자.

<img src="/assets/img/consistency4.PNG" width="100%" height="auto">

이 경우 시간대별 방식에 따라 요금을 구현하려면 규칙에 정의된 구간별로 통화를 구분해야 한다. 즉, 위 그림의 통화는 아래 그림과 같이 통화 구간을 분리한 후 각 구간에 대해 개별적으로 계솬된 요금을 합해야 한다.

<img src="/assets/img/consistency5.PNG" width="100%" height="auto">

여기서 이야기하고 싶은 것은 시간대별 방식의 통화요금을 계산하기 위해서는 통화의 `시작 시간과 종료 시간`뿐만 아니라 `시작 일자와 종료 일자`도 함께 고려해야 한다는 것이다.

시간대별 방식을 구현하는데 있어 핵심은 `규칙에 따라 통화 시간을 분할하는 방법을 결정`하는 것이다. 이를 위해 기간을 편하게 관리할 수 있는 `DateTimeInterval` 클래스를 추가하자. `DateTimeInterval`은 `시작시간(from)`과 `종료 시간(to)`을 인스턴스 변수로 포함하며, 객체 생성을 위한 정적 메서드(static)인 `of`, `toMidnight`, `fromMidnight`, `during`을 제공한다.

<script src="https://gist.github.com/BongHoLee/fa7d9bbc9e545b1f5368d476b17c7968.js"></script>

기존의 `Call` 클래스는 통화 기간을 저장하기 위해 `from`과 `to`라는 두 개의 `LocalDateTime` 타입의 인스턴스 변수를 포함하고 있었다. 이제 기간을 하나의 단위로 표현할 수 있는 `DateTimeInterval` 타입을 사용할 수 있으므로 `from`과 `to`를 `interval`이라는 하나의 인스턴스 변수로 묶을 수 있다.

<script src="https://gist.github.com/BongHoLee/71eac3cf677cbfa927ee6a23bc2630a2.js"></script>

이제 필요한 것들은 준비되었으니 전체 통화 시간을 `일자`와 `시간` 기준으로 분할하여 계산해보자. 이를 위해 요금 계산 로직을 다음과 같이 두 개의 단계로 나눠 구현할 필요가 있다.

- 통화 기간을 `일자`별로 분리한다.

- 일자별로 분리된 기간을 다시 `시간대별 규칙`에 따라 분리한 후 각 기간에 대해 요금을 계산한다.

위의 두 작업을 `객체의 책임`으로 할당해보자. 책임을 할당하는 기본 원칙은 **책임을 수행하는 데 필요한 정보를 가장 잘 알고있는 정보 전문가에게 할당하는 것이다.** 먼저 `통화 기간을 일자 단위로 나누는 작업의 정보 전문가`는 누구인가? 통화 기간에 대한 정보를 가장 잘 알고있는 객체는 `Call`이다. 하지만 `Call`은 통화 기간은 잘 알지 몰라도 `기간 자체를 처리하는 방법`에 대해서는 전문가가 아니다. **기간을 처리하는 방법에 대한 전문가는 바로 DateTimeInterval이다.** 따라서 `통화 기간을 일자 단위로 나누는 책임`은 `DateTimeInterval`에게 할당하고 `Call`이 `DateTimeInterval`에게 분할을 요청하도록 협력을 설계하는 것이 적절할 것이다.

두 번째 작업인 `시간대 별로 분할`하는 작업의 정보 전문가는 누구인가? `시간대별 기준을 잘 알고있는 요금 정책`이며 여기서는 `TimeOfDayDiscountPolicy`라는 이름의 클래스로 구현할 것이다.

전체 통화 시간을 분할하는 작업은 아래 그림과 같이 `TimeOfDayDiscountPolicy`, `Call`, `DateTimeInterval` 사이의 협력으로 구현할 수 있다.

1. 먼저 `TimeOfDayDiscountPolicy`는 통화 기간을 알고있는 `Call`에게 일자별로 통화 기간을 분리할 것을 요청한다.

2. `Call`은 이 요청을 `DateTimeInterval`에게 위임한다.

3. `DateTimeInterval`은 기간을 일자 단위로 분할한 후 분할된 목록을 반환한다.

4. `Call`은 반환된 목록을 그대로 `TimeOfDayDiscountPolicy`에게 반환한다.

5. `TimeOfDayDiscountPolicy`는 일자별 기간의 목록을 대상으로 루프를 돌리면서 각 시간대 별 기준에 맞는 시작시간(from)과 종료시간(to)를 얻는다.

<img src="/assets/img/consistency6.PNG" width="100%" height="auto">

이해를 돕기 위해 구체적인 예를 통해 분할 과정을 살펴보자. 시간대별 방식 요금제에 가입한 사용자가 `1월 1일 10시 ~ 1월 3일 15시`에 걸쳐 통화를 했다고 가정해보자. 그리고 각 시간대 별 요금은 아래와 같다.

1. `0시 ~ 19시 까지는 10초당 18원`의 요금

2. `19시 ~ 24시 까지는 10초당 15원`의 요금

앞에서 설명한 것처럼 시간대별 방식으로 요금을 계산하기 위해서는 우선 `날짜별로 통화 시간을 분리`해야 한다. `Call`은 기간을 저장하고 있는 `DateTimeInterval` 타입의 인스턴스 변수인 `interval`에게 `splitByDay` 메시지를 전송한다. `splitByDay` 메서드는 아래 그림처럼 `1월 1일 10시 ~ 24시`, `1월 2일 0시 ~ 24시`, `1월 3일 0시 ~ 15시`를 저장하는 3개의 `DateTimeInterval` 인스턴스를 포함하는 `List`를 반환 할 것이다.

<img src="/assets/img/consistency7.PNG" width="100%" height="auto">

`Call`은 이렇게 분리된 `List`를 시간대별 방식을 위한 `TimeOfDayDiscountPolicy` 클래스에게 반환한다. `TimeOfDayDiscountPolicy` 클래스는 일자별로 분리된 각 `DateTimeInterval` 인스턴스들을 요금 정책에 정의된 각 시간대 별로 분할한 후 요금을 부과해야 한다.

첫 번째 통화 구간과 두 번째 통화 구간은 조금 복잡한데 `1월 1일 10시 ~ 24시`와 `1월 2일 0시 ~ 24시`가 두 요금 규칙의 시간대에 걸쳐있기 때문이다. 이 요금을 계산하기 위해서는 반환된 `일자별 통화 구간`을 다시 `시간대 별`로 나눈 후 나뉘어진 시간대 별로 요금을 계산한 합을 구해야 한다. 따라서 통화 구간을 19시 기준으로 나누고 `1월 1일 10시 ~ 19시`와 `1월 2일 0시 ~ 19시`는 10초당 18원으로, `1월 1일 19시 ~ 24시`와 `1월 2일 19시 ~24`시는 10초당 15원으로 요금을 계산해야 한다. 세 번째 통화 구간인 `1월 3일 0시 ~ 15시`는 전체가 0시부터 19시 사이에 포함되기 때문에 전체 구간에 대해 10초당 18원의 요금 규칙을 적용하면 될 것이다.

결과적으로 `1월 1일 10시 ~ 1월 3일 15시` 사이의 통화 요금을 계산하기 위한 전체 통화 기간은 아래 그림에서 알 수 있는 것 처럼 `1월 1일 10시 ~ 19시`, `1우러 1일 19시 ~ 24시`, `1월 2일 0시 ~ 19시`, `1월 2일 19시 ~ 24시`, `1월 3일 0시 ~ 15시`의 5개로 분리된다.

<img src="/assets/img/consistency8.PNG" width="100%" height="auto">

이제 대략적인 로직을 살펴봤으므로 `TimeOfDayDiscountPolicy` 클래스를 구현해보자. 이 클래스에서 가장 중요한 것은 **시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정하는 것이다.** 하나의 통화 시간대를 구성하는 데는 `시작 시간`, `종료 시간`, `단위 시간`, `단위 요금`이 필요하다. 앞의 예에서 살펴본 0시부터 19시 까지의 통화 시간에 대해서는 10초당 18원의 요금을 부과하는 규칙에서 `시작 시간은 0시`, `종료 시간은 19시`, `단위 시간은 10초`, `단위 요금은 18원`이 된다. 그리고 시간대별 방식은 하나 이상의 시간대로 구성되기 때문에 이 4가지 요소가 하나 이상 존재해야 한다.

시간대별 방식을 담당한 개발자는 이 문제를 4개의 서로 다른 `List`를 가지는 것으로 해결했다. `TimeOfDayDiscountPolicy` 클래스는 `시작 시간의 List`, `종료 시간의 List`, `단위 시간의 List`, `단위 요금의 List`를 포함하며 같은 규칙에 포함된 요소들은 `List` 안에서 `동일한 인덱스`에 위치하게 된다.

<script src="https://gist.github.com/BongHoLee/7720c1ae745597c2d703d7bb62c67fa8.js"></script>

아래 그림은 0시부터 19시 까지의 통화에 대해서는 10초당 18원의 요금을 부과하고 19시부터 24시 까지는 10초당 15원의 요금을 부과하는 시간대별 방식 요금제를 4개의 리스트로 구성한 예를 표현한 것이다. 같은 규칙에 속하는 요소들이 시작 시간의 List인 `starts`, 종료 시간의 List인 `ends` 단위 시간의 List인 `durations`, 단위 요금의 List인 `amounts` 안에서 같은 인덱스에 위치한다는 것을 알 수 있을 것이다.

<img src="/assets/img/consistency9.PNG" width="100%" height="auto">



### 참고 및 출처

  - 오브젝트
