---
layout: post
title: 서브클래싱과 서브타이핑
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

객체지향 커뮤니티에 널리 퍼진 `상속`에 대한 불신과 오해를 풀기 위해서는 `상속`이 `두 가지 용도`로 사용된다는 사실을 이해하는 것이 중요하다.

첫 번째 용도는 `타입 계층 구현`이다. **_타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다._** `타입 계층`의 관점에서 부모 클래스는 자식 클래스의 `일반화`이고, 자식 클래스는 부모 클래스의 `특수화`이다.

상속의 두 번째 용도는 `코드 재사용`이다. 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용 할 수 있는 마법의 주문과도 같다. 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다. 하지만 **_재사용을 위해 상속을 사용하게 되면 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다._**

> 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다. 상속은 코드를 쉽게 재사용할 수 있는 방법을 제공하지만 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 설계의 변경과 진화를 방해한다. 반면 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관게에 기반해 확장 가능하고 유연한 설계를 얻을 수 있다.

결론부터 말하자면 **_동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 '행동'을 기반으로 타입 계층을 구성해야 한다._**

이번 장에서는 `올바른 타입 계층을 구성하는 원칙`에 대해서 학습하기로 한다.

그렇다면 `타입 계층`이란 무엇인가? `상속을 이용해 타입 계층을 구현`한다는 것이 무엇을 의미하는가? 이 질문에 대한 답을 찾기 위해 먼저 `타입`과 `타입 계층`의 개념을 알아보자.

---

## 타입

`객체지향 프로그래밍에서의 타입`에 대해서 이해를 하기 위해서는 먼저 `프로그래밍 언어 관점에서의 타입`과 `개념 관점에서의 타입`을 함께 살펴볼 필요가 있다.

### 개념 관점에서의 타입

`개념 관점에서의 타입`이란 우리가 인지하는 세상의 사물의 종류를 의미한다. 다시말해 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 부른다. **_타입은 사물을 분류하기 위한 틀로 사용된다._** 예를 들어 자바, 루비, 자바스크립트, C를 프로그래밍 언어라고 부를 때 우리는 이것들을 `프로그래밍 언어 타입`으로 분류하고 있는 것이다.

어떤 대상이 `타입`으로 분류될 때 그 대상을 `타입의 인스턴스`라고 부른다. 자바, 루비, 자바스크립트, C는 프로그래밍 언어의 `인스턴스`이다. 일반적으로 타입의 인스턴스를 `객체`라고 부른다.

지금까지의 설명을 통해 `타입`이 `심볼`, `내연`, `외연`의 세 가지 요소로 구성된다는 사실을 알 수 있다.

- `심볼(Symbol)` : 타입에 `이름`을 붙인 것이다. 앞에서 `프로그래밍 언어`가 타입의 `심볼`에 해당한다.

- `내연(Intension)` : 타입의 `정의`로서 타입에 속하는 객체들이 가지는 `공통적인 속성이나 행동`을 가리킨다. 프로그래밍 언어의 `정의`인 `"컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합"`이 바로 `내연`에 속한다. 일반적으로 `타입`에 속하는 `객체들이 공유하는 속성과 행동의 집합`이 내연을 구성한다.

- `외연(Extension)` : 타입이 속하는 `객체들의 집합`이다. 프로그래밍 언어 타입의 경우에는 자바, 루비, 자바스크립트, C가 속한 `집합이 외연을 구성`한다.

### 프로그래밍 언어 관점의 타입

프로그래밍 언어 관점에서 `타입`은 **_연속적인 비트에 의미와 제약을 부여하기 위해 사용된다._** 하드웨어는 데이터를 `0`과 `1`로 구성된 일련의 비트 조합으로 취급한다. 하지만 비트 자체에는 타입이라는 개념이 존재하지 않는다. 비트에 담긴 데이터를 `문자열`로 다룰지, `정수`로 다룰지는 전적으로 `데이터를 사용하는 애플리케이션에 의해 결정`된다. 따라서 **_프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다._**

프로그래밍 언어에서 `타입`은 두 가지 목적을 위해 사용된다.

- **_타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다._**
자바에서 `+` 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다. 하지만 C++과 C#에서는 연산자 오버로딩을 통해 `+`연산자를 사용하는 것이 가능하다. 여기서 중요한 것은 `모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한`함으로써 프로그래머의 실수를 막아준다는 것이다.

- **_타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다._**
예를 들어 자바에서 `a + b`라는 연산이 있을 때 `a`와 `b`의 타입이 `int`라면 두 수를 더할 것이다. 하지만 `a`와 `b`의 타입이 `String`이라면 두 문자열을 하나의 문자열로 합칠 것이다. 따라서 **_a와 b에 부여된 타입이 + 연산자의 문맥을 정의한다._**

> 정리하면 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의한다.

이제 `타입`의 개념을 객체지향 패러다임 관점에서 확장해보자.

### 객체지향 패러다임 관점의 타입

지금까지의 내용을 바탕으로 `타입`을 다음과 같은 두 가지 관점에서 정의할 수 있다.

- `개념 관점`에서의 타입이란 `공통의 특징을 공유하는 대상들의 분류`이다.

- `프로그래밍 언어 관점`에서의 타입이란 `동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합`이다.

이제 이 두 정의를 `객체지향 패러다임의 관점`에서 조합해보자. `프로그래밍 언어 관점에서의 타입은 호출 가능한 오퍼레이션의 집합을 정의`한다. `객체지향 프로그래밍`에서 `오퍼레이션`은 `객체가 수신할 수 있는 메시지`를 의미한다. 따라서 **_객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다._**

우리는 이미 객체가 수신할 수 있는 메시지의 집합을 가리키는 멋진 용어를 알고있다. 바로 `퍼블릭 인터페이스`가 그것이다. **_객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다._**

`개념 관점에서의 타입`은 `공통의 특성을 가진 객체들을 분류하기 위한 기준`이다. 그렇다면 여기서 `공통의 특성`이란 무엇일까? `타입이 오퍼레이션을 정의`한다는 사실을 기억하면 쉽게 답을 구할 수 있다.

> 객체지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있다.

즉, 객체지향 프로그래밍 관점에서 `타입`은 다음과 같이 정의할 수 있다.

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

`타입`의 정의는 지금까지 줄곧 강조해왔던 객체에 관한 한 가지 사실을 다시 한번 강조한다. **_객체에게 중요한 것은 속성이 아니라 행동이라는 사실이다._** 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르다면 이들은 서로 다른 타입으로 분류된다. 반대로 어떤 객체들이 내부 상태는 다르지만 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.

> 객체를 바라볼 떄는 항상 "객체가 외부에 제공하는 행동에 초점"을 맞춰야 한다. 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 명심하자.

---

## 타입 계층

### 타입 사이의 포함 관계

수학에서 `집합`은 다른 집합을 `포함`할 수 있다. `타입` 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다. `타입` 안에 포함된 객체들을 `좀 더 상세한 기준으로 묶어 새로운 타입을 정의`하면 이 새로운 타입은 자연스럽게 `기존 타입의 부분집합`이 된다.

앞에서 예로 든 자바, 루비, 자바스크립트, C는 `프로그래밍 언어` 타입의 인스턴스다. 따라서 이들을 아래 그림과 같이 `프로그래밍 언어`집합의 원소로 표현할 수 있다.

<img src="/assets/img/type1.PNG" width="100%" height="auto">

이 집합의 원소들을 좀 더 `상세한 기준에 따라 분류`할 수 있다. **_자바_**, **_루비_** , **_자바스크립트_** 는 `객체지향 언어`로 분류할 수 있고, **_C_** 는 `절차적 언어`로, **_자바스크립트_** 는 `프로토타입 기반 언어`로 분류할 수 있다.

아래 그림에서 알 수 있는 것처럼 **_타입은 집합의 관점에서 좀 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다._** `프로그래밍 언어` 타입은 `객체지향 언어` 타입과 `절차적 언어` 타입을 포함하고, `객체지향 언어` 타입은 `클래스 기반 언어` 타입과 `프로토타입 기반 언어` 타입을 포함한다.

<img src="/assets/img/type2.PNG" width="100%" height="auto">

타입이 다른 타입에 `포함`될 수 있기 때문에 **_동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능하다._** **_자바_** 는 `프로그래밍 언어`인 동시에 `객체지향 언어`에 속하며 더 세부적으로 `클래스 기반 언어` 타입에 속한다.

다른 타입을 `포함하는 타입`은 `포함되는 타입`보다 좀 더 `일반화된 의미`를 표현할 수 있다. 반면 `포함되는 타입`은 좀 더 `특수하고 구체적`이다. `프로그래밍 언어` 타입은 `객체지향 언어` 타입보다 더 `일반적`이고 `객체지향 언어` 타입은 `클래스 기반 언어` 보다 더 일반적이다.

다른 타입을 `포함하는 타입`은 `포함되는 타입`보다 더 많은 인스턴스를 가진다. 위 그림에서 `프로그래밍 언어` 타입은 7개의 인스턴스를 포함하지만 `클래스 기반 언어` 타입은 이보다 적은 3개의 인스턴스만을 포함한다.

다시 말해서 `포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적`이다. 이와 반대로 `포함되는 타입은 외연 관점에서는 더 작고 내연 관점에서는 더 특수`하다. 이것은 **_포함 관계로 연결된 타입 사이에 개념적으로 "일반화"와 "특수화" 관계가 존재한다는 것을 의미한다._**

타입들은 아래 그림과 같이 `일반화`와 `특수화` 관계를 가진 계층으로 표현할 수 있다.

<img src="/assets/img/type3.PNG" width="100%" height="auto">

타입 계층을 구성하는 두 타입 간의 관계에서 `더 일반적인 타입을 "슈퍼타입"`이라고 부르고 `더 특수한 타입을 "서브타입"`이라고 부른다. `프로그래밍 언어` 타입은 `객체지향 언어` 타입과 `절차적 언어` 타입의 `슈퍼타입`이고 `객체지향 언어` 타입은 `클래스 기반` 타입과 `프로토타입 기반` 타입의 `슈퍼타입`이다.

이제 `내연`과 `외연`의 관점에서 `일반화`와 `특수화`를 정의해보자. `객체의 정의를 의미하는 내연 관점`에서 `일반화`란 어떤 타입의 정의를 좀 더 **_보편적이고 추상적으로 만드는 과정을 의미한다._** 반대로 `특수화`란 **_어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정을 의미한다._**

`내연의 관점`에서 특수한 타입의 정의는 `일반적인 타입의 정의를 좀 더 구체화`한 것이다. 예를들어 `객체지향 언어의 내연`은 **_컴퓨터에게 특정한 작업을 지시하기 위해 객체를 생성하고 객체 사이의 메시지 전송을 통한 협력 관계를 구성할 수 있는 어휘와 문법적 규칙의 집합_** 으로 정의할 수 있는데, 이것은 앞에서 살펴본 `프로그래밍 언어` 타입의 정의에 의미를 명확하게 하기 위한 설명을 덧붙여 `구체화`한 것이다.

집합을 의미하는 `외연의 관점`에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 `슈퍼셋`이다. 반대로 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 `서브셋`이다. 따라서 **_특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스이기도 하다._**

따라서 `내연`과 `외연`의 관점에서 `서브타입`과 `슈퍼타입`을 다음과 같이 정의할 수 있다.

- `슈퍼타입`은 다음과 같은 특징을 가지는 타입을 가리킨다.
  - 집합이 다른 집합의 모든 멤버를 포함한다.
  - 타입 정의가 다른 타입보다 좀 더 일반적이다.

- `서브타입`은 다음과 같은 특징을 가지는 타입을 말한다.
  - 집합에 포함되는 인스턴스들이 좀 더 큰 집합에 포함된다.
  - 타입 정의가 다른 타입보다 좀 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층

이제 객체지향 프로그래밍 관점에서 `타입`의 정의가 더 일반적이고 더 특수하다는 사실이 어떤 의미를 가지는지 살펴보자. **_객체의 타입을 결정하는 것은 퍼블릭 인터페이스다._** `일반적인 타입`이란 `더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입`을 의미한다. `특수한 타입`이란 `더 특수한 퍼블릭 인터페이스를 가지는 객체들의 타입`을 의미한다. 따라서 `퍼블릭 인터페이스`의 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다.

- `슈퍼타입`이란 **_서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다._**

- `서브타입`이란 **_슈퍼타입이 정의한 퍼블릭 인터페이싀를 특수화시켜 상대적으로 구체적이고 좁은 의믜로 정의한 것이다._**

뒤에서 `일반적인 퍼블릭 인터페이스`와 `특수한 퍼블릭 인터페이스`를 살펴볼 것이다. 일단 여기서는 **_일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 "퍼블릭 인터페이스"_** 라는 사실을 기억하자.

> 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 "슈퍼 타입"이다. 서브타입의 인스턴스 집합은 슈퍼타입의 인스턴스 집합의 부분집합이기 때문에 더 특수한 퍼블릭 인터페이스를 가지는 객체들은 동시에 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 집합에 포함된다.

다시 한번 강조한다. **_서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다._**

---

## 서브클래싱과 서브타이핑

객체지향 프로그래밍 언어에서 `타입`을 구현하는 일반적인 방법은 `클래스`를 이용하는 것이다. 그리고 `타입 계층`을 구현하는 일반적인 방법은 `상속`을 이용하는 것이다. `상속`을 이용해 `타입 계층`을 구현한다는 것은 **_부모 클래스가 슈퍼 타입의 역할을, 자식 클래스가 서브 타입의 역할을 수행하도록 클래스 사이의 관계를 정의한다는 것을 의미한다._**

그렇다면 어떤 타입이 다른 타입의 `서브타입`이 되기 위해서는 어떤 조건을 만족해야 할까? **서브타입의 퍼블릭 인터페이스가 슈퍼타입의 퍼블릭 인터페이스보다 더 특수하다는 것은 어떤 의미일까?** 이제부터는 `타입 계층을 구현할 때 지켜야 하는 제약사항`을 클래스와 상속의 관점에서 살펴보자.

### 언제 상속을 사용해야 하는가?

반복해서 강조하지만 **_상속의 올바른 용도는 "타입 계층을 구현"하는 것이다._** 그렇다면 어떤 조건을 만족시켜야만 `타입 계층을 위해 올바르게 상속을 사용`했다고 말할 수 있을까? `마틴 오더스키`는 다음과 같은 질문을 해보고 두 질문에 모두 `Yes`일 경우에만 상속을 사용하라고 조언한다.

- **_상속 관계가 IS-A 관계를 모델링 하는가?_**
이것은 어플리케이션을 구성하는 `어휘`에 대한 우리의 관점에 기반한다 일반적으로 **_[자식클래스] IS A [부모클래스]_** 라고 말해도 이상하지 않다면 `상속을 사용할 후보`로 간주할 수 있다.

- **_클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?_**
상속 계층을 사용하는 `클라이언트`의 입장에서 `부모 클래스`와 `자식 클래스`의 차이점을 몰라야 한다. 이를 자식 클래스와 부모 클래스 사이의 `행동 호환성`이라고 한다.

설계 관점에서 상속을 적용할지 여부를 결정하기 위해 첫 번째 질문 보다는 두 번째 질문에 초점을 맞추는 것이 중요하다. 뒤에서 자세히 살펴보겠지만 **_클라이언트의 관점에서 두 클래스에 대해 "기대"하는 행동이 다르다면 비록 그것이 IS-A 관계로 표현할 수 있따고 하더라도 상속을 사용해서는 안된다._**

### IS-A 관계

마틴 오더스키의 조언에 따르면 두 클래스가 `어휘적`으로 `IS-A` 관계를 모델링 할 경우에만 상속을 사용해야 한다. **_어떤 타입 S가 다른 타입 T의 일종이라면 당연히 '타입 S는 타입 T다(S is-a T)'라고 말할 수 있어야 한다._** `객체지향 언어는 프로그래밍 언어다.`라고 표현할 수 있고 `클래스 기반 언어는 객체지향 언어다`라고 표현할 수 있기 때문에 `프로그래밍 언어`, `객체지향 언어`, `클래스기반 언어`는 `IS-A` 관계를 만족시킨다.

하지만 `IS-A` 관계가 생각처럼 직관적이고 명쾌한 것은 아니다. 먼저 두 가지 익숙한 사실에서 이야기를 시작해보자.

- `펭귄`은 `새`다.
- `새`는 날 수 있다.

두 가지 사실을 조합하면 아래와 유사한 코드를 얻게 된다.

<script src="https://gist.github.com/BongHoLee/88dba4d4ccbe6cca6b5de46631a7279b.js"></script>

안타깝게도 이 코드는 반은 맞고 반은 틀리다. `펭귄`은 분명 `새`지만 날수 없는 새다. 하지만 코드는 분명히 `펭귄은 새고, 따라서 날 수 있다.`라고 주장한다.

> 이 예는 어휘적인 정의가 아니라 "기대되는 행동"에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다. [어휘적인 정의]로는 펭귄은 새지만 만약 [새의 정의에 날 수 있다는 행동이 포함되면 펭귄은 새의 서브타입이 될 수 없다.] 만약 [새의 정의에 날 수 있다는 행동이 포함되지 않는다면 펭귄은 새의 서브타입이 될 수 있다.] 이 경우에는 어휘적인 관점과 행동 관점이 일치하게 된다.

따라서 **_타입 계층의 의미는 행동이라는 문맥에 따라서 달라질 수 있다._** 그에 따라 **_올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다._** 어떤 어플리케이션에서 `새`에게 날 수 있다는 행동을 기대하지 않고 단지 울음 소리를 낼 수 있다는 행동만 기대한다면 새와 펭귄을 타입 계층으로 묶어도 무방하다. 따라서 **_슈퍼타입과 서브타입 관계에서는 IS-A 보다 "행동 호환성"이 더 중요하다._**

> 어떤 두 대상을 언어적으로 IS-A라고 표현할 수 있더라도 일단은 "상속을 사용할 예비 후보"정도로만 생각하라.

> 중요하다. 너무 성급하게 상속을 적용하려고 서두르지 마라. 여러분의 애플리케이션 안에서 두 가지 후보 개념이 어떤 방식으로 사용되고 협력되는지 살펴본 후에 상속의 적용 여부를 결정해도 늦지 않다.

### 행동 호환성

펭귄이 새가 아니라는 사실을 받아들이기 위한 출발점은 `타입이 행동과 관련이 있다는 사실에 주목`하는 것이다. 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 **_행동에 연관성이 없다면 IS-A 관계를 사용하지 말아야 한다._**

분명 `펭귄`과 `새`라는 단어가 풍기는 향기는 두 타입을 `IS-A` 관계로 묶고 싶을 만큼 매혹적인 것은 사실이다. 하지만 `새`와 `펭귄`의 `서로 다른 행동 방식`은 이 둘을 동일한 타입 계층으로 묶어서는 안된다고 강하게 경고한다.

> 결론은 두 타입 사이에 "행동이 호환될 경우에만" 타입 계층으로 묶어야 한다는 것이다.

그렇다면 `행동이 호환된다`는 것은 무슨 의미일까? 단순히 동일한 메서드를 구현하고 있으면 행동이 호환되는 것일까?

여기서 중요한 것은 **_행동의 호환 여부를 판단하는 기준은 "클라이언트의 관점"이라는 것이다._** `클라이언트`가 `두 타입이 동일하게 행동할 것이라고 기대`한다면 두 타입을 타입 계층으로 묶을 수 있다. `클라이언트`가 `두 타입이 동일하게 행동하지 않을 것이라고 기대`한다면 두 타입을 타입 계층으로 묶어서는 안된다.

> Penguin이 Bird의 서브타입이 아닌 이유는 "클라이언트의 입장"에서 모든 새가 날 수 있다고 "가정" 하기 때문이다. 단순히 IS-A라고 표현할 수 있다고 해서 두 타입이 올바른 타입 계층을 구성한다고 말할 수 없다. 중요한 것은 "클라이언트의 기대"다. 타입 계층을 이해하기 위해서는 "그 타입 계층이 사용될 문맥을 이해"하는 것이 중요한 것이다.

다음과 같이 클라이언트가 날 수 있는 새만을 원한다고 가정해보자.

<script src="https://gist.github.com/BongHoLee/f0a27251f3b90702d6dcd5deffeb3d67.js"></script>

현재 `Penguin`은 `Bird`의 자식 클래스이기 때문에 컴파일러는 `업캐스팅`을 허용한다. 따라서 `flyBird` 메서드의 인자로 `Penguin`의 인스턴스가 전달되는 것을 막을 수 없다. 하지만 `Penguin은 날 수 없고 클라이언트는 모든 bird가 날 수 있기를 기대`하기 때문에 `flyBird` 메서드로 전달돼서는 안된다. **_Penguin은 클라이언트의 기대를 저버리기 때문에 Bird의 서브타입이 아니다._** 따라서 이 둘을 상속 관계로 연결한 위 설계는 수정돼야 한다.

이 문제를 해결하기 위해 주로 초보 개발자들은 `바람직하지 않은 3가지 방법`을 택한다. 아래에서 살펴보자.

`첫 번째 바람직하지 않은 방법`은 `Penguin`의 `fly` 메서드를 오버라이딩 해서 `내부 구현을 비워두는 것`이다.

<script src="https://gist.github.com/BongHoLee/7964751a43f16df22a40e53801800e88.js"></script>

이제 `Penguin`에게 `fly` 메시지를 전송하더라도 아무일도 일어나지 않는다. 따라서 `Penguin`은 날 수 없게 된다. 하지만 **_이 방법은 어떤 행동도 수행하지 않기 때문에 모든 bird가 날 수 있다는 "클라이언트의 기대"를 만족시키지 못하게 된다._** 따라서 올바른 설계라고 할 수 없다. **_이 설계에서 Penguin과 Bird의 행동은 클라이언트의 입장에서 호환되지 않기 때문에 올바르지 않다._**

`두 번째 바람직하지 않은 방법`은 `Penguin`의 `fly` 메서드를 오버라이딩 한 후 `예외`를 던지게 하는 것이다.

<script src="https://gist.github.com/BongHoLee/a76a26dd3c38f0a4ebd7be03e1551a8e.js"></script>

하지만 이 경우에는 `flyBird` 메서드에 전달되는 `인자의 타입에 따라 메서드가 실패하거나 성공`하게 된다. `flyBird` 메서드는 모든 `bird`가 날 수 있다고 가정한다는 사실에 주목하자. **_이 방법 역시 클라이언트의 관점에서 Bird와 Penguin의 행동이 호환되지 않는다._**

`세 번째 바람직하지 않은 방법`은 `flyBird` 메서드를 수정해서 인자로 전달된 `bird`의 타입이 `Penguin`이 아닐 경우에만 `fly` 메서드를 전송하도록 하는 것이다.

<script src="https://gist.github.com/BongHoLee/926892a478a67675869b5ebe176f62ff.js"></script>

하지만 이 방법 역시 문제가 있다. 만약 `Penguin` 이외에 날 수 없는 새가 상속 계층에 추가된다면 어떻게 할 것인가? `flyBird` 메서드 안에서 `instanceof`를 이용해 새로운 타입을 체크하는 코드를 추가해야 할 것이다. **_이것은 new 연산자와 마찬가지로 구체적인 클래스에 대한 결합도를 높인다._** 일반적으로 `instanceof`처럼 객체의 타입을 확인하는 코드는 새로운 타입을 추가할 때 마다 코드 수정을 요구하기 때문에 `개방-폐쇄 원칙`을 위반한다.

이제 `바람직하지 않은 3가지 방법`을 알아봤으니 `바람직한 방법`에 대해서 알아보자.

### 클라이언트의 기대에 따라 계층 분리하기

지금까지 살펴본 것 처럼 `행동 호환성`을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾기란 쉽지 않다. **_문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것 뿐이다._**

`flyBird` 메서드는 `파라미터로 전달되는 모든 bird가 날 수 있다고 가정`하기 때문에 `flyBird` 메서드와 협력하는 모든 객체는 `fly` 메시지에 대해서 `올바르게 응답`할 수 있어야 한다. 따라서 `Penguin`의 인스턴스는 `flyBird` 메서드에 전달되어서는 안된다. 반면 `Penguin`과 협력하는 클라이언트는 날 수 없는 새와 협력할 것이라고 가정할 것이다. 따라서 **_날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족시킬 수 있을 것이다._**

다음 코드는 `날 수 없는 새`와 `날 수 있는 새`의 두 부류가 존재하며, 그 중 펭귄은 날 수 없는 새에 속한다는 사실을 분명하게 표현한다.

<script src="https://gist.github.com/BongHoLee/72660f803f192632de139074b85033a2.js"></script>

이제 `flyBird` 메서드는 `FlyingBird` 타입을 이용해 날 수 있는 새만 인자로 전달돼야 한다는 사실을 코드에 명시할 수 있다. 만약 날 수 없는 새와 협력하는 메서드가 존재한다면 파라미터의 타입을 `Bird`로 선언하면 된다.

<script src="https://gist.github.com/BongHoLee/92d1439a95bcbcc4e27bb385cc0ceb43.js"></script>

아래 그림은 `클라이언트의 기대에 따라 상속 계층을 분리`한 후 클래스의 구조를 나타낸 것이다. **_변경 후에는 모든 클래스들이 "행동 호환성"을 만족시킨다는 사실을 알 수 있다._** `Bird`의 클라이언트는 자신과 협력하는 객체들이 `fly`라는 행동을 수행할 수 없다는 사실을 잘 알고 있다. 따라서 `Penguin`이 `Bird`를 대체하더라도 놀라지 않을 것이다. `FlyingBird` 역시 `Bird`와 행동적인 측면에서 호환 가능한데 `Bird`의 클라이언트는 `fly` 메시지를 전송할 수 없기 때문에 `Bird` 대신 `FlyingBird` 인스턴스를 전달하더라도 문제가 되지 않기 때문이다.

<img src="/assets/img/type4.PNG" width="100%" height="auto">

이제 `FlyingBird` 타입의 인스턴스만이 `fly` 메시지를 수신할 수 있다. 날 수 없는 `Bird`의 서브타입인 `Pengiun`의 인스턴스에게 `fly` 메시지를 전송할 수 있는 방법은 없다. 따라서 잘못된 객체와 협력해서 기대했던 행동이 수행되지 않거나 예외가 던져지는 일은 발생하지 않을 것이다.

이 문제를 해결하는 다른 방법은 `클라이언트에 따라 인터페이스를 분리`하는 것이다. 만약 `Bird`가 날 수 있으면서 걸을 수도 있어야 하고, `Penguin`은 오직 걸을 수만 있다고 가정하자. 다시말해 `Bird`는 `fly`와 `walk` 메서드를 함께 구현하고 `Penguin`은 오직 `walk` 메서드만 구현해야 한다는 것이다. 그리고 오직 `fly` 메시지만 전송하는 클라이언트와 오직 `walk` 메시지만 전송하는 또 다른 클라이언트가 존재한다고 가정해보자.

**_인터페이스는 클라이언트가 기대하는 바에 따라 분리되어야 한다는 것을 기억하자._** 하나의 클라이언트가 오직 `fly` 메시지만 전송하기를 원한다면 이 클라이언트에게는 `fly` 메시지만 보여야 한다. 다른 클라이언트가 오직 `walk` 메시지만 전송하기를 원한다면 이 클라이언트에게는 `walk` 메시지만 보여야 한다. 따라서 가장 좋은 방법은 `fly 오퍼레이션을 가진 Flyer 인터페이스`와 `walk 오퍼레이션을 가진 Walker` 인터페이스로 분리하는 것이다. 이제 `Bird`와 `Penguin`은 자신이 수행할 수 있는 인터페이스만 구현할 수 있다.

<img src="/assets/img/type5.PNG" width="100%" height="auto">

만약 `Penguin`이 `Bird의 코드를 재사용`해야 한다면 어떻게 해야할까? `Pengiun`이 하나의 인터페이스만 구현하고 있기 때문에 문법상으로는 `Penguin`이 `Bird`를 상속받더라도 문제가 안되겠지만 `Penguin`의 퍼블릭 인터페이스에 `fly` 오퍼레이션이 추가되기 때문에 이 방법을 사용할 수는 없다. 게다가 **_재사용을 위한 상속은 위험하다._**

더 좋은 방법은 `합성`을 사용하는 것이다. 물론 **_Bird의 퍼블릭 인터페이스를 이용하여 재사용 가능하다는 전제를 만족시켜야 한다._** 만약 `Bird`의 퍼블릭 인터페이스를 이용해서 재사용하기 어렵다면 `Bird를 약간 수정`해야 할 수도 있을 것이다. **_대부분의 경우 불안정한 상속 계층을 계속 껴안고 가는 것 보다는 Bird를 재사용 가능하도록 수정하는 것이 더 좋은 방법이다._**

<img src="/assets/img/type6.PNG" width="100%" height="auto">

> "클라이언트의 기대에 따라 인터페이스를 분리"하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 된다. 대부분의 경우 인터페이스는 클라이언트의 요구가 바뀜에 따라 변경된다. 클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어할 수 있게 된다.

두번째 윗 그림에서 `Client1`의 기대가 바뀌어서 `Flyer`의 인터페이스가 변경되어야 한다고 가정해보자. 이 경우 `Flyer`에 의존하고 있는 `Bird`가 영향을 받게 된다. 하지만 **_변경의 영향은 Bird에서 끝난다._** `Client2`는 `Flyer`나 `Bird`에 대해 전혀 알지 못하기 때문에 영향을 받지 않는다.

> 이처럼 "인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어"하는 설계 원칙을 "인터페이스 분리 원칙"이라고 부른다.

>> 인터페이스 분리 원칙은 "비대한 인터페이스의 단점"을 해결한다. "비대한 인터페이스"를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스다. 즉, 이런 클래스의 인터페이스는 "메서드의 그룹으로 분해"될 수 있고 각 메서드 그룹은 각기 다른 클라이언트 집합을 지원한다.

>> 비대한 클래스는 그 클라이언트 사이에 이상하고 해로운 결합이 생기게 만든다. 한 클라이언트가 이 비대한 클래스에 변경을 가하면 나머지 모든 클래스가 영향을 받게된다. 그러므로 [클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야 한다.] 이것은 이 비대한 클래스의 인터페이스를 여러 개의 클라이언트에 특화된 인터페이스로 분리함으로써 성취될 수 있다. 이렇게 하면 호출되지 않는 메서드에 대한 클라이언트의 의존성을 끊고, 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다.

이제 변경 후의 설계는 날 수 있는 새와 날 수 없는 새가 존재한다는 현실 세계를 정확하게 반영한다. 하지만 여기서 한 가지 주의해야 할 점이 있다. **_설계가 꼭 현실 세계를 반영할 필요는 없다는 것이다._**

> 중요한 것은 [설계가 반영할 도메인의 요구사항]이고 그 안에서 [클라이언트가 객체에게 요구하는 행동]이다.

현재의 요구사항이 `날 수 있는 행동(fly)`에 관심이 없다면 상속 계층에 `FlyingBird`를 추가하는 것은 설계를 불필요하게 복잡하게 만든다. **_현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야 한다._**

다음에 인용하는 `스콧 마이어스`의 조언은 이 같은 ㅅ아황에서 어떤 자세를 취해야 하는지에 대한 유용한 기준을 제시한다.

> 모든 소프트웨어에 이상적인 설계같은 것은 없다는 사실을 간단히 반증하는 예라고 할 수 있다. 최고의 설계는 제작하려는 소프트웨어 시스템이 기대하는 바에 따라 달라진다. 여러분이 지금 만드는 애플리케이션이 비행에 대한 지식을 전혀 쓰지 않으며 나중에도 쓸 일이 없을것이라면, 날 수 있는 새와 날지 않는 새를 구분하지 않는 것이 탁월한 선택일 수도 있다. 실제로 이런 것들을 잘 구분해서 설계하는 쪽이 바람직하다. 나는 새도 있고 날 수 없는 새도 있다는 사실은 여러분이 본뜨려고 하는 세계가 어떤 것이냐에 따라 고려해도 되고 고려하지 않아도 되기 때문이다.

요점은 `자연어`에 현혹되지 말고 **_요구사항 속에서 클라이언트가 기대하는 행동에 집중하라는 것이다._** 클래스의 이름 사이에 어떤 연관성이 있다는 사실은 아무런 의미가 없다. **_두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입계층이 아니기 때문에 상속을 사용해서는 안된다._**



### 참고 및 출처

  - 오브젝트
