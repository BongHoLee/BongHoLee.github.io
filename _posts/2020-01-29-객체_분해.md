---
layout: post
title: 객체 분해
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 객체 분해

앞선 챕터들에서는 객체지향 설계가 무엇인지, 객체지향적인 설계를 하기 위해서 왜 `협력`이라는 문맥이 중요한지, 그리고 왜 클라이언트의 입장에서 적절한 `책임`을 할당해야하는지 살펴보았다.

또한 `캡슐화, 응집도, 결합도` 측면에서 더 나은 설계를 위해 고려해야할 점들과 주의해야할 점들을 살펴보고 `인터페이스의 설계와 품질`을 다듬기 위해서 준수해야할 `디미터 법칙, 묻지말고 시켜라, 클라이언트의 의도를 드러내는 인터페이스`에 대해서 배웠다.

이번 **_객체 분해_** 장에서는 절차지향 설계에서부터 시작하여 어떤 과정을 거쳐 객체지향까지 흘러들어왔는지의 변천사를 `시스템 분해`에 초점을 맞춰서 설명한다.

챕터의 마지막장을 넘기고 나면 여타 설계들과 비교하여 객체지향적 설계가 갖는 특징과 장점들이 머릿속에 보다 뚜렷하게 남을것이라 기대한다.

---

## 추상화

`추상화`의 목적은 복잡하게 얽히고 섥힌 문제에서 `공통점을 취하고 세부적인 사항은 생략`함으로써 인지과부화를 최소화하고 `문제 해결에 필요한 핵심`에 집중하는 것이다. 다시말해 한 번에 다뤄야 하는 정보의 수를 줄이기 위해 `본질적인 정보만 남기고 불필요한 세부사항을 걸러냄으로써 문제를 단순화`하는 것으로 요약할 수 있다.

가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 `크기`를 줄이는 것이다. 이처럼 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 `분해`라고 한다.

복잡성이 존재하는 곳에 **_추상화와 분해_** 역시 함께 존재한다. 소프트웨어 개발 영역 역시 마찬가지이다.

#### 프로시저 추상화와 데이터 추상화

프로그래밍 언어의 발전은 좀 더 효과적인 `추상화를 이용해 복잡성을 극복`하려는 개발자들의 노력에서 출발하였다.

현대적인 프로그래밍 언어를 특징 짓는 두 가지 중요한 추상화 메커니즘은 `프로시저 추상화`와 `데이터 추상화`이다. 프로시저 추상화는 소프트웨어가 무엇을 `해야하는지(do)`를 추상화한다. 반면에 데이터 추상화는 소프트웨어가 무엇을 `알아야 하는지(know)`를 추상화한다. 소픝웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.

`프로시저 추상화`를 이용하여 시스템을 분해한다면 `기능 분해`의 길을 따르게 된다. 그리고 `데이터 추상화`를 이용하여 시스템을 분해한다면 다시 두 가지 길을 따르게 되는데 하나는 데이터를 중심을 타입을 추상화 하는 `추상 데이터 타입`이고 또 다른 하나는 데이터를 중심으로 프로시저를 추상화하는 `객체지향`이다.

>전통적인 기능 분해 방법에 비해 객체지향이 효과적이라고 말하는 이유가 무엇일까? 먼저 전통적인 기능 분해 방법을 살펴보자.

---

#### 프로시저 추상화와 기능 분해

프로시저를 추상화라고 부르는 이유는 **_내부의 상세한 구현을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다._** 따라서 프로시저는 잠재적으로 정보은닉의 가능성을 제시하지만 뒤에서 살펴보는 것 처럼 **_프로시저만으로 효과적인 정보은닉 체계를 구축하는데에는 한계가 있다._**

전통적인 기능분해 방법은 `하향식 접근법`을 따른다. 하향식 접근법이란 시스템을 구성하는 가장 **_최상위_** 기능을 정의하고 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다. 다시말해 하위 기능은 상위 기능보다 **_덜 추상적_** 이어야 한다.

기능 분해 방법에서는 **_기능을 중심으로 필요한 데이터를 결정한다._** 기능 분해라는 무대의 주연은 `기능`이며 데이터는 기능을 보조하는 조연의 역할에 머무른다. **_기능이 우선이고 데이터는 기능의 뒤를 따른다._**

>기능분해를 위한 하향식 접근법은 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.

이것은 `유지보수`에 다양한 문제를 야기한다. 왜 그런지 하향식 기능 분해 방식으로 구현한 코드를 살펴보자.

<script src="https://gist.github.com/BongHoLee/df49c00379640f62972f949c77fe41c5.js"></script>

위 코드에서 알 수 있는 것처럼 **_하향식 기능분해는 시스템을 최상위의 가장 추상적인 메인함수로 정의하고, 메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해하는 방법이다._**

---

#### 하향식 기능 분해의 문제점

하향식 기능 분해 방법은 겉으로는 이상적인 방법으로 보일 수 있지만 실제로 설계에 적용하다 보면 다음과 같은 다양한 문제에 직면하게 된다.

>시스템은 하나의 메인함수로 구성되어있지 않다.

>기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.

>비즈니스 로직이 사용자 인터페이스와 강하게 결합된다. (위 코드에서는 console 입력과 같은 커맨드)

>하향식 분해는 너무 이른 시기에 함수들의 실행순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.

>데이터 형식이 변경될 경우 파급 효과(side effect)를 예측할 수 없다.

`설계는 코드 배치 방법이며 설계가 필요한 이유는 변경에 대비하기 위함`이라는 것을 기억하자. 변경은 소프트웨어가 맞이해야 하는 피할 수 없는 운명이다.

안타깝게도 위 목록들을 통해 알 수 있는 것 처럼 하향식 접근법과 기능 분해가 가지는 근본적인 문제점은 **_변경에 취약한 설계를 낳는다는 것_** 이다.

#### 하나의 메인함수라는 비현실적인 아이디어

대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않는다. 모든 기능들은 동등하게 독립적이고 완결된 하나의 기능을 표현한다. 하향식 접근법은 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는데는 적합하지 않다.

#### 메인 함수의 빈번한 재설계

시스템 안에는 여러 개의 정상(기능)이 존재하기 때문에 결과적으로 하나의 메인함수를 유일한 정상으로 간주하는 하향식 기능분해의 경우에는 **_새로운 기능을 추가할 때 마다 매번 메인함수를 수정해야 한다._**

>기존 로직과는 아무런 상관이 없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 함수의 구조를 급격하게 변경할 수 밖에 없다.

위의 급여 관리 시스템에서 **_회사에 속한 모든 직원들의 기본급의 총합을 구하는 기능을 추가해 달라는 새로운 요구사항_** 접수가 되었다고 가정하자. 구현 자체를 놓고 봤을 때는 전역 변수 `basePays` 배열에 저장되어있는 모든 기본급을 더하기만 하면 되는 간단한 작업이다.

<script src="https://gist.github.com/BongHoLee/88ccc9198c90bd292bb68772831073cf.js"></script>

문제는 **_기존의 메인 함수는 직원 각각의 급여를 계산하는 것이 목적_** 이기 때문에 전체 직원들의 기본급 총 합을 계산하는 함수가 들어설 자리가 마땅치 않다는 것이다.

<script src="https://gist.github.com/BongHoLee/da00f96810d89d541ac7755eb4ef1d8f.js"></script>

현재 코드에서 전체 직원의 급여 총액을 계산하는 `sumOfBasePays` 함수와 개별 직원의 급여를 계산하는 `main` 함수는 **_개념적으로 동등한 수준의 작업을 수행한다._** 따라서 현재의 main 함수 안에서 `sumOfBasePays` 함수를 호출할 수는 없다.

이 문제를 해결하는 방법은 `현재의 main 함수 안의 로직 전체를 calculatePay라는 함수로 추출한 후 main 함수 안에서 적절하게 sumOfBasePays 함수와 calculatePay 함수를 호출하는 것이다.`

<script src="https://gist.github.com/BongHoLee/d91fb0c1abef3cfbcc1a0e038340a74c.js"></script>

이 간단한 예제는 **_하나의 정상인 메인 함수에서 출발한다는 하향식 접근법의 기본 가정에 어떤 문제가 있는지를 잘 보여준다._** 시스템은 여러개의 정상으로 구성되기 때문에 `sumOfBasePays` 함수와 같은 새로운 정상을 추가할 때 마다 하나의 정상이라고 간주했던 main 함수 내부를 수정할 수 밖에 없다. **_결과적으로 기존 코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 변경에 취약해질 수밖에 없다._**

#### 성급하게 결정된 실행순서

>하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다. 이것을 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만든다.

**_직원의 급여를 계산하려면 어떤 작업이 필요한가?_** 와 같이 하향식 접근법의 첫 번째 질문은 `무엇(what)`이 아니라 `어떻게(how)`이다.

하향식 접근법의 설계는 처음부터 구현을 염두에 두기 때문에 자연스럽게 **_함수들의 실행 순서를 정의하는 시간 제약을 강조한다._** 메인 함수가 작은 함수들로 분해되기 위해서는 우선 `함수들의 순서`를 결정해야 한다. 함수들의 실행 순서를 미리 결정하지 않고서는 `기능 분해`를 할 수 없다.

> 실행 순서나 조건, 반복과 같은 제어구조를 미리 결정하지 않고는 분해를 진행할 수 없기 때문에 기능 분해 방식은 중앙집중 제어스타일의 형태를 띨 수 밖에 없다. 결과적으로 모든 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출된다.

문제는 중요한 설계 사항인 `함수의 제어구조`가 빈번한 변경의 대상이라는 점이다. 기능이 추가되거나 변경될 때 마다 초기에 결정된 함수들의 제어구조가 올바르지 않다는 것이 판명된다. 결과적으로 기능을 추가하거나 변경하는 작업은 매번 기존에 결정된 함수의 제어구조를 변경하도록 만든다.

이를 해결할 수 있는 한 가지 방법은 **_자주 변경되는 시간적인 제약에 대한 미련을 버리고 좀 더 안정적인 논리적 제약을 설계의 기준으로 삼는 것이다._** 객체지향은 함수간의 호출순서가 아니라 `객체 사이의 논리적인 관계`를 중심으로 설계를 이끌어 나간다. 결과적으로 하나의 시스템은 어떤 한 구성요소로 제어가 집중되지 않고 **_여러 객체들 사이로 제어 주체가 분산된다._**

>하향식 접근법을 통해 분해한 함수들은 재사용하기가 어렵다. 모든 함수는 상위 함수를 분해하는 과정에서 필요에 따라 식별되며, 그에 따라 상위 함수가 강요하는 문맥(Context) 안에서만 의미를 가지기 때문이다.

하향식 설계와 관련된 모든 문제의 원인은 `결합도`이다. 함수는 상위 함수가 강요하는 문맥에 강하게 결합된다. 또한 함수는 **_함께 절차를 구성하는 다른 함수들과 시간적으로 강하게 결합된다._** 강한 결합도는 시스템을 변경에 취약하게 만들고 이해하기도 어렵게 만든다. 가장 큰 문제는 전체 시스템의 핵심적인 구조를 결정하는 함수들이 `데이터와 강하게 결합`된다는 것이다.

#### 데이터 변경으로 인한 파급효과

하향식 기능분해의 가장 큰 문제점은 **_어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다._** 따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.

>데이터 변경으로 인한 영향은 데이터를 직접 참조하는 모든 함수로 퍼져나간다.

하향식 기능 분해 방법이 데이터 변경에 얼마나 취약한지 이해하기 위해 급여 관리 시스템에 새로운 기능을 추가해보자. 정규 직원과는 다르게 계산되는 아르바이트 직원에 대한 급여 계산 기능을 개발해달라는 요청이 들어왔다고 가정해보자.

`아르바이트 직원`의 이름과 시급은 `정규 직원`의 이름과 기본급을 보관하던 전역변수 `employees`와 `basePays`에 함께 보관하기로 했다. `employees`와 `basePays`의 각 인덱스에 위치한 정보가 정규 직원의 것인지, 아르바이트 직원의 것인지 여부를 결정하는 새로운 전역변수인 `hourlys`를 추가했다. `hourlys`의 특정 인덱스의 값이 `true`일 경우에는 아르바이트 직원에 대한 정보를, `false`인 경우에는 정규 직원에 대한 정보를 나타낸다.

```Java
String[] employees = {"직원A", "직원B", "직원C", "아르바이트D", "아르바이트E", "아르바이트F"};
int[] basePays     = {400, 300, 250, 1, 1, 2};
boolean[] hourlys  = {false, false, false, true, true, true};
```

아르바이트 직원의 급여를 계산하기 위해서는 한달 간의 업무 누적 시간이 필요하다. 이 값은 전역 변수 `timeCards`에 보관하기로 했다. 정규 직원의 경우 이 값은 0이다.

```Java
int[] timeCards = {0, 0, 0, 120, 120, 120};
```

지금까지 애플리케이션 안의 데이터를 수정했다. 이제 기존에 `employees`와 `basePays`를 사용한 함수들 중에서 아르바이트 직원을 함께 처리해야 하는 함수를 찾아 수정해야 한다. 물론 `hourlys`와 `timeCards`에 저장된 값도 함께 사용하도록 수정해야 할 것이다.

말은 쉽지만 사실 이 작업은 **_시스템 안에 구현된 모든 함수를 분석해서 영향도를 파악해야 한다는 것을 의미한다._** 먼저 기존의 `calculatePay` 함수에 조건 분기를 추가해야 한다. 정규 직원과 아르바이트 직원에 대한 급여를 다른 방식으로 계산하기 위해서는 직원의 종류가 무엇인지를 파악하고 그에 따라 적절한 로직을 실행해야 한다.

아르바이트 직원의 급여를 계산하는 `calculateHorlyPayFor` 함수는 시급에 한달 동안 일한 시간을 곱해서 급여를 계산한다.
<script src="https://gist.github.com/BongHoLee/afa1497ee2b0c063ff441e383da03b95.js"></script>

정규 직원과 아르바이트 직원을 판단하는 `isHourly` 함수도 추가하자. 이 함수는 직원이 아르바이트 직원이면 true를 반환환다.
<script src="https://gist.github.com/BongHoLee/c33012091111ae993f7246018002fc4d.js"></script>

이제 기존의 `calculatePay` 함수를 수정한다. 직원이 아르바이트 직원이면 `calculateHorlyPayFor` 함수를 호출하고 정규 직원이면 기존의 `calculatePayFor` 함수를 실행한다.
<script src="https://gist.github.com/BongHoLee/eb2a05961957403a18874764540fe632.js"></script>

모든 코드의 수정이 완료되었을까? 안타깝게도 운영환경에 배포되고 난 다음 날 사용자로부터 직원들의 모든 기본급을 더한 `sumOfBasePays` 함수의 결과가 이상하다는 리포트가 전달되기 시작했다. 오랜 디버깅 끝에 `basePays`와 `employees`에 아르바이트 직원에 대한 정보를 추가했기 때문이라는 사실을 알아낼 수 있었다. 모든 직원의 기본급의 총합을 더하는 `sumOfBasePays` 함수도 함께 수정해야 했던 것이다.

현재의 `basePays`에는 정규 직원의 기본급 뿐만 아니라 아르바이트 직원의 시급도 저장되어 있기 때문에 시급을 총합에서 제외해야 한다.
<script src="https://gist.github.com/BongHoLee/63c8ff5f117806c8340fabad54d4e88b.js"></script>

이 예제가 말해주는 것은 **_데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것이 생각보다 쉽지 않다는 것이다._** 새로운 요구사항은 아르바이트 직원에 대한 급여도 계산할 수 있도록 시스템을 개선해달라는 것이었다. 이를 위해 아르바이트 직원을 위한 데이터를 추가하고 급여를 계산하는 `calculatePay` 함수도 수정했다. 하지만 이 수정으로 인해 `sumOfBasePays` 함수도 영향을 받는다는 사실을 알지 못했기 때문에 버그가 발생한 것이다.

> 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다. 이를 위해 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해서 데이터에 접근해야 한다.

다시말해 `잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제`해야 하는 것이다.

이것이 바로 의존성 관리의 핵심이다. **_변경에 대한 영향을 최소화 하기 위해 영향을 받는 부분과 받지 않는 부분을 명확하게 분리하고 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하라._**

---

### 모듈

#### 정보은닉과 모듈

앞서 설명한 것처럼 **_시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다._** 즉, 기능을 기반으로 시스템을 분해하는 것이 아니라 `변경의 방향`에 맞춰 시스템을 분해하는 것이다.

`정보은닉`은 시스템을 모듈단위로 분해하기 위한 기본 원리로 **_시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다._**

 >정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할의 원리이다. 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의도고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공하여 내부의 비밀에 함부로 접근하지 못하게 한다.

 `기능 분해`가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면 `모듈 분해`는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다. 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.

 >시스템을 모듈 단위로 어떻게 분해할 것인가? 시스템이 감춰야 하는 비밀을 찾아라. 외부에서 내부의 비밀에 접근하지 못하도록 커다란 방어막을 쳐서 에워싸라. 이 방어막이 바로 퍼블릭 인터페이스가 된다.

 모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

 **_1. 복잡성 : 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다._**

 **_2. 변경 가능성 : 변경 가능한 설계 결정이 외부에 놏루될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다._**

 앞선 급여 관리 시스템의 예에서 알 수 있는 것처럼 `시스템의 가장 일반적인 비밀은 데이터다.` 이때문에 `데이터 캡슐화`와 `정보은닉`을 혼동스럽게 만든 것으로 보인다. 비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있다.

다음은 전체 직원에 관한 처리를 `Employees` 모듈로 캡슐화한 결과를 나타낸 것이다.
<script src="https://gist.github.com/BongHoLee/09b2632da696caeb82bf9f9f6138971c.js"></script>

지금까지 전역 변수였던 `employees, basePays, hourlys, timeCards`가 `Employees`라는 모듈 내부로 숨겨져 있다는 것에 주목하라. 이제 외부에서는 직원 정보를 관리하는 **_데이터에 직접 접근할 수 없다._** 외부에서는 `Employees` 모듈이 제공하는 퍼블릭 인터페이스에 포함된 `calcuatePay, hourly?, calculateHourlyPayFor, calculatePayFor, sumOfBasePays` 함수를 통해서만 내부 변수를 조작할 수 있다. 심지어 모듈 외부에서는 모듈 내부에 어떤 데이터가 존재하는지조차 알지 못한다.

이제 `main` 함수가 `Employees` 모듈의 기능을 사용하도록 코드를 수정하면 된다.







### 참고 및 출처
  - 오브젝트
