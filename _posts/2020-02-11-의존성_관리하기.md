---
layout: post
title: 의존성 관리하기
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 의존성 관리하기

객체지향 설계에 있어서 가장 많이 들어본 원칙들이 있을것이다. 그리고 그 중 하나가 바로 `느슨한 결합도`가 아닐까 싶다. 이번 장에서는 객체지향 설계에있어 중요한 부분인 `느슨한 결합도`를 위해 신경써야 하는 `의존성 관리`에 대해서 배워보려 한다. 의존성이란 무엇인지, 왜 의존성 관리가 중요한지, 그리고 어떻게 의존성을 해결하는지 차근차근 알아가보자.

---

## 들어가며

잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다. **_작고 응집도 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체를 의미한다._** 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 일반적인 애플리케이션의 기능을 구현하기 위해서는 다른 객체에게 도움을 요청해야 한다. 이런 요청이 객체 사이의 협력을 낳는다.

>협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠뜨릴 수 있다.

협력은 객체가 다른 객체에 대해 알 것을 강요한다. **_다른 객체와 협력하기 위해서는 그런 객체가 존재한다는 사실을 알고 있어야 한다._** 물론 객체가 수신할 수 있는 `메시지`에 대해서도 알고 있어야 한다. 이런 `지식`이 객체 사이의 `의존성`을 낳는다.

협력을 위해서는 의존성이 필요하지만 **_과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다._**

>객체지향 설계의 핵심은 협력을 위해 필요한 의존성을 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.

이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.


---

## 의존성 이해하기

#### 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다. 의존성은 `실행 시점`과 `구현 시점`에 서로 다른 의미를 갖는다.

```
실행 시점 : 의존하는 객체(클라이언트 객체)가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체(서버, 의존 객체)가 반드시 존재해야 한다.

구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
```

설명을 잘 이해하기 위해 `PeriodCondition` 클래스를 이용해 의존성의 개념을 설명해보겠다.
<script src="https://gist.github.com/BongHoLee/0ddb06c5a5056973807fd3637663d78a.js"></script>

실행 시점에 `PeriodCondition`의 인스턴스가 정상적으로 동작하기 위해서는 `Screening`의 인스턴스가 존재해야 한다. 만약 `Screening`의 인스턴스가 존재하지 않거나 **_getStartTime()_** 메시지를 이해할 수 없다면 `PeriodCondition`의 **_isSatisfiedBy()_** 메서드는 예상했던 대로 동작하지 않을 것이다.

이처럼 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 `의존성`이 존재한다고 말한다.

>의존성은 방향을 가지며 항상 단방향이다.

`Screening`이 변경될 때 `PeriodCondition`이 영향을 받게 되지만 그 역은 성립하지 않는다. 이 경우 `PeriodCondition`은 `Screening`에 의존한다.

지금까지 주의깊게 살펴본 사람이라면 아마 설계와 관련된 대부분의 용어들이 `변경`과 관련이 있다는 사실을 눈치챘을 것이다. 두 요소 사이의 의존성은 `의존 객체가 변경될 경우 클라이언트 객체도 함께 변경될 수 있다는 것을 의미`한다.

>의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

`PeriodCondition`의 코드를 다시 살펴보자.

`PeriodCondition`은 `DayOfWeek`과 `LocalTime`의 인스턴스를 속성으로 포함한다.
`PeriodCondition`은 **_isSatisfiedBy_** 메서드의 인자로 `Screening`의 인스턴스를 받는다.
`PeriodCondition`은 `DayOfWeek`의 인스턴스에게 **_compareTo_** 메시지를 전송한다.
`PeriodCondition`은 `Screening`의 인스턴스에게 **_getStartTime_** 메시지를 전송한다.

따라서 `PeriodCondition`은 `DayOfWeek, LocalTime, Screening`에 대해 의존성을 갖는다.

`DayOfWeek`의 클래스 명을 변경한다고 가정해보자. 이 경우 `PeriodCondition` 클래스에 정의된 인스턴스 변수의 타입 선언도 함께 수정해야 한다. 이것은 `LocalTime, Screening`에 대해서도 마찬가지다. 만일 `DiscountCondition` 인터페이스의 이름이 변경된다면 어떻게 될까? `DiscountCondition`에 선언된 **_isSatisfiedBy_** 오퍼레이션의 시그니처가 변경된다면 어떻게 될까? `DiscountCondition`의 인터페이스를 실체화 하고 있는 `PeriodCondition` 클래스 역시 어떤 식으로든 함께 수정해야 할 것이다. 여기서 요점은 어떤 형태로든 `DayOfWeek, LocalTime, Screening, DiscountCondition`이 변경된다면 `PeriodCondition`도 함께 변경될 수 있다는 것이다.

비록 위의 의존성들이 각자 `인스턴스 변수, 메서드 인자, 인터페이스 타입`과 같이 다른 성질을 갖고있지만 근본적으로 의존성이 갖는 특성은 동일하다. `PeriodCondition`은 자신이 의존하고 있는 대상이 변경될 때 함꼐 변경될 수 있다는 것이다.

---

#### 런타임 의존성과 컴파일 타임 의존성

의존성과 관련해서 다뤄야 하는 또 다른 주제는 `런타임 의존성`과 `컴파일 타임 의존성`의 차이다.

객체지향 애플리케이션에서 `런타임의 주인공은 객체`이다. 따라서 런타임 의존성이 다루는 주제는 `객체 사이의 의존성`이다.

반면 `코드 관점에서의 주인공은 클래스`이다. 따라서 컴파일 타임 의존성이 다루는 주제는 `클래스 사이의 의존성`이다.

여기서 중요한 것은 **_런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것이다._** 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 **_런타임 의존성과 컴파일타임 의존성을 서로 다르게 만들어야 한다._**

영화 예매 시스템을 예로 들어보자 `Movie`는 가격을 계산하기 위해 `비율 할인 정책`과 `금액 할인 정책` 모두를 적용할 수 있게 설계해야 한다. 다시 말해서 `Movie`는 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 모두와 협력할 수 있어야 한다. 이를 위해 `AmountDiscountPolicy`와 `PercentDiscountPolicy`가 추상 클래스인 `DiscountPolicy`를 상속받게 한 후 `Movie`가 이 추상 클래스에 의존하도록 클래스를 설계하였다.

여기서 중요한 것은 `Movie`클래스에서 `AmountDiscountPolicy` 클래스와 `PercentDiscountPolicy` 클래스로 향하는 어떤 의존성도 존재하지 않는다는 것이다. `Movie` 클래스는 오직 추상 클래스인 `DiscountPolicy` 클래스에만 의존한다. `Movie` 클래스의 코드를 보면 `AmountDiscountPolicy`나 `PercentDiscountPolicy`에 대해서는 언급조차 하지 않는다는 것을 알 수 있다.

<script src="https://gist.github.com/BongHoLee/14d2565baeb4377a82ccf304adf96228.js"></script>

하지만 런타임 의존성을 살펴보면 상황이 완전히 달라진다. `금액 할인 정책`을 적용하기 위해서 `AmountDiscountPolicy`의 인스턴스와 협력해야 한다. `비율 할인 정책`을 적용하기 위해서는 `PercentDiscountPolicy`의 인스턴스와 협력해야 한다. 코드를 작성하는 시점의 `Movie` 클래스는 `AmountDiscountPolicy` 클래스와 `PercentDiscountPolicy`에 대해서 전혀 알지 못하지만 실행 시점의 `Movie` 인스턴스는 `AmountDiscountPolicy` 인스턴스와 `PercentDiscountPolicy` 인스턴스와 협력할 수 있어야 한다.

만약 `Movie` 클래스가 `AmountDiscountPolicy` 클래스에 대해서만 의존한다면 `PercentDiscountPolicy` 인스턴스와 협력하는 것은 불가능 할 것이다. 물론 그 반대도 마찬가지 이다. `Movie` 클래스가 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 클래스 둘 모두에 의존하도록 만드는 것은 좋은 방법이 아닌데, 이것은 `Movie`의 전체적인 결합도를 높일 뿐 아니라 새로운 할인 정책을 추가하기 위해서는 `Movie` 내부 구현 코드를 수정해야 하기 때문이다.

**_Movie의 인스턴스가 이 두 클래스의 인스턴스와 함께 협력할 수 있게 만드는 더 나은 방법은 Movie가 두 클래스 중 어떤 것도 알지 못하게 만드는 것이다. 대신 두 캘르스를 모두 포괄하는 DiscountPolicy라는 추상 클래스에 의존하도록 만들고 이 컴파일타임 의존성을 실행 시에 PercentDiscountPolicy 인스턴스나 AmountDiscountPolicy 인스턴스에 대한 런타임 의존성으로 대체해야 한다._**

코드 작성 시점의 `Movie 클래스`는 할인 정책을 구현한 두 클래스의 존재를 모르지만 실행 시점의 `Movie 객체`는 두 클래스의 인스턴스와 협력할 수 있게 된다. 이것이 핵심이다. 유연하고 재사용 가능한 설계를 창조하기 위해서는 `동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.`

> 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다. 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.

클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다. 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용이 가능해진다.

---

#### 컨텍스트 독립성

이제 유연하고 확장 가능한 설계를 만들기 위해서는 `컴파일타임 의존성`과 `런타임 의존성`이 달라야 한다는 사실을 이해했을 것이다. **_클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다._**

>구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는 것과 같다.

`Movie` 클래스 안에 `PercentDiscountPolicy` 클래스에 대한 컴파일타임 의존성을 명시적으로 표현하는 것은 `Movie`가 `비율 할인 정책`이 적용된 영화의 요금을 계산하는 문맥에서 사용될 것이라는 것을 가정하는 것이다. 이와 달리 `Movie` 클래스에 추상 클래스인 `DiscountPolicy`에 대한 컴파일타임 의존성을 명시하는 것은 `Movie`가 할인 정책에 따라 요금을 계산하지만 구체적으로 어떤 정책을 따르는지는 결정하지 않았다고 선언하는 것이다. 이 경우 구체적인 문맥은 컴파일타임 의존성을 어떤 런타임 의존성으로 대체하느냐에 따라 달라질 것이다.

> 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 컨텍스트 독립성이라고 부른다.

> 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다. 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.

이제 마지막 연결고리만 남았다. 클래스가 실행 컨텍스트에 독립적인데도 **_어떻게 런타임에 실행 컨텍스트에 적절한 객체들과 협력할 수 있을까?_**

---

#### 의존성 해결하기

`컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.` 이처럼 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 `의존성 해결`이라고 부른다. 의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다.

>1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결

>2. 객체 생성 후 setter 메서드를 통해 의존성 해결

>3. 메서드 실행 시 인자를 이용해 의존성 해결

예를 들어, 어떤 영화의 요금 계산에 `금액 할인 정책`을 적용하고 싶다고 가정해보자. 다음과 같이 `Movie` 객체를 생성할 때 `AmountDiscountPolicy`의 인스턴스를 `Movie`의 생성자에 인자로 전달하면 된다.
<script src="https://gist.github.com/BongHoLee/45c220730909f59c10ebe4b3383c9e68.js"></script>

`Movie`의 생성자에 `PercentDiscountPolicy`의 인스턴스를 전달하면 `비율 할인 정책`에 따라 요금을 계산하게 될 것이다.
<script src="https://gist.github.com/BongHoLee/6fb4f761efc08620a327e0696a88274a.js"></script>

이를 위해 `Movie` 클래스는 `PercentDiscountPolicy` 인스턴스와 `AmountDiscountPolicy` 인스턴스 모두를 `선택적으로 전달`받을 수 있도록 이 두 클래스의 부모 클래스인 `DiscountPlicy` 타입의 인자를 받는 생성자를 정의한다.
<script src="https://gist.github.com/BongHoLee/a497f84cf0dc4a91ca0700c9b61e2174.js"></script>

`Movie`의 인스턴스를 생성한 후에 메서드를 이용해 의존성을 해결하는 방법도 있다.
<script src="https://gist.github.com/BongHoLee/2785fefab65c2607ee4d63a820164be2.js"></script>

이 경우 `Movie` 인스턴스가 생성된 후에도 `DiscountPolicy`를 설정할 수 있는 `setter 메서드`를 제공해야 한다.
<script src="https://gist.github.com/BongHoLee/23f11cfdad8abc6c13a8867101f7d201.js"></script>

`setter 메서드`를 이용하는 방식은 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열어놓고 싶은 경우에 유용하다. 즉, `실행 시점에 의존 대상을 변경`할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다. 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전 까지는 객체의 상태가 불완전할 수 있다는 것이다.

보다 좋은 방법은 `생성자 방식과 setter 방식을 혼합`하는 것이다. 항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후, 필요에 따라 setter 메서드를 이용해 의존 대상을 변경할 수 있게 할 수 있다. 이 방법은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호되는 방법이다.

---

## 유연한 설계

#### 의존성과 결합도

객체지향 패러다임의 근간은 `협력`이다. 객체들은 협력을 통해 애플리케이션에 생명력을 불어넣는다. **_객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다._** 이런 지식들이 객체 사이의 의존성을 낳는다. 따라서 `모든 의존성이 나쁜것은 아니다.` 의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서는 바람직한 것이다. 하지만 `의존성이 과하면 문제가 될 수 있다.`

`Movie`가 `비율 할인 정책`을 구현하는 `PercentDiscountPolicy`에 직접 의존한다고 가정해보자.

<script src="https://gist.github.com/BongHoLee/ea1934c643a1d600b6676555b9df6912.js"></script>

이 코드는 비율 할인 정책을 적용하기 위해 `Movie`가 `PercentDiscountPolicy`에 의존하고 있다는 사실을 코드를 통해 명시적으로 드러낸다. 문제는 의존성의 존재가 아니라 `의존성의 정도`이다. 이 코드는 `Movie`를 `PercentDiscountPolicy`라는 구체적인 클래스에 의존하게 만들었기 때문에 다른 종류의 할인 정책이 필요한 문맥에서 `Movie`를 재사용 할 수 있는 가능성을 없애버렸다. 만약 `Movie`가 `PercentDiscountPolicy`뿐만 아니라 `AmountDiscountPolicy`와도 협력해야 한다면 어떻게 해야할까?

해결 방법은 의존성을 바람직하게 만드는 것이다. `Movie`가 협력하고 싶은 대상이 반드시 `PercentDiscountPolicy`의 인스턴스일 필요는 없다는 사실에 주목하라. 사실 `Movie`의 입장에서는 협력할 객체의 클래스를 고정할 필요가 없다. 자신이 전송하는 `calculateDiscountAmount` 메시지를 이해할 수 있고 할인된 요금을 계산할 수만 있다면 어떤 타입의 객체와 협력하더라도 상관이 없다.

추상 클래스인 `DiscountPolicy`는 `calculateDiscountAmount`메시지를 이해할 수 있는 타입을 정의함으로써 이 문제를 해결한다. `AmountDiscountPolicy` 클래스와 `PercentDiscountPolicy` 클래스가 `DiscountPolicy`를 상속받고 `Movie` 클래스는 오직 `DiscountPolicy`에만 의존하도록 만듦으로써 `DiscountPolicy` 클래스에 대한 `컴파일타임 의존성`을 `AmountDiscountPolicy` 인스턴스와 `PercentDiscountPolicy` 인스턴스에 대한 `런타임 의존성`으로 대체할 수 있다.

`바람직한 의존성`이란 무엇인가? 바람직한 의존성은 `재사용성`과 관련이 있다.

>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다. 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.

>컨텍스트 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

**_특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것 뿐이다._** `Movie`가 `PercentDiscountPolicy`에 의존하고 있는 경우에 `Movie`를 `AmountDiscountPolicy`와 협력하도록 만들고 싶다면 어떻게 해야할까? 방법은 하나밖에 없다. `percentDiscountPolicy`의 타입을 `PercentDiscountPolicy`에서 `AmountDiscountPolicy`로 변경하는 것이다. 하지만 이 수정으로 인해 이번에는 `Movie`가 `AmountDiscountPolicy`에 강하게 결합된다. 결국 이것은 바람하지 못한 의존성을 또 다른 바람직하지 못한 의존성으로 대체한 것 뿐이다.

>다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 것은 바람직하지 못한 의존성이다.

어떤 두 요소 사이에 의존성이 바람직 할 경우 `느슨한 결합도`라고 부르고 바람직하지 못할 경우 `강한 결합도`라고 부른다.

바람직한 의존성이란 설계를 `재사용`하기 쉽게 만드는 의존성이다. 바람직하지 못한 의존성이란 설계를 재사용하기 어렵게 만드는 의존성이다. 어떤 의존성이 `재사용`을 방해한다면 결합도가 강하다고 표현한다. 어떤 의존성이 재사용을 쉽게 허용한다면 결합도가 느슨하다고 표현한다.

`Movie` 클래스가 추상 클래스인 `DiscountPolicy`에 의존하면 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 모두와 협력할 수 있다. 따라서 `Movie`와 `DiscountPolicy`는 느슨하게 결합된다.

---

#### 지식이 결합을 낳는다.

앞에서 `Movie`가 `PercentDiscountPolicy`에 의존하는 경우에는 결합도가 강하다고 표현했다. 반면 `Movie`가 `DiscountPolicy`에 의존하는 경우에는 결합도가 느슨하다고 표현했다. **_결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고있는 정보의 양으로 결정된다._** 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다. 반대로 한 요소가 다른 요소에 대해 더 적은 정보를 알고 있을수록 두 요소는 약하게 결합된다.

더 많이 알수록 더 많이 결합된다. **_더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미한다._** 기존 지식에 어울리지 않는 컨텍스트에서 클래스의 인스턴스를 사용하기 위해서 할 수 있는 유일한 방법은 클래스를 수정하는 것 뿐이다. 결합도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야 한다. 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.

느슨한 결합도를 위한 방법으로 필요한 정보만을 제공하는 대상에 의존하는 방법은 어떤 것이 있을까? 바로 `추상화`이다.

---

#### 추상화에 의존하라

추상화란 어떤 양상, 세부사항, 구조를 좀더 명확하게 이해하기 위해 `특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법`이다. 추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다. 따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.

`DiscountPolicy` 클래스는 `PercentDiscountPolicy` 클래스가 `비율 할인 정책`에 따라 할인 요금을 계산한다는 사실을 숨겨주기 때문에 `PercentDiscountPolicy`의 추상화다. 따라서 `Movie` 클래스의 관점에서 협력을 위해 알아야 하는 지식의 양은 `PercentDiscountPolicy`보다 `DiscountPolicy` 클래스가 더 적다.

> Movie와 DiscountPolicy 사이의 결합도가 더 느슨한 이유는 Movie가 구체적인 대상이 아닌 추상화에 의존하기 때문이다.

```
구체 클래스 의존성 > 추상 클래스 의존성 > 인터페이스 의존성
```

위 내용과 같이 `구체 클래스`가 가장 결합도가 강하고 그 다음으로 `추상 클래스`, 가장 느슨한 결합도를 얻을 수 있는 추상화는 `인터페이스`이다.

`구체 클래스`에 비해 `추상 클래스`는 메서드의 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다. 따라서 클라이언트가 알아야 하는 지식의 양이 더 적기 때문에 `구체 클래스`보다 `추상 클래스`에 의존하는 것이 결합도가 더 낮다. 하지만 `추상 클래스`의 클라이언트는 여전히 협력하는 대상이 속한 클래스 상속 계층이 무엇인지에 대해서는 알고 있어야 한다.

`인터페이스`에 의존하면 상속 계층을 모르더라도 협력이 가능해진다. 인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다. 이것은 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있도록 컨텍스트를 확장하는 것을 가능하게 한다.

여기서 중요한 것은 `실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 더 낮아진다는 것`이다. 결합도를 느슨하게 만들기 위해서는 구체적인 클래스보다는 추상 클래스에, 추상 클래스보다 인터페이스에 의존하도록 만드는 것이 더 효과적이다. 다시 말해 `의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다` 이것이 핵심이다.

---

#### 명시적인 의존성

아래 코드는 한 가지 실수로 인해 결합도가 불필요하게 높아졌다. 그 실수는 무엇일까?
<script src="https://gist.github.com/BongHoLee/ab38c41228303107e65cfec93e56f407.js"></script>









### 참고 및 출처
  - 오브젝트
