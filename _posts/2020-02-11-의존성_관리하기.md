---
layout: post
title: 의존성 관리하기
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 의존성 관리하기

객체지향 설계에 있어서 가장 많이 들어본 원칙들이 있을것이다. 그리고 그 중 하나가 바로 `느슨한 결합도`가 아닐까 싶다. 이번 장에서는 객체지향 설계에있어 중요한 부분인 `느슨한 결합도`를 위해 신경써야 하는 `의존성 관리`에 대해서 배워보려 한다. 의존성이란 무엇인지, 왜 의존성 관리가 중요한지, 그리고 어떻게 의존성을 해결하는지 차근차근 알아가보자.

---

## 들어가며

잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다. **_작고 응집도 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체를 의미한다._** 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 일반적인 애플리케이션의 기능을 구현하기 위해서는 다른 객체에게 도움을 요청해야 한다. 이런 요청이 객체 사이의 협력을 낳는다.

>협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠뜨릴 수 있다.

협력은 객체가 다른 객체에 대해 알 것을 강요한다. **_다른 객체와 협력하기 위해서는 그런 객체가 존재한다는 사실을 알고 있어야 한다._** 물론 객체가 수신할 수 있는 `메시지`에 대해서도 알고 있어야 한다. 이런 `지식`이 객체 사이의 `의존성`을 낳는다.

협력을 위해서는 의존성이 필요하지만 **_과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다._**

>객체지향 설계의 핵심은 협력을 위해 필요한 의존성을 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.

이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.


---

## 의존성 이해하기

#### 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다. 의존성은 `실행 시점`과 `구현 시점`에 서로 다른 의미를 갖는다.

```
실행 시점 : 의존하는 객체(클라이언트 객체)가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체(서버, 의존 객체)가 반드시 존재해야 한다.

구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
```

설명을 잘 이해하기 위해 `PeriodCondition` 클래스를 이용해 의존성의 개념을 설명해보겠다.
<script src="https://gist.github.com/BongHoLee/0ddb06c5a5056973807fd3637663d78a.js"></script>

실행 시점에 `PeriodCondition`의 인스턴스가 정상적으로 동작하기 위해서는 `Screening`의 인스턴스가 존재해야 한다. 만약 `Screening`의 인스턴스가 존재하지 않거나 **_getStartTime()_** 메시지를 이해할 수 없다면 `PeriodCondition`의 **_isSatisfiedBy()_** 메서드는 예상했던 대로 동작하지 않을 것이다.

이처럼 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 `의존성`이 존재한다고 말한다.

>의존성은 방향을 가지며 항상 단방향이다.

`Screening`이 변경될 때 `PeriodCondition`이 영향을 받게 되지만 그 역은 성립하지 않는다. 이 경우 `PeriodCondition`은 `Screening`에 의존한다.

지금까지 주의깊게 살펴본 사람이라면 아마 설계와 관련된 대부분의 용어들이 `변경`과 관련이 있다는 사실을 눈치챘을 것이다. 두 요소 사이의 의존성은 `의존 객체가 변경될 경우 클라이언트 객체도 함께 변경될 수 있다는 것을 의미`한다.

>의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

`PeriodCondition`의 코드를 다시 살펴보자.

`PeriodCondition`은 `DayOfWeek`과 `LocalTime`의 인스턴스를 속성으로 포함한다.
`PeriodCondition`은 **_isSatisfiedBy_** 메서드의 인자로 `Screening`의 인스턴스를 받는다.
`PeriodCondition`은 `DayOfWeek`의 인스턴스에게 **_compareTo_** 메시지를 전송한다.
`PeriodCondition`은 `Screening`의 인스턴스에게 **_getStartTime_** 메시지를 전송한다.

따라서 `PeriodCondition`은 `DayOfWeek, LocalTime, Screening`에 대해 의존성을 갖는다.

`DayOfWeek`의 클래스 명을 변경한다고 가정해보자. 이 경우 `PeriodCondition` 클래스에 정의된 인스턴스 변수의 타입 선언도 함께 수정해야 한다. 이것은 `LocalTime, Screening`에 대해서도 마찬가지다. 만일 `DiscountCondition` 인터페이스의 이름이 변경된다면 어떻게 될까? `DiscountCondition`에 선언된 **_isSatisfiedBy_** 오퍼레이션의 시그니처가 변경된다면 어떻게 될까? `DiscountCondition`의 인터페이스를 실체화 하고 있는 `PeriodCondition` 클래스 역시 어떤 식으로든 함께 수정해야 할 것이다. 여기서 요점은 어떤 형태로든 `DayOfWeek, LocalTime, Screening, DiscountCondition`이 변경된다면 `PeriodCondition`도 함께 변경될 수 있다는 것이다.

비록 위의 의존성들이 각자 `인스턴스 변수, 메서드 인자, 인터페이스 타입`과 같이 다른 성질을 갖고있지만 근본적으로 의존성이 갖는 특성은 동일하다. `PeriodCondition`은 자신이 의존하고 있는 대상이 변경될 때 함꼐 변경될 수 있다는 것이다.

---

#### 런타임 의존성과 컴파일 타임 의존성

의존성과 관련해서 다뤄야 하는 또 다른 주제는 `런타임 의존성`과 `컴파일 타임 의존성`의 차이다.

객체지향 애플리케이션에서 `런타임의 주인공은 객체`이다. 따라서 런타임 의존성이 다루는 주제는 `객체 사이의 의존성`이다.

반면 `코드 관점에서의 주인공은 클래스`이다. 따라서 컴파일 타임 의존성이 다루는 주제는 `클래스 사이의 의존성`이다.

여기서 중요한 것은 **_런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것이다._** 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 **_런타임 의존성과 컴파일타임 의존성을 서로 다르게 만들어야 한다._**





### 참고 및 출처
  - 오브젝트
