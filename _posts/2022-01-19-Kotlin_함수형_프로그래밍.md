---
layout: post
title: Kotlin 함수형 프로그래밍
author: Bong5
categories: [Keywords, Programing_Language/Kotlin]
--- 

## 함수형 프로그래밍

---

### 다중 패러다임언어 코틀린

코틀린은 `함수형 프로그래밍`과 `객체지향 프로그래밍` 패러다임을 모두 사용 가능한 `다중 패러다임` 언어이다.

이번 페이지에서는 가볍게 `함수형 프로그래밍`에 대한 개념과 코틀린에서 어떻게 사용하는지 간단하게 살펴본다.

### 함수형 프로그래밍이란

`함수형 프로그래밍`은 `순수 함수`를 작성하여 프로그램의 `부작용`을 줄이는 프로그래밍 기법을 말한다. 그리고 함수형 프로그래밍에서는 `일급 객체로써의 함수`와 `람다식`, `고차 함수`를 활용한다.

### 순수 함수

함수형 프로그래밍은 `순수 함수` 사용을 지향한다고 이야기 하였다.

어떤 함수가 **같은 인자에 대하여 항상 같은 결과를 반환**한다면 **부작용이 없는 함수**라고 할 수 있다. 그리고 **부작용이 없는 함수가 함수 외부의 어떤 상태도 변경하지 않는다**면 이를 `순수 함수`라고 말할 수 있다.

`순수 함수`의 이런 특성은 `다중 스레드`에 사용해도 안전하고 코드를 테스트 하기도 쉽다는 장점이 있다.

```kotlin
// 항상 같은 입력에 같은 결과
// 함수 외부의 어떤 상태도 바꾸지 않음
// 순수 함수
fun sum(a: Int, b: Int): Int {
	return a + b
}

// 같은 입력에 대해 같은 결과가 아닐 수 있다.
// 외부의 상태를 변경할 여지가 있다.
// 순수 함수가 아님
fun check() {
	val test = User.grade() // 함수 외부의 객체를 사용
  if (test != null) process(test)  // User.grade()의 실행 결과에 따라 다름
}
```

- 순수 함수의 조건
    - **같은 인자에 대하여 항상 같은 값을 반환**
    - **함수 외부의 어떤 상태도 변경하지 않음**

### 람다식

```kotlin
{x, y -> x + y}
```

`람다식`은 **함수의 이름이 없고** `->`가 사용된 `단순화된 함수 표현식`이다.

자바에서는 `람다식`이 `함수형 인터페이스의 구현체`인 반면 **코틀린에서는 별도의 `함수형 인터페이스`를 두지 않고 `람다식`을 사용 가능**하다.

### 일급 객체

**함수형 프로그래밍에서는 함수를 `일급 객체`로 생각한다.** `람다식` 역시 `일급 객체`의 특징을 가지고 있다.

- **일급 객체의 특징**
    - 일급 객체는 `**함수의 인자로 전달 가능**`
    - 일급 객체는 `**함수의 반환값에 사용 가능**`
    - 일급 객체는 `**변수에 할당 가능**`

위와 같은 특징으로 `람다식`은 `함수의 인자로 전달 가능`하고 `함수의 반환값으로 사용 가능`하며 `변수에 할당`이 가능하다.

즉, **람다식은 일급 객체의 특성을 가진 이름이 없는 함수**이다.

### 고차 함수

`일급 함수`가 `**일반 객체`처럼 사용 가능한 `함수`**라면 **고차 함수는 `일급 함수`를 사용하는 함수**라고 할 수 있다.

```kotlin
fun main() {
		// 람다식 함수를 인자로 전달
		// 람다식은 일급 함수이기 때문에 함수의 인자로 전달이 가능
    // 행동 파라미터화
		println(highFunc({x, y -> x + y}, 10, 20))
}

// 함수를 인자로 사용하는 고차 함수
// 자바의 경우, 함수를 인자로 사용하기 위해서는 Function<Integer, Integer>와 같은
// 함수형 인터페이스를 사용해야 했지만, 코틀린은 인자에 함수 정의 가능
fun highFunc(calculate: (x: Int, y: Int) -> a: Int, b: Int) = calculate(a, b)
```

위 `highFunc` 함수와 같이 `일급 함수`를 매개변수로 사용하거나, `일급 함수`를 반환값으로 사용하는 함수를 `고차 함수`라고 한다.

```kotlin
fun main() {
    val sum = {x: Int, y: Int -> x + y}
    val subtract = {x: Int, y: Int -> x - y}
    val max = {x: Int, y: Int -> if(x > y) x else y}
    val min = {x: Int, y: Int -> if(x < y) x else y}

    println(highFunc(sum, 1, 2))          // 3
    println(highFunc(subtract, 10, 5))    // 5
    println(highFunc(max, 10, 11))        // 11
    println(highFunc(min, 10, 11))        // 10
}

fun highFunc(calculate: (a: Int, b: Int) -> Int, a: Int, b: Int) = calculate(a, b)
```

**람다식은 `인자`가 없거나 `반환값`이 없을 수 있다.**

`이름이 없는 함수`를 표현하기 위해 등장한 `람다식`은 함수형 프로그래밍에서 아주 중요한 개념이다.

**람다식은 함수 자체를 인자나 변수로 사용할 수 있어 프로그램의 효율성도 높일 수 있다.**

반면 `람다식`은 **상당한 유연성을 제공(행동의 파라미터화 등)하지만 `높은 러닝커브` 때문에 약간을 어려워 보일 수 있다.**

이제 `람다식`의 다양한 상황에서의 활용 방법을 살펴보자.

### 람다식과 고차 함수 호출

- 여기서 잠깐
    - `기본형 변수(Primitive Data Type)`은 `Stack`에 저장되고 함수의 인자로 전달될 때 `값의 복사`가 전달된다.
    - `참조형 변수(Reference Data Type)`으로 할당된 객체는 `Heap`에 위치하고, `Stack`에 `Heap`의 주소값이 저장되어 객체가 함수에 전달될 때는 `Stack에 저장된 객체의 주소값이 복사`되어 전달된다.
    - 이처럼 `JVM`에서 동작하는 코틀린/자바와 같은 언어는 `Call By Value`가 일반적이다. `C/C++`과 같이 포인터 주소 연산이 없기 때문에 `Call By Reference`는 사용되지 않는다.
    - 다시말해, **자바는 객체가 전달될 때 `값의 복사`가 전달되고, `이 값이 주소값 일 뿐`이다.**
    - 코틀린은 `람다식`을 사용하면 몇 가지 `확장된 호출 방법`을 사용할 수 있다.


### 값에 의한 호출로 람다식 사용

`자바`와 같이 함수의 인자로 `함수` 또는 함수를 호출하면 `함수의 결과가 인자로 전달`된다.

```kotlin
fun main() {
    
    val result = callByValue(lambda())      // lambda()가 실행되고 그 결과가 callByValue()의 인자로 들어감
    println(result)
}

fun callByValue(b: Boolean) : Boolean {
    println("call by value function")
    return b
}

val lambda: () -> Boolean =  {
    println("lambda functino call")
    true
}
```

### 이름에 의한 람다식 호출

고차 함수의 매개변수를 `람다식 타입`으로 선언하면 **람다식의 이름으로 인자를 전달**할 수 있다.

이는 `자바`에서 매개변수를 `함수형 인터페이스`로 선언하고 `람다식`을 인자로 전달하는 것과 동일하다.

```kotlin
fun main() {
    val result = callByName(lambda2)    // lambda2 이름으로 호출
}

// 매개변수로 람다식 타입을 받는 고차함수
fun callByName(func: (msg: String) -> Boolean) : Boolean {
    println("call By Name is called")
    val funcResult = func("hi everyone")
    return !funcResult
}

val lambda2: (msg: String) -> Boolean =  {
    msg ->
    println("lambda2 called massage : $msg")
    true
}
```

### 인자로 함수 참조 전달하기

람다식이 아닌 일반 함수를 함수의 인자로 전달하는 방법으로 `함수 참조 전달`이 있다.

```kotlin
fun main() {
		// 함수 참조를 인자로 전달
    println(funcParam(2, 3, ::sum))     // 5     
    hello(::text)                       // hi Hello and World
}

fun sum(a: Int, b: Int) : Int = a + b
fun text(a: String, b: String): String = "hi $a and $b"

fun funcParam(a: Int, b: Int, func: (a: Int, b: Int) -> Int) : Int  = func(a, b)
fun hello(body: (a: String, b: String) -> String) : Unit {
    body("Hello", "World")
}
```

이처럼 `함수 참조`를 전달함으로써 `람다식`을 좀 더 간소화 하여 인자로 전달할 수 있다.

또한 `함수의 매개변수가 람다식 타입 한 개` 일 경우에는 `소괄호()`를 생략할 수 있다.

```kotlin
// 모두 같은 결과
hello(::sum)
hello({a: String, b:String -> text(a, b)}

// 함수의 매개변수가 람다식 하나일 경우 소괄호()를 생략 가능하다.
hello {a, b -> text(a, b)}
```

### 매개변수가 하나인 람다식

```kotlin
fun main() {
	oneParam({a -> "Hello World! $a"})
	oneParam { a-> "Hello World! $a" }

	// 매개변수가 한 개인 람다식의 경우 매개변수를 생략하고 `it`으로 대체할 수 있다.
	oneParam { "Hello World! $it" }
}

fun oneParam(func: (a: String) -> String) {
	println(func("OneParam"))
}
```

함수의 인자로 `매개변수가 한 개인 람다식`을 전달할 때에는 매개변수를 명시하지 않고 `it`으로 대체할 수 있다. **코틀린 컴파일러가 타입을 추론할 수 있기 때문**

### 매개변수가 두 개인 람다식

람다식의 매개변수가 두 개 이상인 경우 **매개변수 생략이 불가능**하다.

```kotlin
fun main() {
	moreParam {a, b -> "Hello World! $a $b"}
}

fun moreParam(func: (a: String, b: String) -> String) {
	println(func("OneParam", "TwoParam"))
}
```

### 일반 매개변수와 람다식 타입 매개변수를 함께 사용

함수의 매개변수 중 `마지막 매개변수가 람다식`인 경우 가독성을 위해 **소괄호 바깥으로 람다식 인자를 뺄 수 있다.**

```kotlin
fun main() {
    // 모두 같은 결과 
    mixedParam("Hello", "World", {x: String, y: String -> "$x, $y"})
    mixedParam("Hello", "World", {x, y -> "$x, $y"})
    mixedParam("Hello", "World") {x, y -> "$x, $y"}
}

fun mixedParam(a: String, b: String, func: (x: String, y: String) -> String) {
    println(func(a, b))
}
```

위 처럼 일반 인자는 `소괄호()` 내에 위치하고, 마지막 람다식 인자는 소괄호 바깥으로 뺄 수 있다.

### 일반 함수에 람다식 매개변수 2 개 이상 사용

`소괄호()`를 생략한 람다식 인자 전달은 **함수에 람다식 타입 매개변수가 한 개 일때만 가능하다.**

만일 람다식 매개변수가 2개 이상인 경우에는 소괄호 생략이 불가능하다.

```kotlin
fun main() {
		// 동일한 결과
    println(multipleLambdaArgs(mul, max))
    println(multipleLambdaArgs({a, b -> a * b}, {x, y -> if(x>y) x else y}))
}

fun multipleLambdaArgs(
        fun1: (a: Int, b: Int) -> Int,
        fun2: (x: Int, y: Int) -> Int
): Int {
    return fun1(10, 20) + fun2(10, 20)
}

val mul = {a: Int, b: Int -> a*b}
val max = {a: Int, b: Int -> if (a>b) a else b}
```

## 고차 함수와 람다식의 사례 살펴보기



- 공유 자원 보호

```kotlin
fun main() {
    val reLock = ReentrantLock()
    lock(reLock, { accessCriticalSection()})
    lock(reLock) { accessCriticalSection()}
    lock(reLock, ::accessCriticalSection) 
}

fun accessCriticalSection() {
    shareable ++
}

fun <T> lock(locker: ReentrantLock, body: () -> T) : T {
    locker.lock()
    
    try {
        return body()
    } finally {
        locker.unlock()
    }
}
```

- 네트워크 성공/실패 콜백
    - 자바

```java
public interface CallBack() {
	void onSuccess(ResultType result);
	void onError(Exception exception);
}

public void networkCall(CallBack callBack) {
	try {
		// 성공 시 onSuccess 콜백 호출
		callBack.onSuccess(result);
	} catch (e: Throwable) {
		// 실패 시 onError 콜백 호출
		callBack.onError(e);
	}
}

public void someMethod() {
	// 익명 객체로 구현
	networkCall(new CallBack() {
			@Override
			public void onSuccess(ResultType result) {
				// 성공 시 구현
				...
			}

			@Override
			public void onError(Exception e) {
				// 실패 시 구현
				...
			}
		})
}

```

- 코틀린

```kotlin
fun networkCall(onSuccess: (result: ResultType) -> Unit, onError: (e: Exception)) {
	try {
		// 성공 시 onSuccess 호출
		onSuccess(result);
	} catch (e: Throwable) {
		// 실패 시 onError 호출
		onError(e);
	}
}

fun someFunc() {
	networkCall(
		result -> {
			// 성공 시 구현
		},
		error -> {
			// 오류 시 구현
		}
}
```