---
layout: post
title: 유연한 설계
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

지난 `의존성 관리하기` 포스팅에서 유연하고 재사용 가능한 설계를 위해 `바람직한 의존성`이 필요하다고 하였다. 그리고 `바람직한 의존성`을 위해서는 간략하게 3가지가 필요하다.

> 1. 구체적인 클래스가 아니라 추상화에 의존하라.

> 2. 생성과 사용의 책임을 분리하라.

> 3. 의존성을 퍼블릭 인터페이스에 명시적으로 드러내라

이번 장에서는 위에서 언급한 `의존성 관리` 방법을 `원칙과 기법`을 이용하여 자세히 알아보자.

---

## 개방-폐쇄 원칙

확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나는 `개방-폐쇄 원칙(OCP)`이다. 개방-폐쇄 원칙은 다음과 같은 문장으로 요약할 수 있다.

> 소프트웨어 개체(클래스, 모듈, 함수 등등)은 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

여기서 키워드는 `확장`과 `수정`이다. 이 둘은 순서대로 애플리케이션의 `동작`과 `코드`의 관점을 반영한다. 즉, `동작(기능)의 확장`에 대해서는 열려있어야 하고 `기존 코드의 수정`에 대해서는 닫혀있어야 한다.

```
1. 확장에 대해서 열려있다 : 앺프리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.

2. 수정에 대해 닫혀있다. : 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
```

`개방-폐쇄 원칙`은 **_유연한 설계란 기존의 코드를 수정하지 않고도 애플리케이션의 기능을 확장할 수 있는 설계_** 라고 이야기한다. 처음에는 **_어떻게 코드를 수정하지 않고 동작(기능)을 확장시킬 수 있는가?_** 라는 의문이 들 것이다. 어떻게 가능할까?

### 컴파일 의존성을 고정시키고 런타임 의존성을 변경하라!

**_사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다._** 기억을 되살려보자. `런타임 의존성`은 실행 시 협력에 참여하는 객체 사이의 의존성이고 `컴파일타임 의존성`은 코드에서 드러나는 클래스들 사이의 의존성이다. 그리고 이미 살펴본 바와 같이 **_유연하고 재사용 가능한 설계에서는 런타임 의존성과 컴파일타임 의존성은 서로 다른 구조를 갖는다._**

`영화 예매 시스템`의 할인 정책을 의존성 관점에서 다시 한번 살펴보자. `컴파일타임 의존성` 관점에서 `Movie` 클래스는 추상 클래스인 `DiscountPolicy`에 의존한다. `런타임 의존성` 관점에서 `Movie` 인스턴스는 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 인스턴스에 의존한다. 아래 그림에서 알 수 있는 것처럼 `Movie`의 관점에서 `DiscountPolicy`에 대한 `컴파일 타임 의존성`과 `런타임 의존성`은 동일하지 않다.

<img src="/assets/img/object/ch9/img1.png" width="100%" height="auto">

사실 `할인 정책 설계`는 이미 `개방-폐쇄 원칙`을 따르고 있따. 앞 장에서 `금액 할인 정책`과 `비율 할인 정책`을 동시에 적용할 수 있게 `중복 할인 정책`을 추가 했던 기억을 떠올려 보자. `중복 할인 정책`을 추가하기 위해 한 일은 `DiscountPolicy`의 자식 클래스로 `OverlappedDiscountPolicy` 클래스를 추가한 것 뿐이다. 기존의 `Movie`, `DiscountPolicy`, `AmountDiscountPolicy`, `PercentDiscountPolicy` 중 어떤 코드도 수정하지 않았다. 즉, **_기존의 코드는 전혀 수정하지 않고 클래스를 추가하는 것만으로 중복 할인 정책이 적용된 영화를 구현할 수 있었다._**

단순히 `새로운 클래스를 추가`하는 것만으로 `Movie`를 새로운 컨텍스트에서 사용되도록 `확장`할 수 있었던 것이다.

현재의 설계는 새로운 할인 정책을 추가해서 기능을 확장할 수 있도록 허용한다. 따라서 `확장에 대해서는 열려있다.` 현재의 설계는 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는 것만으로 새로운 할인 정책을 확장할 수 있다. 따라서 `수정에 대해서는 닫혀있다.` 이것이 `개방-폐쇄 원칙`이 의미하는 것이다.

개방-폐쇄 원칙을 수용하는 코드는 **_컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다._** 아래 그림에서 알 수 있는 것처럼 `중복 할인 정책`을 구현하는 `OverlappedDiscountPolicy` 클래스를 추가하더라도 `Movie` 클래스는 여전히 `DiscountPolicy` 클래스에만 의존한다. 따라서 `컴파일타임 의존성은 변하지 않는다`. 하지만 런타임에 `Movie` 인스턴스는 `OverlappedDiscountPolicy` 인스턴스와 협력할 수 있따. 따라서 `런타임 의존성은 변경된다.`

> 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조이다.

<img src="/assets/img/object/ch9/img2.png" width="100%" height="auto">

---

### 추상화가 핵심이다.

`개방-폐쇄 원칙`의 핵심은 `추상화에 의존하는 것`이다. 여기서 `추상화`와 `의존`이라는 두 개념 모두가 중요하다.

`추상화`란 **_핵심적이고 공통적인 부분만 남기고 불필요한 부분은 생략_** 함으로써 `복잡성을 극복`하는 기법이다.

>추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게되고 문맥에 따라 변하는 부분은 생략된다.

**_추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화 하고 확장할 수 있다._**

`개방-폐쇄 원칙`의 관점에서 생략되지 않고 남겨지는 부분은 `다양한 상황에서의 공통점을 반영한 추상화의 결과물`이다. **_공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다._** 다시말해서 **_수정할 필요가 없어야 한다._** 따라서 `추상화`부분은 수정에 대해서 닫혀있다. **_추상화를 통해 생략된 부분(세부적인 부분)은 확장의 여지를 남긴다._** 이것이 `추상화`가 `개방-폐쇄 원칙`을 가능하게 만드는 이유다.

이해를 돕기 위해 아래의 `DiscountPolicy` 코드를 보자.

<script src="https://gist.github.com/BongHoLee/099993ddb6c6da75d9b0f61230f9294f.js"></script>

`DiscountPolicy`는 할인 여부를 판단하여 할인 요금을 계산하는 `calculateDiscountAmount` 메서드와 조건을 만족할 때 할인된 요금을 계산하는 추상 메서드인 `getDiscountAmount` 메서드로 구성돼 있다. 여기서 변하지 않는 부분은 `할인 여부를 판단`하는 로직이고 변하는 부분은 `할인 요금을 계산하는 방법`이다. 우리는 **_상속을 통해 생략된 부분을 구체화 함으로써 할인 정책을 확장할 수 있는 것이다._**

여기서 `변하는 부분을 생략하고 변하지 않는 부분을 고정`하는 추상화 메커니즘이 `개방-폐쇄 원칙`의 기반이 된다는 사실에 주목하자. 언제라도 추상화의 생략된 부분을 채워넣음으로써 새로운 문맥에 맞게 기능을 확장할 수 있다. 따라서 **_추상화는 설계의 확장을 가능하게 한다._**

단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀있는 설계를 만들 수 있는 것은 아니다. **_개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다._** 수정에 대한 영향을 최소화하기 위해서는 `모든 요소가 추상화에 의존`해야 한다. 잠시 `Movie` 클래스 코드를 보자.

<script src="https://gist.github.com/BongHoLee/1a0d5a7c2855fa6265d6b0f01ee3cc8f.js"></script>

`Movie`는 할인 정책을 추상화한 `DiscountPolicy`에 대해서만 의존한다. **_의존성은 변경의 영향을 의미하고 DiscountPolicy는 변하지 않는 추상화라는 사실에 주목하라._** `Movie`는 안정된 추상화인 `DiscountPolicy`에 의존하기 때문에 할인 정책을 추가하기 위해 `DiscountPolicy`의 자식 클래스를 추가하더라도 영향을 받지 않는다. 따라서 `Movie`와 `DiscountPolicy`는 수정에 대하여 닫혀있다.

>추상화는 확장을 가능하게하고 추상화에 대한 의존은 폐쇄를 가능하게 한다.

앞 장에서 설명한 것 처럼 **_명시적 의존성과 의존성 해결 방법을 통해 컴파일타임 의존성을 런타임 의존성으로 대체함으로써 실행 시에 객체의 행동을 확장할 수 있다._**

>올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

여기서 주의할 점은 **_추상화를 했다고 해서 모든 수정에 대해 설계가 폐쇄되는 것은 아니라는 것이다._** 수정에 대해 닫혀있고 확장에 대해 열려 있는 설계는 공짜로 얻어지지 않는다. 변경에 의한 파급효과를 최대한 피하기 위해서는 `변하는 것과 변하지 않는 것이 무엇인지를 이해`하고 이를 `추상화의 목적`으로 삼아야만 한다.

>추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분은 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.

---

## 생성과 사용의 분리

`Movie`가 오직 `DiscountPolicy`라는 추상화에만 의존하기 위해서는 `Movie`내부에서 `AmountDiscountPolicy`와 같은 구체 클래스의 인스턴스를 생성해서는 안된다. 아래 코드에서 `Movie`의 할인 정책을 비율 할인 정책으로 변경할 수 있는 방법은 단 한 가지 밖에 없다. 바로 `AmountDiscountPolicy`의 인스턴스를 생성하는 부분을 `PercentDiscountPolicy`의 인스턴스를 생성하도록 직접 코드를 수정하는 것 뿐이다. 이것은 **_동작을 추가하거나 변경하기 위해 기존의 코드를 수정하도록 만들기 때문에 개방-폐쇄 원칙을 위반한다._**

<script src="https://gist.github.com/BongHoLee/9f2ab51be994d1d6f90a075aeae61a68.js"></script>

**_결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다._** 알아야 하는 지식이 많으면 결합도도 높아진다. 특히 `객체 생성에 대한 지식은 과도한 결합도를 초래`하는 경향이 있다.

> 객체의 타입과 생성자에 전달해야 하는 인자에 대한 과도한 지식은 코드를 특정한 컨텍스트에 강하게 결합시킨다.

컨텍스트를 바꾸기 위한 유일한 방법은 코드 안에 명시돼 있는 컨텍스트에 대한 정보를 직접 수정하는 것 뿐이다.

물론 객체 생성을 피할수는 없다. 어딘가에서는 반드시 객체를 생성해야 한다. 문제는 객체 생성이 아니라 `부적절한 곳에서 객체를 생성`한다는 것이 문제다. `Movie` 코드를 자세히 살펴보면 생성자 안에서는 `DiscountPolicy`의 인스턴스를 생성하고, `calculateDiscountAmount`메서드 안에서는 이 객체에게 메시지를 전송한다는 것을 알 수 있다.

메시지를 전송하지 않고 객체를 생성하기만 했다면 아무런 문제가 없었을 것이다. 또는 객체를 생성하지 않고 메시지를 전송하기만 했다면 괜찮았을 것이다. **_동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하면 문제가 된다._**

<img src="/assets/img/object/ch9/img3.png" width="100%" height="auto">

유연하고 재사용 가능한 설계를 원한다면 `객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.` 하나는 `객체를 생성하는 책임`이고 또 다른 하나는 `객체를 사용하는 책임`이다. 한 마디로 말해서 객체에 대한 `생성과 사용을 분리`해야 한다.

사용으로부터 생성을 분리하는데 가장 보편적인 방법은 **_객체를 생성할 책임을 클라이언트로 옮기는 것이다._** 다시 말해서 `Movie`의 클라이언트가 적절한 `DiscountPolicy` 인스턴스를 생성한 후 `Movie`에게 전달하게 하는 것이다.

조금만 생각해보면 이 방법이 타당하다는 사실을 알 수 있는데 `Movie`에게 금액 할인 정책을 적용할지, 비율 할인 정책을 적용할지를 알고 있는 것은 그 시점에 `Movie`와 협력할 클라이언트이기 때문이다. **_현재의 컨텍스트에 관한 결정권을 가지고 있는 클라이언트로 컨텍스트에 대한 지식을 옮김으로써 Movie는 특정한 클라이언트에 결합되지 않고 독립적일 수 있다._**
<script src="https://gist.github.com/BongHoLee/d6bb57b09c0ff127d1ce59eac75967f2.js"></script>

아래 글미은 생성에 관한 책임을 `Movie`의 클라이언트로 옮길 경우의 의존성을 나타낸 것이다. 이 전의 그림에서 `Movie`는 `AmountDiscountPolicy`에 대한 의존성 때문에 `금액 할인 정책`이라는 구체적인 컨텍스트에 묶여있다. 반면 아래 그림에서는 `AmountDiscountPolicy`의 인스턴스를 생성하는 책임을 클라이언트에게 맡김으로써 `구체적인 컨텍스트와 관련된 정보는 클라이언트로 옮기고 Movie는 오직 DiscountPolicy의 인스턴스를 사용하는 데만 주력`하고 있다.

<img src="/assets/img/object/ch9/img4.png" width="100%" height="auto">

**_Movie의 의존성을 추상화인 DiscountPolicy로만 제한하기 때문에 확장에 대해서는 열려있으면서도 수정에 대해서는 닫혀 있는 코드를 만들 수 있는 것이다._**

### FACTORY 추가하기

생성 책임을 `Client`로 옮긴 배경에는 `Movie`는 특정 컨텍스트에 묶여서는 안되지만 `Client`는 묶여도 상관 없다는 전제가 깔려있다. 하지만 `Movie`를 사용하는 `Client`도 특정한 컨텍스트에 묶이지 않기를 바란다고 가정해보자.

`Client`의 코드를 다시 살펴보면 `Movie`의 인스턴스를 생성하는 동시에 `getFee` 메시지도 함께 전송한다는 것을 알 수 있다. `Client` 역시 생성과 사용의 책임을 함께 지니고 있는 것이다.

`Movie`의 문제를 해결했던 방법과 동일한 방법을 이용하여 이 문제를 해결할 수 있다. `Movie`를 생성하는 책임을 `Client`의 인스턴스를 사용할 문맥을 결정할 클라이언트로 옮기는 것이다. 하지만 객체 생성과 관련된 지식이 `Client`와 협력하는 클라이언트에게까지 새어나가기를 원하지 않는다고 가정해보자.

이 경우 **_객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다._** 이처럼 `생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY`라고 부른다.

<script src="https://gist.github.com/BongHoLee/1c9486e9badfb059b65f7d7d653e7547.js"></script>

이제 `Client`는 `Factory`를 사용해서 생성된 `Movie`의 인스턴스를 반환받아 `사용`하기만 하면 된다.

<script src="https://gist.github.com/BongHoLee/36a43b0b5b6c08d5f676adb21a283e31.js"></script>

`FACTORY`를 사용하면 `Movie`와 `AmountDiscountPolicy`를 생성하는 책임 모두를 `FACTORY`로 이동할 수 있다. 이제 `Client`에서는 사용과 관련된 책임만 남게 되는데 하나는 생성된 `Movie`를 얻기 위한 것이고 다른 하나는 `Movie`를 통해 가격을 계산하기 위한 것이다. `Client`는 오직 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않을 수 있다.

<img src="/assets/img/object/ch9/img5.png" width="100%" height="auto">

### 순수한 가공물에게 책임 할당하기

4장에서 책임 할당 원칙을 패턴의 형태로 기술한 `GRASP` 패턴에 관해 살펴봤다. **_책임 할당의 가장 기본이 되는 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 INFORMATION EXPERT에게 책임을 할당하는 것이다._** `도메인 모델`은 `INFORMATION EXPERT`를 찾기 위해 참조할 수 있는 일차적인 재료다. 어떤 책임을 할당하고 싶다면 제일 먼저 `도메인 모델`안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야 한다.

하지만 `FACTORY`는 도메인 모델에 속하지 않는다. `FACTORY`를 추가한 이유는 순수하게 기술적 결정이다. **_전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다._**

시스템을 객체로 분해하는데는 크게 두 가지 방식이 존재한다. `표현적 분해`와 `행위적 분해`가 그것이다.

`표현적 분해`는 `도메인에 존재하는 개념을 표현하는 객체들을 이용해 시스템을 분해`하는 것이다. 즉, 도메인 모델에 담겨있는 개념과 관계를 따르며 `도메인과 소프트웨어 사이의 표현적 차이를 최소화 하는것을 목적`으로 한다. 따라서 표현적 분해는 객체지향 설계를 위한 가장 기본적인 접근법이다.

그러나 **_종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다._** 도메인 모델은 설계를 위한 중요한 출발점이지만 `단지 출발점`이라는 사실을 명심해야 한다. 실제로 동작하는 애플리케이션은 `데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념들을 필요`로 할 수 있다.

>모든 책임을 도메인 객체에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제에 봉착하게 될 가능성이 높아진다.

이 경우 도메인 개념을 표현한 객체가 아닌 `설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결`해야 한다.

어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 `PURE FABRICATION`을 추가하고 이 객체에게 책임을 할당하라. 그 결과로 **_추가된 PURE FABRICATION은 보통 특정한 행동을 표현하는 것이 일반적이다._** 따라서 `PURE FABRICATION`은 `표현적 분해`보다 `행위적 분해`에 의해 생성되는 것이 일반적이다.

이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다. `객체지향 애플리케이션은 도메인 개념 뿐만 아니라 설계자들이 임의적으로 창조한 인공적인 추상화들을 포함`하고 있다.














### 참고 및 출처
  - 오브젝트
