---
layout: post
title: 상속과 코드 재사용
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

객체지향 프로그래밍에서 코드를 재사용 하는 대표적인 방법은 두 가지가 있다.

첫 째는 바로 `상속`이고 둘 째는 `합성`이다.

이번 장에서는 코드 재사용을 위한 `상속`에 대해 알아보면서 상속이 갖는 장단점을 살펴본다.

---

## 상속과 코드 재사용

객체지향 프로그래밍의 장점 중 하나는 `코드 재사용`이 용이하다는 것이다. 전통적인 패러다임에서 코드를 재사용하는 방법은 코드를 복사한 후 수정하는 것이다. 객체지향은 조금 다른 방법을 취한다. **_객체지향에서는 코드를 재사용하기 위해 새로운 코드를 추가한다._** 객체지향에서 코드는 일반적으로 클래스 안에 작성되기 때문에 객체지향에서 클래스를 재사용하는 전통적인 방법은 `새로운 클래스를 추가`하는 것이다.

--

### 상속과 중복 코드

> 중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.

**_중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다._**

모든 중복코드를 개별적으로 테스트해서 동일한 결과를 내놓는지 확인해야만 한다. 즉, **_중복 코드는 수정과 테스트에 드는 비용을 증가시킬 뿐 아니라 시스템과 개발자를 공황상태로 몰아넣는다._**

> 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면(의존성과 상관 없이) 이 코드는 중복이다. 함께 수정할 필요가 없다면 중복이 아니다. 중복 코드를 결정하는 기준은 코드의 모양이 아니다. 모양이 유사하다는 것은 단지 중복의 징후일 뿐이다. 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.

---

### 중복과 변경

중복 코드의 문제점을 이해하기 위해 간단한 애플리케이션을 개발해보자.

1. 한 달에 한 번씩 가입자 별로 `전화 요금을 계산`한다.

2. 전화 요금을 계산하는 규칙은 `(통화 시간)/(단위 시간당 요금)`으로 계산한다.

3. 10초당 5원의 통화료를 부과하는 요금제에 가입되어있는 가입자가 100초동안 통화를 했다면 `(100/10) * 5 = 50원`이 부과된다.

먼저 `개별 통화 기간을 저장`하는 `Call` 클래스가 필요하다. `Call`은 통화 시작 시간(from)과 통화 종료 시간(to)을 인스턴스 변수로 포함한다.

<script src="https://gist.github.com/BongHoLee/6f64b81f50b1eb1a4bcf0a41dc3a7c41.js"></script>

이제 `통화 요금을 계산`하는 객체가 필요하다. 언제나 그런 것처럼 전체 통화 목록에 대해 알고 있는 `정보 전문가`에게 요금을 계산할 책임을 할당해야 한다. 일반적으로 통화 목록은 전화기 안에 보관된다. 따라서 `Call`의 목록을 관리할 정보 전문가는 `Phone`이다.

`Phone` 인스턴스는 요금 계산에 필요한 세 가지 인스턴스 변수를 포함한다. 첫 번째는 `단위 요금을 저장하는 amount`이고, 두 번째는 `단위 시간을 저장하는 seconds`다. 사용자가 `10초당 5원`씩 부과되는 요금제에 가입돼 있을 경우 `amount`의 값은 5원이 되고 `seconds`의 값은 10초가 된다. 세 번째 인스턴스 변수인 `calls`는 전체 통화 목록을 저장하고 있는 `Call`의 리스트다. `calculateFee()` 메서드는 `amount, seconds, calls`를 이용하여 전체 통화 요금을 계산한다.

<script src="https://gist.github.com/BongHoLee/86f47c69472fc561b302686183e5eb5b.js"></script>

다음은 `Phone`을 이용해 `10초당 5원`씩 부과되는 요금제에 가입한 사용자가 각각 1분 동안 두 번 통화를 한 경우의 통화 요금을 계싼하는 방법을 코드로 나타낸 것이다.

<script src="https://gist.github.com/BongHoLee/3c6965204dc4e0aa4e07ff900273554e.js"></script>

여기서 부터가 재미있는 부분이다.

**_요구 사항은 항상 변한다._** 그리고 우리의 애플리케이션 역시 예외일 수는 없다. 시간이 흘러 `심야 요금 할인제`라는 새로운 요금 방식을 추가해야 한다는 요구사항이 접수됐다. `심야 할인 요금제`는 밤 10시 이후의 통화에 대해 요금을 할인 해주는 방식이다.

이 요구사항을 해결할 수 있는 쉽고도 가장 빠른 방법은 `Phone`의 코드를 복사해서 `NightlyDiscountPhone`이라는 새로운 클래스를 만든 후 수정하는 것이다.

<script src="https://gist.github.com/BongHoLee/e042588627e042b5fbcee4f77901f383.js"></script>

`심야 할인 요금제`를 구현하는 `NightlyDiscountPhone`은 밤 10시 이전에 적용할 통화 요금(regularAmount)과 밤 10시 이후에 적용할 통화요금(nightlyAmount), 단위 시간(seconds)을 인스턴스 변수로 포함한다. 예를 들어, 심야 할인 요금제가 10시 이전에는 10초당 5원이고 10시 이후에는 10초당 2원이라면 seconds는 10초, regularAmount는 5원, nightlyAmount는 2원의 값을 저장하고 있을 것이다.

`NightlyDiscountPhone`은 밤 10시를 기준으로 regularAmount와 nightlyAmount 중에서 기준 요금을 결정한다는 점을 제외하고는 `Phone`과 거의 유사하다. `Phone`의 코드를 복사해서 `NightlyDiscountPhone`을 추가하는 방법은 심야 시간에 요금을 할인해야 한다는 요구사항을 아주 짧은 시간 안에 구현할 수 있게 해준다.

하지만 구현 시간을 절약한 대가로 지불해야 하는 비용은 예상보다 크다. 사실 `Phone`과 `NightlyDiscountPhone` 사이에는 `중복 코드`가 존재하기 때문에 언제 터질지 모르는 시한폭탄을 안고 있는 것과 같다.

---

### 중복 코드 수정하기

중복 코드가 코드 수정에 미치는 영향을 살펴보기 위해 새로운 요구사항을 추가해보자. 이번에 추가할 기능은 `통화 요금에 부과할 세금을 계산`하는 것이다. 부과되는 세율은 가입자의 핸드폰마다 다르다고 가정할 것이다. 현재 통화 요금을 계산하는 로직은 `Phone`과 `NightlyDiscountPhone` 양쪽 모두에 구현돼있기 때문에 **_세금을 추가하기 위해서는 두 클래스를 함께 수정해야 한다._**

`Phone` 클래스 먼저 수정하자. 가입자의 핸드폰별로 세율이 서로 달라야 하기 때문에 `Phone`은 세율을 저장할 인스턴스 변수인 `taxRate`를 포함해야 한다. `taxRate`의 값을 이용해 통화 요금에 세금을 부과하도록 `Phone`의 `calculateFee()` 메서드를 수정하자.

<script src="https://gist.github.com/BongHoLee/b1a9e70b162614d85179376af618868b.js"></script>

`NightlyDiscountPhone`도 동일한 방식으로 수정하자.

<script src="https://gist.github.com/BongHoLee/a997904e63c9cd1a8b1800551b615a99.js"></script>

이 예제는 중복 코드가 가지는 단점을 잘 보여준다. 많은 코드 더미속에서 어떤 코드가 중복 인지를 파악하는 일은 쉬운 일이 아니다. `중복 코드는 항상 함께 수정`해야 하기 때문에 수정할 때 하나라도 빠트린다면 버그로 이어질 것이다. `Phone`은 수정했지만 `NightlyDiscountPhone`은 수정하지 않은 채 배포했다면 심야 할인 요금제의 모든 가입자에게 세금이 부과되지 않는 장애가 발생할 것이다.

더 큰 문제는 중복 코드를 서로 다르게 수정하기가 쉽다는 것이다. `Phone`의 `calculateFee()` 메서드는 반환시에 result에 plus 메서드를 호출해서 세금을 더했지만 `NightlyDiscountPhone`의 `calculateFee()` 메서드에는 plus 대신 minus 메서드를 호출하고 있다. 







### 참고 및 출처
  - 오브젝트
