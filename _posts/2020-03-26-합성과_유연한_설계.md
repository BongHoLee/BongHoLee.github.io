---
layout: post
title: 합성과 유연한 설계
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

지난 시간에 우리는 객체지향 설계에 있어 코드를 재사용하는 방법 중 `상속`에 대하여 살펴보았다.

이번 장에서는 코드 재사용 방법 중 `합성`에 대하여 살펴보고 `합성`이 왜 `상속`보다 더 우아한 방법인지에 대해 장단점을 비교해본다.

---

## 합성과 유연한 설계

`상속`과 `합성`은 객체지향 프로그래밍에서 가장 널리 사용되는 `코드 재사용` 기법이다. 상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는데 비해 **_합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다._** 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 `컴파일 타임`에 해결되지만 `합성`에서 두 객체 사이의 의존성은 `런타임`에 해결된다.

`상속` 관계는 `is-a` 관계라고 부르고 `합성` 관계는 `has-a` 관계라고 부른다. 상속과 합성은 코드 재사용이라는 동일한 목적을 가진다는 점을 제외하면 **_구현 방법부터 변경을 다루는 방식에 이르기 까지 모든 면에서 도드라진 차이를 보인다._**

상속을 이용하면 자식 클래스의 정의에 부모 클래스의 이름을 덧붙이는 것만으로 부모 클래스의 코드를 재사용할 수 있게된다. 상속을 통해 자식 클래스는 부모 클래스의 정의 대부분을 물려받게 되며 부모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 확장할 수 있다. 그러나 **_상속을 제대로 사용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다._** 결과적으로 상속은 코드를 재사용할 수 있는 쉽고 간단한 방법일지는 몰라도 우아한 방법이라고는 할 수 없다.

`합성`은 구현에 의존하지 않는다는 점에서 상속과 다르다. **_합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다._** 따라서 `합성`을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화 할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게된다.

> 합성은 구현에 의존하지 않는다. 내부에 포함되는 객체의 퍼블릭 인터페이스에 의존하기 때문에 내부 객체의 구현이 변경되더라도 영향을 최소화 할 수 있다.

`상속` 관계는 클래스 사이의 `정적인 관계`인 데 비해 `합성` 관계는 객체 사이의 `동적인 관계`이다. 이 차이점은 생각보다 중요한데, 코드 작성 시점에 결정한 상속 관계는 `변경이 불가능` 하지만 합성 관계는 실행 시점에 `동적으로 변경`할 수 있기 때문이다. 따라서 **_상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다._**

물론 상속보다 합성을 이용하는 것이 구현 관점에서는 좀 더 번거롭고 복잡하게 느껴질 수 있다. 하지만 `설계는 변경과 관련된 것`이라는 점을 기억하라. **_변경에 유연하게 대처할 수 있는 설계가 대부분의 경우에 정답일 가능성이 높다._**

> 코드를 재사용하기 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법이다.

**_상속과 합성은 재사용의 대상이 다르다._** `상속`은 부모 클래스 안에 구현된 `코드 자체를 재사용`하지만 `합성`은 포함된 객체의 `퍼블릭 인터페이스를 재사용`한다. 따라서 상속 대신 합성을 사용하면 `구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경`할 수 있다. 다시말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.

---

## 상속을 합성으로 변경하기

상속으로 인한 몇 가지 문제점을 10장에서 살펴보았다.

`1. 불필요한 인터페이스 상속 문제`
자식 클래스에게는 부적합한 부모 클래스의 `오퍼레이션이 상속`되기 때문에 자식 클래스의 인스턴스 상태가 불안정해지는 문제. `JDK`에 포함된 `java.util.properties`와 `java.util.Stack`을 살펴보았다.

`2. 메서드 오버라이딩의 오작용 문제`
자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 **_자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제_** `java.util.HashSet`을 상속받은 `InstrumentedHashSet`을 살펴보았다.

`3. 부모 클래스와 자식 클래스의 동시 수정 문제`
부모 클래스와 자식 클래스 사이의 `개념적인 결합`으로 인해 **_부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제._** `PlayList`를 상속받은 `PersonalPlayList`를 살펴보았다.

이제 상속으로 불거진 위의 문제들을 `합성` 관계로 변경했을 때 어떻게 바뀌는지 살펴보자.

### 불필요한 인터페이스 상속 문제 : java.util.Properties와 java.util.Stack

먼저 `HashTable` 클래스와 `Properties` 클래스 사이의 상속 관계를 합성 관계로 바꿔보자. `Properties` 클래스에서 상속 관계를 제거하고 `HashTable`을 `Properties`의 인스턴스 변수로 포함시키면 합성 관계로 변경할 수 있다.

<script src="https://gist.github.com/BongHoLee/da0c267cd92aaf0f8bdf51576a417a4d.js"></script>

이제 더 이상 불필요한 `HashTable`의 오퍼레이션들이 `Properties`의 클래스의 퍼블릭 인터페이스를 오염시키지 않는다. 클라이언트는 오직 `Properties`에서 정의한 오퍼레이션만 사용할 수 있다. `Properties`의 클라이언트는 모든 타입의 키와 값을 저장할 수 있는 `HashTable`의 오퍼레이션을 사용할 수 없기 때문에 `String` 타입의 키와 값만 허용하는 `Properties`의 규칙을 어길 위험성은 사라진다.

내부 구현에 밀접하게 결합된 상속과 달리 `합성`으로 변경한 `Properties`는 `HashTable`의 내부 구현에 관해 알지 못한다. 단지 `Properties`는 `get`과 `set` 오퍼레이션이 포함된 퍼블릭 인터페이스를 통해서만 `HashTable`과 협력할 수 있을 뿐이다.

`Vector`를 상속받는 `Stack` 역시 `Vector`의 인스턴스 변수를 `Stack` 클래스의 인스턴스 변수로 선언함으로써 합성 관계로 변경할 수 있다.

<script src="https://gist.github.com/BongHoLee/36659f3a7179e2d84377428f2e910223.js"></script>

이제 `Stack`의 퍼블릭 인터페이스에는 불필요한 `Vector`의 오퍼레이션들이 포함되지 않는다. 클라이언트는 더 이상 임의의 위치에 요소를 추가하거나 삭제할 수 없다. 따라서 마지막 위치에서만 요소를 추가하거나 삭제할 수 있따는 `Stack`의 규칙을 어길 수 없게 된다. 합성 관계로 변경함으로써 클라이언트가 `Stack`을 잘못 사용할 수 도 있다는 가능성을 깔끌하게 제거한 것이다.

---

### 메서드 오버라이딩의 오작용 문제 : InstrumentedHashSet

`InstrumentedHashSet`도 같은 방법을 사용해서 합성 관계로 변경할 수 있다. `HashSet` 인스턴스를 내부에 포함한 후 `HashSet`의 퍼블릭 인터페이스에서 제공하는 오퍼레이션들을 이용해 필요한 기능을 구현하면 된다.

<script src="https://gist.github.com/BongHoLee/bbc5c6ed892420b3b4193915a11300df.js"></script>

여기까지만 보면 앞에서 살펴본 `Properties`와 `Stack`을 변경하던 과정과 동일하게 보일 것이다. 하지만 `InstrumentedHashSet`의 경우에는 다른 점이 한 가지 있다. `Properties`와 `Stack`을 합성으로 변경한 이유는 불필요한 오퍼레이션들이 퍼블릭 인터페이스에 스며드는 것을 방지하기 위해서다. 하지만 `InstrumentedHashSet`의 경우에는 `HashSet`이 제공하는 퍼블릭 인터페이스를 그대로 제공해야 한다.

`HashSet`에 대한 구현 결합도는 제거하면서도 퍼블릭 인터페이스를 그대로 상속받기 위해서 자바는 `인터페이스 문법`을 제공한다. `HashSet`은 `Set` 인터페이스를 구현한 구현체 중 하나이며, `InstrumentedHashSet`이 제공해야 하는 모든 오퍼레이션들은 `Set` 인터페이스에 정의돼 있다. 따라서 `InstrumentedHashSet`이 `Set` 인터페이스를 실체화하면서 내부에 `HashSet`의 인스턴스를 합성하면 `HashSet`에 대한 구현 결합도는 제거하면서도 퍼블릭 인터페이스는 그대로 유지할 수 있다.








### 참고 및 출처
  - 오브젝트
