---
layout: post
title: 합성과 유연한 설계
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

지난 시간에 우리는 객체지향 설계에 있어 코드를 재사용하는 방법 중 `상속`에 대하여 살펴보았다.

이번 장에서는 코드 재사용 방법 중 `합성`에 대하여 살펴보고 `합성`이 왜 `상속`보다 더 우아한 방법인지에 대해 장단점을 비교해본다.

---

## 합성과 유연한 설계

`상속`과 `합성`은 객체지향 프로그래밍에서 가장 널리 사용되는 `코드 재사용` 기법이다. 상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는데 비해 **_합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다._** 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 `컴파일 타임`에 해결되지만 `합성`에서 두 객체 사이의 의존성은 `런타임`에 해결된다.

`상속` 관계는 `is-a` 관계라고 부르고 `합성` 관계는 `has-a` 관계라고 부른다. 상속과 합성은 코드 재사용이라는 동일한 목적을 가진다는 점을 제외하면 **_구현 방법부터 변경을 다루는 방식에 이르기 까지 모든 면에서 도드라진 차이를 보인다._**

상속을 이용하면 자식 클래스의 정의에 부모 클래스의 이름을 덧붙이는 것만으로 부모 클래스의 코드를 재사용할 수 있게된다. 상속을 통해 자식 클래스는 부모 클래스의 정의 대부분을 물려받게 되며 부모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 확장할 수 있다. 그러나 **_상속을 제대로 사용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다._** 결과적으로 상속은 코드를 재사용할 수 있는 쉽고 간단한 방법일지는 몰라도 우아한 방법이라고는 할 수 없다.

`합성`은 구현에 의존하지 않는다는 점에서 상속과 다르다. **_합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다._** 따라서 `합성`을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화 할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게된다.

> 합성은 구현에 의존하지 않는다. 내부에 포함되는 객체의 퍼블릭 인터페이스에 의존하기 때문에 내부 객체의 구현이 변경되더라도 영향을 최소화 할 수 있다.

`상속` 관계는 클래스 사이의 `정적인 관계`인 데 비해 `합성` 관계는 객체 사이의 `동적인 관계`이다. 이 차이점은 생각보다 중요한데, 코드 작성 시점에 결정한 상속 관계는 `변경이 불가능` 하지만 합성 관계는 실행 시점에 `동적으로 변경`할 수 있기 때문이다. 따라서 **_상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다._**

물론 상속보다 합성을 이용하는 것이 구현 관점에서는 좀 더 번거롭고 복잡하게 느껴질 수 있다. 하지만 `설계는 변경과 관련된 것`이라는 점을 기억하라. **_변경에 유연하게 대처할 수 있는 설계가 대부분의 경우에 정답일 가능성이 높다._**

> 코드를 재사용하기 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법이다.

**_상속과 합성은 재사용의 대상이 다르다._** `상속`은 부모 클래스 안에 구현된 `코드 자체를 재사용`하지만 `합성`은 포함된 객체의 `퍼블릭 인터페이스를 재사용`한다. 따라서 상속 대신 합성을 사용하면 `구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경`할 수 있다. 다시말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.

---

## 상속을 합성으로 변경하기

상속으로 인한 몇 가지 문제점을 10장에서 살펴보았다.

`1. 불필요한 인터페이스 상속 문제`
자식 클래스에게는 부적합한 부모 클래스의 `오퍼레이션이 상속`되기 때문에 자식 클래스의 인스턴스 상태가 불안정해지는 문제. `JDK`에 포함된 `java.util.properties`와 `java.util.Stack`을 살펴보았다.

`2. 메서드 오버라이딩의 오작용 문제`
자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 **_자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제_** `java.util.HashSet`을 상속받은 `InstrumentedHashSet`을 살펴보았다.

`3. 부모 클래스와 자식 클래스의 동시 수정 문제`
부모 클래스와 자식 클래스 사이의 `개념적인 결합`으로 인해 **_부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제._** `PlayList`를 상속받은 `PersonalPlayList`를 살펴보았다.

이제 상속으로 불거진 위의 문제들을 `합성` 관계로 변경했을 때 어떻게 바뀌는지 살펴보자.

### 불필요한 인터페이스 상속 문제 : java.util.Properties와 java.util.Stack

먼저 `HashTable` 클래스와 `Properties` 클래스 사이의 상속 관계를 합성 관계로 바꿔보자. `Properties` 클래스에서 상속 관계를 제거하고 `HashTable`을 `Properties`의 인스턴스 변수로 포함시키면 합성 관계로 변경할 수 있다.

<script src="https://gist.github.com/BongHoLee/da0c267cd92aaf0f8bdf51576a417a4d.js"></script>

이제 더 이상 불필요한 `HashTable`의 오퍼레이션들이 `Properties`의 클래스의 퍼블릭 인터페이스를 오염시키지 않는다. 클라이언트는 오직 `Properties`에서 정의한 오퍼레이션만 사용할 수 있다. `Properties`의 클라이언트는 모든 타입의 키와 값을 저장할 수 있는 `HashTable`의 오퍼레이션을 사용할 수 없기 때문에 `String` 타입의 키와 값만 허용하는 `Properties`의 규칙을 어길 위험성은 사라진다.

내부 구현에 밀접하게 결합된 상속과 달리 `합성`으로 변경한 `Properties`는 `HashTable`의 내부 구현에 관해 알지 못한다. 단지 `Properties`는 `get`과 `set` 오퍼레이션이 포함된 퍼블릭 인터페이스를 통해서만 `HashTable`과 협력할 수 있을 뿐이다.

`Vector`를 상속받는 `Stack` 역시 `Vector`의 인스턴스 변수를 `Stack` 클래스의 인스턴스 변수로 선언함으로써 합성 관계로 변경할 수 있다.

<script src="https://gist.github.com/BongHoLee/36659f3a7179e2d84377428f2e910223.js"></script>

이제 `Stack`의 퍼블릭 인터페이스에는 불필요한 `Vector`의 오퍼레이션들이 포함되지 않는다. 클라이언트는 더 이상 임의의 위치에 요소를 추가하거나 삭제할 수 없다. 따라서 마지막 위치에서만 요소를 추가하거나 삭제할 수 있따는 `Stack`의 규칙을 어길 수 없게 된다. 합성 관계로 변경함으로써 클라이언트가 `Stack`을 잘못 사용할 수 도 있다는 가능성을 깔끌하게 제거한 것이다.

---

### 메서드 오버라이딩의 오작용 문제 : InstrumentedHashSet

`InstrumentedHashSet`도 같은 방법을 사용해서 합성 관계로 변경할 수 있다. `HashSet` 인스턴스를 내부에 포함한 후 `HashSet`의 퍼블릭 인터페이스에서 제공하는 오퍼레이션들을 이용해 필요한 기능을 구현하면 된다.

<script src="https://gist.github.com/BongHoLee/bbc5c6ed892420b3b4193915a11300df.js"></script>

여기까지만 보면 앞에서 살펴본 `Properties`와 `Stack`을 변경하던 과정과 동일하게 보일 것이다. 하지만 `InstrumentedHashSet`의 경우에는 다른 점이 한 가지 있다. `Properties`와 `Stack`을 합성으로 변경한 이유는 불필요한 오퍼레이션들이 퍼블릭 인터페이스에 스며드는 것을 방지하기 위해서다. 하지만 `InstrumentedHashSet`의 경우에는 `HashSet`이 제공하는 퍼블릭 인터페이스를 그대로 제공해야 한다.

`HashSet`에 대한 구현 결합도는 제거하면서도 퍼블릭 인터페이스를 그대로 상속받기 위해서 자바는 `인터페이스 문법`을 제공한다. `HashSet`은 `Set` 인터페이스를 구현한 구현체 중 하나이며, `InstrumentedHashSet`이 제공해야 하는 모든 오퍼레이션들은 `Set` 인터페이스에 정의돼 있다. 따라서 `InstrumentedHashSet`이 `Set` 인터페이스를 실체화하면서 내부에 `HashSet`의 인스턴스를 합성하면 `HashSet`에 대한 구현 결합도는 제거하면서도 퍼블릭 인터페이스는 그대로 유지할 수 있다.

<script src="https://gist.github.com/BongHoLee/33688c8eab6cf754a26a9b55b35b46fe.js"></script>

`InstrumentedHashSet`의 코드를 보면 `Set`의 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 `HashSet` 인스턴스에게 `동일한 메서드 호출을 그대로 전달`한다는 것을 알 수 있다. 이를 `포워딩`이라고 부르고 **_동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드라고 부른다._**

> 포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법이다.

---

### 부모 클래스와 자식 클래스의 동시 수정 문제 : PersonalPlayList

안타깝게도 `Playlist`의 경우에는 합성으로 변경하더라도 가수별 노래 목록을 유지하기 위해 `PlayList`와 `PersonalPlayList`를 함께 수정해야 하는 문제가 해결되지는 않는다.

<script src="https://gist.github.com/BongHoLee/5f1ffcd9134777203be4ce0a2e973dae.js"></script>

그렇다고 하더라도 여전히 상속보다는 합성을 사용하는게 더 좋은데, 향후에 `Playlist`의 내부 구현을 변경하더라도 **_파급효과를 최대한 PersonalPlayList 내부로 캡슐화 할 수 있기 때문이다._**

> 대부분의 경우 구현에 대한 결합보다는 인터페이스에 대한 결합이 더 좋다는 사실을 기억하라.

이번 장을 시작할 때 `상속`과 비교해서 `합성`은 `안정성과 유연성`이라는 장점을 제공한다고 말했다. 지금까지는 합성을 사용해서 `변경에 불안정한 코드를 안정적으로 유지하는 방법`을 살펴보았다. 이제 두 번째 장점인 `유연성`을 살펴보자.

이 경우에도 핵심은 동일하다. **_구현이 아니라 인터페이스에 의존하면 설계가 더 유연해진다는 것이다._**

---

## 상속으로 인한 조합의 폭발적인 증가

> 상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다.

가장 일반적인 상황은 **_작은 기능을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우다._** 일반적으로 다음과 같이 두 가지 문제점이 발생한다.

**_하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다._**

**_ 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다._**

`합성`을 사용하면 상속으로 인해 발생하는 클래스의 증가와 중복 코드를 간단하게 해결할 수 있다.

### 기본 정책과 부가 정책 조합하기

핸드폰 과금 시스템에 새로운 요구사항을 추가해보자. 현재 시스템에는 `일반 요금제`와 `심야 할인 요금제`라는 두 가지 종류의 요금제가 존재한다. 새로운 요구사항은 이 두 요금제에 `부가 정책을 추가`하는 것이다.

지금부터 핸드폰 요금제가 `기본 정책`과 `부가 정책`을 조합해서 구성된다고 가정 할 것이다.

<img src="/assets/img/ratepolicy.png" width="100%" height="auto">

기본 정책은 `가입자의 통화 정보`를 기반으로 한다. 기본 정책은 가입자의 한달 통화량을 기준으로 부과할 요금을 계산한다. 앞 장에서 소개한 `일반 요금제`와 `심야 할인 요금제`는 통화량을 기반으로 요금을 계산하기 때문에 `기본 요금 정책`으로 분류된다.

`부가 정책`은 통화량과 무관하게 `기본 정책`에 선택적으로 추가할 수 있는 요금 방식을 의미한다. 세금을 부과하는 정책이 바로 `부가 정책`에 해당한다.

`부가 정책`은 다음과 같은 특성을 가진다.

**_기본 정책의 계산 결과에 적용된다._**
세금 정책은 기본 정책인 `RegularPhone`이나 `NightlyDiscountPhone`의 계산이 끝난 결과에 세금을 부과한다.

**_선택적으로 적용할 수 있다._**
기본 정책의 계산 결과에 세금 정책을 적용할 수도 있고 적용하지 않을 수도 있다.

**_조합 가능히다._**
기본 정책에 세금 정책만 적용하는 것도 가능하고, 기본 요금 할인 정책만 적용하는 것도 가능하다. 또한 세금 정책과 기본 요금 할인 정책을 적용한 후에 세금 정책을 적용할 수도 있다.

**_부가 정책은 임의의 순서로 적용 가능하다._**
기본 정책에 세금 정책과 기본 요금 할인 정책을 함께 적용할 경우 세금 정책을 적용한 후에 기본 요금 할인 정책을 적용할 수도 있고, 기본 요금 할인 정책을 적용한 후에 세금 정책을 적용할 수도 있다.

<img src="/assets/img/ratepolicy2.png" width="100%" height="auto">

위 그림은 `기본 정책`과 `부가 정책`을 조합해서 만들 수 있는 모든 요금 정책의 종류를 나타낸 것이다. 그림을 통해 알 수 있는 것처럼 이 요구사항을 구현하는 데 가장 큰 장벽은 기본 정책과 부가 정책의 `조합 가능한 수가 매우 많다는 것`이다. 따라서 **_설계는 다양한 조합을 수용할 수 있도록 유연해야 한다._**

---

### 상속을 이용해서 기본 정책 구현하기

`상속`을 이용해서 기본 정책과 부가 정책을 구현해보자. 기본 정책은 `Phone` 추상 클래스를 루트로 삼는 기존의 상속 계층을 그대로 이용할 것이다. 일반 요금제를 구현하는 `RegularPhone`과 심야 할인 요금제를 구현하는 `NightlyDiscountPhone`은 `Phone`의 자식 클래스로 구현한다.

<script src="https://gist.github.com/BongHoLee/6b40af00da493ef6c50d09e7063e5a1f.js"></script>

`RegularPhone`과 `NightlyDiscountPhone`의 인스턴스만 단독으로 생성한다는 것은 부가 정책은 적용하지 않고 오직 기본 정책만으로 요금을 계산한다는 것을 의미한다.


### 기본 정책에 세금 정책 조합하기

만약 일반 요금제에 세금 정책을 조합해야 한다면 어떻게 해아할까? 가장 간단한 방법은 `RegularPhone` 클래스를 상속받은 `TaxableRegularPhone` 클래스를 추가하는 것이다. `TaxableRegularPhone` 클래스는 부모 클래스의 `calculateFee` 메서드를 오버라이딩 한 후 `super` 호출을 통해 부모 클래스에게 `calculateFee` 메시지를 전송한다. `RegularPhone`의 `calculateFee` 메서드는 일반 요금제 규칙에 따라 계산된 요금을 반환하므로 이 반환값에 세금을 부과해서 반환하면 일반 요금제와 세금 정책을 조합한 요금을 계산할 수 있다.

<script src="https://gist.github.com/BongHoLee/4042a6e3430f45f67694c25988b3440e.js"></script>

> 부모 클래스의 메서드를 재사용하기 위해 super 호출을 사용하면 원하는 결과는 쉽게 얻을 수 있지만 자식 클래스와 부모 클래스 사이의 결합도가 높아지고 만다.

결합도를 낮추는 방법은 **_자식 클래스가 부모 클래스의 메서드를 호출하지 않도록 부모 클래스에 추상 메서드를 제공하는 것이다._**

부모 클래스가 자신이 정의한 추상 메서드를 호출하고 자식 클래스가 이 메서드를 오버라이딩해서 부모 클래스가 원하는 로직을 제공하도록 수정하면 부모 클래스와 자식 클래스의 결합도를 느슨하게 만들 수 있다. 이 방법은 자식 클래스가 부모 클래스의 구체적인 구현이 아니라 필요한 동작의 명세를 기술하는 `추상화`에 의존하도록 만든다.

먼저 `Phone` 클래스에 새로운 추상메서드인 `afterCalclated`를 추가하자. 이 메서드는 자식 클래스에게 전체 요금을 계산한 후에 수행할 로직을 추가할 수 있는 기회를 제공한다.

<script src="https://gist.github.com/BongHoLee/9e681ab146931c14f64ae43e168a53ed.js"></script>

자식 클래스는 `afterCalculated` 메서드를 오버라이딩해서 계산된 요금에 적용할 작업을 추가한다. 일반 요금제를 구현하는 `RegularPhone`은 요금을 수정할 필요가 없기 때문에 `afterCalculated` 메서드에서 파라미터로 전달된 요금을 그대로 반환하도록 구현한다.

<script src="https://gist.github.com/BongHoLee/3570deb1a3afa0d6f57760992d411fd0.js"></script>

위 코드에서 알 수 있는 것처럼 **_부모 클래스에 추상 메서드를 추가하면 모든 자식 클래스들이 추상 메서드를 오버라이딩 해야 하는 문제가 발생한다._** 자식 클래스의 수가 적다면 큰 문제가 아니겠지만 자식 클래스의 수가 많을 경우에는 꽤나 번거로운 일이 될 수 밖에 없다.

`모든 추상 메서드의 구현이 동일하다는 사실`에도 주목하기 바란다. 유연성을 유지하면서도 중복 코드를 제거할 수 있는 방법은 `Phone`에서 `afterCalclated` 메서드에 대한 `기본 구현`을 함께 제공(`훅메서드`)하는 것이다. 이제 `RegularPhone`과 `NightlyDiscountPhone` 클래스에서는 `afterCalclated` 메서드를 오버라이딩 할 필요가 없다.

<script src="https://gist.github.com/BongHoLee/2a2ab762822f90b2967179abfbb0e710.js"></script>

이제 드디어 `TaxableRegularPhone`을 수정할 차례다. `TaxableRegularPhone`은 `RegularPhone`이 계산한 요금에 세금을 부과한다. 다음과 같이 `afterCalclated` 메서드를 오버라이딩 한 후 `fee`에 세금을 더해서 반환하도록 구현하자.

<script src="https://gist.github.com/BongHoLee/a7c6feb7c518f5ab1ee83a758a011bed.js"></script>

이제 심야 할인 요금제인 `NightlyDiscountPhone`에도 세금을 부과할 수 있도록 `NightlyDiscountPhone`의 자식 클래스인 `TaxableNightlyDiscountPhone`을 추가하자.

<script src="https://gist.github.com/BongHoLee/951b06c2de6a01a01bd5caf8db58614e.js"></script>

지금까지 구현한 `Phone`의 상속 계층에 세금 정책을 추가한 상속 계층을 다이어그램을 표현하면 아래와 같다.

<img src="/assets/img/phoneDiagram.png" width="100%" height="auto">

문제는 `TaxableNightlyDiscountPhone`과 `TaxableRegularPhone` 사이에 `코드를 중복`했다는 것이다. 두 클래스의 코드를 자세히 살펴보면 부모 클래스의 이름을 제외하곤 대부분의 코드가 거의 동일하다는 사실을 알 수 있을 것이다. 사실 자바를 비롯한 대부분의 객체지향 언어는 단일 상속만 지원하기 때문에 **_상속으로 인해 발생하는 중복 코드 문제를 해결하기가 쉽지 않다._**

---

### 기본 정책에 기본 요금 할인 정책 조합하기

이번에는 두 번째 부가 정책인 `기본 요금 할인 정책`을 `Phone`의 상속 계층에 추가해보자. 기본 요금 할인 정책이란 매달 청구되는 요금에서 고정된 요금을 차감하는 부가 정책을 가리킨다. 예를 들어 매달 1000원을 할인해주는 요금제가 있다면 이 요금제에는 부가 정책으로 기본 요금 할인 정책이 조합돼 있다고 볼 수 있다.

일반 요금제와 기본 요금 할인 정책을 조합하고 싶다면 `RegularPhone`을 상속받는 `RateDiscountableRegularPhone` 클래스를 추가하면 된다.

<script src="https://gist.github.com/BongHoLee/07ddf715c434447af907bc841a680f2d.js"></script>

심야 할인 요금제와 기본 요금 할인 정책을 조합하고 싶다면 `NightlyDiscountPhone`을 상속받는 `RateDiscountableNightlyDiscountPhone` 클래스를 추가하면 된다.

<script src="https://gist.github.com/BongHoLee/61574ccea8818f29422e1b09e5c858e8.js"></script>

아래 그림은 기본 요금 할인 정책을 추가한 후의 상속 계층을 표현한 것이다. 세금 정책과 마찬가지로 어떤 클래스를 선택하느냐에 따라 적용하는 요금제의 조합이 결정된다는 사실을 알 수 있다.

<img src="/assets/img/phoneDiagram2.png" width="100%" height="auto">

하지만 이번에도 부가 정책을 구현한 `RateDiscountableRegularPhone`와 `RateDiscountableNightlyDiscountPhone` 클래스 사이의 `중복 코드`를 추가했다. 이제 이 중복 코드가 어떤 문제를 초래하는지 살펴보자.

---

### 중복 코드의 덫에 걸리다.

부가 정책은 자유롭게 조합할 수 있어야 하고 적용되는 순서 역시 임의로 결정할 수 있어야 한다. 이 요구사항에 따르면 앞에서 구현한 세금 정책과 기본 요금 할인 정책을 함께 적용하는 것도 가능해야 하고, 세금 정책을 적용한 후에 기본 요금 할인 정책을 적용하거나 기본 요금 할인 정책을 적용한 후에 세금 정책을 적용하는 것도 가능해야 한다.

**_상속을 이용한 해결 방법은 모든 가능한 조합 별로 자식 클래스를 하나씩 추가하는 것이다._** 만약 일반 요금제의 계산 결과에 세금 정책을 조합한 후 기본 요금 할인 정책을 추가하고 싶다면 `TaxableRegularPhone`을 상속받는 새로운 자식클래스인 `TaxableAndRateDiscountableRegularPhone`을 추가해야 한다.

<script src="https://gist.github.com/BongHoLee/8750fd76ac56094756e98c07801d947c.js"></script>

`TaxableAndRateDiscountableRegularPhone`의 `afterCalclated` 메서드는 부모 클래스인 `TaxableRegularPhone`의 `afterCalclated` 메서드를 호출(super)해서 세금이 부과된 요금을 계산한 후 기본 요금 할인 정책을 적용한다. 따라서 세금을 부과하고 나서 기본 요금 할인을 적용하는 순서로 정책을 조합할 수 있다.

표준 요금제에 요금 할인 정책을 먼저 적용한 후 세금을 나중에 부과하고 싶다면 `RateDiscountableRegularPhone`을 상속받는 `RateDiscountAndTaxableReuglarPhone` 클래스를 추가하면 된다.

<script src="https://gist.github.com/BongHoLee/cf13b5509479d16bf0fcdaa88224f180.js"></script>

`TaxableAndDiscountableNightlyDiscountPhone` 클래스는 심야 할인 요금제의 계산 결과에 세금 정책을 적용한 후 기본 요금 할인 정책을 적용하는 케이스를 구현한다.

<script src="https://gist.github.com/BongHoLee/badf63a265e14159302232e4b7b98f9d.js"></script>

마지막으로 `RateDiscountableAndTaxableNightlyDiscuontPhone` 클래스는 심야 할인 요금제의 계산 결과에 기본 요금 할인 정책을 적용한 후 세금 정책을 적용한다.

<script src="https://gist.github.com/BongHoLee/efeda4a42a37598b650d2cb31c39a720.js"></script>

아래 그림은 현재까지 구현된 상속 계층을 그림으로 표현한 것이다. 꽤 복잡해 보이지 않는가? **_하지만 복잡성 보다 더 큰 문제가 있다. 바로 새로운 정책을 추가하기가 어렵다는 것이다._** 현재의 설게에 새로운 정책을 추가하기 위해서는 불필요하게 많은 수의 클래스를 상속 계층 안에 추가해야 한다.

<img src="/assets/img/phoneDiagram3.png" width="100%" height="auto">

만일 위와 같은 상속 계층에 새로운 `기본 정책`을 추가해야 한다고 가정해보자. 추가할 기본 정책은 `고정 요금제`로 `FixedRatePhone`이라는 클래스로 구현할 것이다. 모든 부가정책은 기본 정책에 적용 가능해야 하며 조합 순서 역시 자유로워야 한다. 따라서 새로운 기본 정책을 추가한다면 그에 따라 조합 가능한 부가 정책의 수만큼 새로운 클래스를 추가해야 한다.

아래 그림은 새로운 기본 정책을 추가한 결과를 다이어그램으로 표현한 것이다. 그림에서 짙은 음영으로 표현한 클래스가 새로 추가된 클래스로서 고정 요금제 하나를 추가하기 위해 5개의 새로운 클래스를 추가했다는 것을 알 수 있다.

<img src="/assets/img/phoneDiagram4.png" width="100%" height="auto">

이번에는 새로운 부가정책을 추가하는 경우를 생각해보자. 만일 `약정 할인 부가 정책`이 추가된다고 가정한다면 문제는 기본 정책을 구현하는 `RegularPhone`, `NightlyDiscountPhone`, `FixedRatePhone`에 약정 할인 정책을 선택적으로 적용할 수 있어야 할 뿐 아니라 다른 부가정책인 세금정책, 기본 요금 할인 정책과도 임의의 순서로 조합 가능해야 한다는 것이다.

하나의 부가 정책 추가 시 모든 조합 가능한 수는 폭발적으로 늘어나게 된다.

> 상속의 남용으로 하나으 ㅣ기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 클래스 폭발 문제 또는 조합의 폭발 문제라고 부른다.

> 클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생하는 문제다.

`컴파일 탕미에 결정된 자식 클래스와 부모 클래스 사이의 관계`는 변경될 수 없기 때문에 **_자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것뿐이다._**

클래스 폭발 문제는 `새로운 기능을 추가할 때뿐만 아니라 기능을 수정할 떄도 문제`가 된다. 만약 세금 정책을 변경해야 한다면 어떻게 해야할까? 세금 정책과 관련된 코드가 여러 클래스 안에 중복돼 있기 때문에 세금 정책과 관련된 모든 클래스를 찾아 동일한 방식으로 수정해야 할 것이다. 이 클래스 중에서 하나라도 누락한다면 세금이 부과되지 않는 버그가 발생하고 말것이다.

이 문제를 해결할 수 있는 최선의 방법은 상속을 포기하는 것이다.














### 참고 및 출처
  - 오브젝트
