---
layout: post
title: 디자인 패턴과 프레임워크
author: Bong5
categories: [Java, Books/Object]
---

## 디자인 패턴과 프레임워크

애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결 방법을 다시 사용하는 경우가 있다. 이처럼 **소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 [디자인 패턴]이라고 한다.** `디자인 패턴`의 목적은 `설계를 재사용`하는 것이다. 디자인 패턴은 **다양한 변경을 다루기 위해 반복적으로 재사용 할 수 있는 설계의 묶음이다.** 일단 디자인 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력 방식을 순간적으로 떠올릴 수 있게 된다.

`디자인 패턴`이 `설계를 재사용`하는 것이라면 `프레임워크`는 `설게와 코드를 함께 재사용`하기 위한 것이다. **프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.** 프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 `구현 코드를 쉽고 빠르게 재사용` 할 수 있다. **프레임워크는 각 애플리케이션 요구에 따라 적절하게 커스터마이징할 수 있는 확장 포인트를 제공한다.**

디자인 패턴과 프레임워크 모두 `일관성 있는 협력`과 관련이 있다. `디자인 패턴`은 `특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공`한다. 디자인 패턴이 `협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음`이라면, 프레임워크는 `일관성 있는 협력을 제공하는 확장 가능한 코드`라고 할 수 있다. **_결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다._**

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

`GOF의 디자인 패턴`에 의해 패턴이 대중화된 이후 소프트웨어와 관련된 패턴을 다루는 수많은 저작물이 쏟아져 나왔으며 그에 비례해서 패턴의 정의 역시 다양하고 풍부해져 왔다. 패턴이라는 거대한 숲 속에서 길을 잃지 않기 위해서는 패턴의 정의보다는 패턴이라는 요어 자체가 풍기는 미묘한 뉘앙스를 이해하는 것이 중요하다.

패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징이 있다.

- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.

- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다.

- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.

- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

**패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 '아이디어'다.** 일반적으로 패턴으로 인정하기 위한 조건으로 `3의 규칙`을 언급한다. 이 규칙에 따르면 `최소 세 가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주`할 수 있다.

**패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.** 패턴은 경험의 산물이다. 책상 위에서 탄생한 이론이나 원리와 달리 패턴은 치열한 실무 현장의 역학관계 속에서 검증되고 입증된 자산이다. 따라서 **실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.**

패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 `이름`이다. 패턴의 이름은 커뮤니티가 공유할 수 있는 중요한 어휘집을 제공한다. 잘 알려진 이름을 사용함으로써 **"인터페이스를 하나 추가하고 이 인터페이스를 구체화 하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임 시에 알고리즘을 바꿀 수 있게 하자"** 는 장황한 대화가 `STRATEGY 패턴`을 적용하자는 단순한 대화로 바뀐다. 패턴의 이름은 높은 수준의 대화를 가능하게 하는 원천이다.

패턴의 범위는 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아니다. 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.

**패턴은 홀로 존재하지 않는다.** 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있으며, 패턴들을 포함하는 더 큰 패턴 내에 통합될 수 있다.

### 패턴 분류

패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 `아키텍처 패턴`, `분석 패턴`, `디자인 패턴`, `이디엄`의 4가지로 분류하는 것이다. 4가지 중에서 가장 널리 알려진 것은 `디자인 패턴`이다. `디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결`하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다. `디자인 패턴`은 중간 규모의 패턴으로, `특정한 설계 문제를 해결하는 것을 목적`으로 하며, **프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.**

### 패턴과 책임-주도 설계

객체지향 설계에서 가장 중요한 일은 `올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일`이다. 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 트레이드오프를 통해 결정된다. 가끔씩 책임과 협력을 결정하는 작업이 손쉽게 진행될 때도 있지만 대부분의 경우에는 훌륭한 품질의 설계를 얻기 위해 많은 시간과 노력을 들여야만 한다. **어떤 책임이 필요한가? 이 책임을 어떤 객체에게 할당해야 하는가? 유연하고 확장 가능한 협력 관계를 구축하기 위해서는 객체와 객체 간에 어떤 의존성이 존재해야 하는가?**

`패턴`은 `공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿`이다. 또한 `패턴`은 `반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공`한다. 예를 들면 `STRATEGY 패턴`은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다. `BRIDGE 패턴` 은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 한다. `OBSERVER 패턴`은 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.

**여기서 언급한 패턴들의 세부적인 내용이 중요한 것이 아니다.** 중요한 것은 패턴을 따르면 `특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실`이다. **특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.**

`패턴의 구성 요소는 클래스가 아니라 '역할'`이다. 예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 `COMPOSITE 패턴`을 살펴보자. 아래 그림은 `COMPSITE 패턴`의 일반적인 구조를 표현한 것이다. 패턴의 구성 요소인 `Component`, `Composite`, `Leaf`는 클래스가 아니라 `협력에 참여하는 객체들의 역할`이다. `Component`가 역할이기 때문에 `Component`가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 `Component`의 역할을 수행할 수 있다.

<img src="/assets/img/pattern1.PNG" width="100%" height="auto">

`패턴을 구성하는 요소가 클래스가 아니라 역할`이라는 사실은 `패턴 템플릿을 구현할 수 있는 다양한 방법이 존재`한다는 사실을 암시한다. `역할`은 `동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합`을 암시하기 때문에 아래 그림과 같이 하나의 객체가 세 가지 역할 모두를 수행하더라도 문제가 없다.

<img src="/assets/img/pattern2.PNG" width="100%" height="auto">

반대로 `다수의 클래스가 동일한 역할을 구현`할 수도 있다. 아래 그림은 8장에서 살펴본 `중복 할인 정책`의 구조를 다이어그램으로 표현한 것이다. 중복 할인 설계의 기본 구조는 `COMPOSITE 패턴`을 따른다. `OverlappedDiscountPolicy`는 `Composite`의 역할을 수행하고 `AmountDiscountPolicy`와 `PercentDiscountPolicy`가 `Leaf`의 역할을 수행한다. 여기서는 서로 다른 두 클래스인 `AmountDiscountPolicy`와 `PercentDiscountPolicy`가 동일한 `Leaf`의 역할을 수행한다는 점을 주목하자.

<img src="/assets/img/pattern3.PNG" width="100%" height="auto">

디자인 패턴의 구성요소가 `클래스와 메서드`가 아니라 `역할과 책임`이라는 사실을 이해하는 것이 중요하다. 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 `역할, 책임, 협력의 관점에서 유사성을 공유`한다는 것이지 `특정한 구현 방식을 강제하는 것이 아니라는 점을 이해`하는 것 역시 중요하다. **디자인 패턴은 단지 역할과 책임, 협력의 패턴을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.**

위 그림 모두 올바른 `COMPOSITE 패턴`이다. 두 가지 모두 `COMPOSITE 패턴`에서 제공하는 기본적인 `역할과 책임, 협력 관계를 준수`한다. 이것은 **패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미한다.**






### 참고 및 출처

  - 오브젝트
