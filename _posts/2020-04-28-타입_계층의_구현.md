---
layout: post
title: 타입 계층의 구현
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

앞서 `서브 클래싱과 서브 타이핑` 챕터를 학습하면서 객체지향 프로그래밍에서의 `타입 계층`이 무엇을 의미하는지 대략적으로 이해했다. 객체지향을 처음 접한 입문자들이 흔히 오해하는 부분이 `클래스와 타입`을 동일한 것으로 간주하는 것이다. **_타입은 개념의 분류를 의미하고 클래스는 타입을 구현하는 한 가지 방법일 뿐이다._**

`타입`은 다양한 방법으로 구현할 수 있다. 사실 `타입`의 개념을 이해하는데 가장 큰 걸림돌은 **_타입을 구현하는 방법이 다양하다는 것이다._** 심지어 타입을 구현할 수 있는 독자적인 방법을 제공하는 언어도 있다.

`타입 계층`은 `타입`보다 상황이 좀 더 복잡한데 **다양한 방식으로 구현된 타입들을 하나의 타입 계층 안에 조합할 수 있기 때문이다.** 예를 들어 자바에서는 `인터페이스`와 `클래스`를 이용하여 개별 타입을 구현한 후 이 두 가지 종류의 `타입 구현체`를 함께 포함하도록 `타입 계층`을 구성할 수 있다.

이번 챕터를 공부하면서 반드시 알아야 할 두 가지 사항이 있다.

1. **타입 계층은 동일한 메시지에 대한 행동 호환성을 전제로 하기 때문에 이번 챕터에서 언급하는 모든 방법은 타입 계층을 구현하는 방법인 동시에 다형성을 구현하는 방법이기도 하다.** 이번 장에서 설명하는 방법을 자세히 살펴보면 공통적으로 `슈퍼 타입`에 대해 전송한 `메시지`를 `서브타입 별로 다르게 처리`할 수 있는 방법을 제공한다는 사실을 알 수 있다. 이 방법들은 `동적 메서드 탐색`과 유사한 방식을 이용해 적절한 메서드를 검색한다.

2. 이번 장에서 제시하는 방법을 이용하여 `타입 계층`을 구현한다고 해서 **서브타이핑 관계가 보장되는 것은 아니다.** 앞선 챕터에서 설명한 것 처럼 `올바른 서브타이핑` 관계가 되기 위해서는 서브타입이 슈퍼타입을 `대체`할 수 있도록 `리스코프 치환 원칙을 준수`해야 한다. **리스코프 치환 원칙은 특정한 구현 방법에 의해 보장되는 것이 아니다.** 즉, 서브타이핑 관계를 구현하는 특정 구현 방법이 있는 것이 아니다. 따라서 **클라이언트의 관점에서 타입을 동일하게 다룰 수 있도록 [의미적]으로 [행동 호환성]을 보장하는 것은 전적으로 프로그래머의 책임이다.** 뒤에서 다루는 다양한 `구현 방법`을 이용할 때 **타입 사이의 리스코프 치환 원칙을 준수하도록 만드는 책임은 전적으로 우리에게 있다는 사실을 기억하자.**

이제부터 `타입`과 `타입 계층`을 구현할 수 있는 다양한 방법을 살펴보자.

### 클래스를 이용한 타입 계층 구현

`클래스 기반 객체지향 언어`를 사용하는 대부분의 사람들은 `타입`이라는 말에 반사적으로 `클래스`를 떠올린다. **타입은 객체의 [퍼블릭 인터페이스]를 가리키기 때문에 결과적으로 클래스는 객체의 타입과 구현을 동시에 정의하는 것과 같다.** 이것이 객체지향 언어에서 클래스를 `사용자 정의 타입`이라고 부르는 이유다.

10장에서 구현한 `Phone` 클래스를 살펴보자.

<script src="https://gist.github.com/BongHoLee/823332101dbbc4b1624516dd5d0186e4.js"></script>

`Phone`의 인스턴스는 `calculateFee`메시지를 수신할 수 있는 `퍼블릭 메서드`를 구현한다. 이 메서드는 결과적으로 `Phone의 퍼블릭 인터페이스를 구성`한다. `타입은 퍼블릭 인터페이스를 의미`하기 때문에 `Phone 클래스는 Phone 타입을 구현`한다고 말할 수 있다. **Phone은 calculateFee 메시지에 응답할 수 있는 타입을 선언하는 동시에 객체 구현을 정희하고 있는 것이다.**

`Phone`의 경우처럼 타입을 구현할 수 있는 방법이 단 한 가지만 존재하는 경우에는 타입과 클래스를 동일하게 취급해도 무방하다. 여기서 `타입의 구현 방법이 단 한 가지`라는 말이 중요하다. **타입을 구현할 수 있는 다양한 방법이 존재하는 순간 타입과 클래스는 갈라지기 시작한다.**

`Phone`과 `퍼블릭 인터페이스`는 동일하지만 `다른 방식으로 구현`해야 하는 객체가 필요하다고 가정해보자. 다시 말해서 `구현은 다르지만 Phone과 동일한 타입`으로 분류되는 객체가 필요한 것이다. `퍼블릭 인터페이스`는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 가장 간단한 방법은 `상속`을 이용하는 것이다.

<script src="https://gist.github.com/BongHoLee/4a26065b860a9ddb91accad7ca257ba1.js"></script>

`상속`을 이용하면 자식 클래스가 부모 클래스의 `구현`뿐 아니라 `퍼블릭 인터페이스`도 물려받을 수 있기 때문에 `타입 계층`을 쉽게 구현할 수 있다. 하지만 10장에서 살펴본 것 처럼 **상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시키기 때문에 구체 클래스를 상속받는 것은 피해야 한다.** 가급적 `추상 클래스`를 상속받거나 `인터페이스`를 구현하는 방법을 사용하자.

`클래스는 타입을 구현할 수 있는 다양한 방법 중 하나`일 뿐이다. 비교적 최근에 발표된 객체지향 언어들은 클래스를 사용하지 않고도 타입을 구현할 수 있는 방법을 제공한다. 대표적인 것이 자바와 C#의 `인터페이스`이다.

### 인터페이스를 이용한 타입 계층 구현

간단한 게임을 개발하고 있다고 가정하자. 게임은 사용자와 상호작용 할 수 있는 다양한 객체들로 구성된다. 수많은 객체들 중에서 실제로 플레이어의 `게임 플레이에 영향을 미치는 객체들을 동일한 타입으로 분류`하기를 원한다고 가정하자. 이 객체들의 타입을 `GameObject`라고 부를 것이다.

게임 안에는 `GameObject` 타입으로 분류될 수 있는 다양한 객체들이 존재한다. `화면 상에서 폭발 효과를 표현하는 Explosion`과 `사운드 효과를 표현하는 Sound`가 `GameObject` 타입의 대표적인 예다. 이 중에서 `Explosion`과 `Sound`는 게임에 필요한 다양한 효과 중 하나이기 때문에 이들을 다시 `Effect` 타입으로 분류할 수 있다. 이 중에서 `Explosion`은 `화면에 표시될 수 있기 때문에 Displayable 타입으로도 분류`될 수 있다. 아마 `Displayable 타입`에는 적대적인 `Monster`와 플레이어가 직접 조작 가능한 `Player` 타입도 존재할 것이다.

<img src="/assets/img/subtype1.PNG" width="100%" height="auto">

이제 `클래스와 상속`을 이용해 이 객체들을 구현하는 방법을 생각해보자. `Sound 타입은 Effect 타입의 서브타입`이기 때문에 `Effect` 클래스를 상속받아야 한다. `Explosion 타입은 Effect 타입인 동시에 Displayable 타입`이기 때문에 `Effect 클래스와 Displayable 클래스를 동시에 상속`받아야ㄴ 한다.

문제는 대부분의 언어들이 `다중 상속`을 지원하지 않는다는 데 있따. 만약 자바를 사용하고 있다면 `Explosion 클래스`가 `Effect 클래스`와 `Displayable 클래스`를 동시에 상속받을 수 있는 방법은 없다.

<img src="/assets/img/subtype2.PNG" width="100%" height="auto">

게다가 이 클래스들을 동일한 상속 계층 안에 구현하고 싶지도 않다. **클래스들을 상속 관계로 연결하면 자식 클래스가 부모 클래스의 구현에 강하게 결합될 확률이 높다. 결과적으로 상속 계층 안의 클래스 하나를 변경했는데도 게임에 포함된 수많은 클래스들이 영향을 받을 수 있다.**

상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법은 `클래스가 아닌 인터페이스를 사용`하는 것이다.

<script src="https://gist.github.com/BongHoLee/5eaacb84a981922de1b51575838625ea.js"></script>

`GameObject` 타입은 좀 더 많은 행동을 가진 다른 타입에 의해 `확장`될 수 있다. 예를 들어, 게임의 많은 요소들은 화면으로 표시될 필요가 있다. 이 객체들은 `화면 표시라는 동일한 행동을 제공`하기 때문에 별도의 타입으로 분류돼야 한다. 이들을 `Displayable 타입`으로 분류하는 것이 좋을 것 같다.

<script src="https://gist.github.com/BongHoLee/38a5f56d8b546ef4772464e0867b3499.js"></script>

`Displayable 인터페이스`가 `GameObject를 확장`한다는 사실에 주목하자. 위 코드는 `Displayable 타입을 GameObject 타입의 서브타입으로 정의`한다. 결과적으로 `Displayable` 타입의 모든 인스턴스는 `GameObject` 타입의 인스턴스 집합에도 포함된다. 이처럼 **인터페이스가 다른 인터페이스를 [확장]하도록 만들면 슈퍼타입과 서브타입간의 [타입계층]을 구성할 수 있다.**

화면에 표시될 수 있는 `Displayable` 타입의 인스턴스들 중에는 다른 요소들과의 충돌로 인해 이동에 제약을 받거나 피해를 입는 등의 처리가 필요한 객체들이 존재한다. 이런 객체들을 위해 `Collidable` 타입을 정의하고 충돌 체크를 위한 `collideWith` 오퍼레이션을 추가하자. 충돌을 체크하는 객체들은 모두 화면에 표시 가능해야 하기 때문에 `Collidable` 타입은 `Displayable` 타입의 `서브타입`이어야 한다. `Displayable`  타입은 `GameObject`의 서브타입이므로  `Collidable` 타입은 자동적으로 `GameObject`의 서브타입이 된다.

<script src="https://gist.github.com/BongHoLee/a24e337d741b89a78397953a2d9adcfd.js"></script>

화면에 표시되지 않더라도 게임에 다양한 효과를 부여할 수 있는 부가적인 요소들이 필요하다. 대표적인 것이 게임의 배경음악과 효과음이다. 이들은 특정한 조건에 따라 활성화돼야 하므로 이 행동을 제공하는 `Effect` 라는 타입을 정의하자.

<script src="https://gist.github.com/BongHoLee/e826d71ed2db5075db6bb3fbe7832a88.js"></script>

이제 타입에 속할 객체들을 구현하자. 여기서는 **인터페이스로 정의한 타입을 구현하기 위해 클래스를 사용할 것이다.** `자바`같은 경우 **인터페이스를 이용해 타입의 퍼블릭 인터페이스를 정의하고 클래스를 이용해 객체를 구현하는 것이 일반적인 패턴이다.** 인터페이스와 클래스를 함께 조합하면 `다중 상속`의 딜레마에 빠지지 않을 수 있고 `단일 상속 게층`으로 인한 결합도 문제도 피할 수 있다.

가장 먼저 사용자의 분신이 되어줄 `Player`가 필요하다. `Player`는 화면에 표시돼야 할 뿐만 아니라 화면상에 표현된 다른 객체들과의 충돌을 체크해야 한다. 따라서 `Playable`은 `Collidable` 타입의 인스턴스여야 한다. 클래스를 이용해 타입을 구현하자.

<script src="https://gist.github.com/BongHoLee/25b5f9af9fd64cd0edeb89822b009826.js"></script>

플레이어를 공격할 `Monster` 역시 `Collidable` 타입이 정의한 행동을 제공해야 한다.

<script src="https://gist.github.com/BongHoLee/f536414aa598d41370fa2d13cea67640.js"></script>

효과음은 화면에 표시될 필요도 없고 다른 요소와 충돌 여부를 체크할 필요도 없다. 하지만 플레이어 캐릭터와 몬스터 캐릭터가 충돌하는 경우처럼 `특정 이벤트가 발생할 경우 활성화`되어야 한다. 따라서 효과음을 구현한 `Sount` 클래스는 `Effect` 인터페이스를 구현해야 한다.

<script src="https://gist.github.com/BongHoLee/002efe6604e548e1da8f967eef9d7b04.js"></script>

다양한 `폭발 효과`를 구현한 `Explosion` 객체는 화면에 표시될 수 있어야 하고 충돌 등의 특정 조건에 의해 활성화 되는 `Effect`의 일종이다. `Sound`와 달리 다른 요소들과의 충돌 여부를 체크할 필요는 없기 때문에 `Displayable`과 `Effect` 인터페이스를 구현하면 된다.

<script src="https://gist.github.com/BongHoLee/696f2e0bf59e3078ad13ac891f805b6a.js"></script>

아래 그림은 지금까지 살펴본 `타입`과 `타입을 구현한 클래스`사이의 관계를 그림으로 표현한 것이다.

<img src="/assets/img/subtype3.PNG" width="100%" height="auto">

이 그림으로부터 다음과 같은 사실을 알 수 있다.

- `여러 클래스가 동일한 타입을 구현할 수 있다.`
**Plyaer와 Monster 클래스는 서로 다른 클래스지만 이 두 클래스의 인스턴스들은 Collidable 인터페이스를 구현하고 있기 때문에 동일한 메시지에 응답할 수 있다. 따라서 서로 다른 클래스를 이용해서 구현됐지만 타입은 동일하다.**

- `하나의 클래스가 여러 타입을 구현할 수 있다.`
**Explosion 인스턴스는 Displayable 인터페이스와 동시에 Effect 인터페이스도 구현한다. 따라서 Explosion의 인스턴스는 Displayable 타입인 동시에 Effect 타입이기도 하다.**

중요한 것은 `인터페이스를 이용해 타입을 정의`하고 `클래스를 이용해 객체를 구현`하면 클래스 상속을 사용하지 않고도 `타입 계층`을 구현할 수 있다는 사실이다.

```
클래스와 타입 간의 차이를 이해하는 것은 중요한 일이다.

객체의 클래스는 객체의 구현을 정의한다. 클래스는 [객체의 내부 상태]와 [오퍼레이션 구현 방법]을 정의한다.

객체의 타입은 [인터페이스]만을 정의하는 것으로, 객체가 반응(응답)할 수 있는 [오퍼레이션 집합을 정의]한다.

하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있다. 즉, 객체의 구현은 다를지라도 인터페이스는 같을 수 있다는 것이다.

클래스와 타입 간에는 밀접한 관련이 있다. 클래스도 객체가 만족할 수 있는 오퍼레이션을 정의하고 있으므로 타입을 정의하는 것이기도 하다. 그래서 객체가 클래스의 인터페이스라고 말할 때 객체는 클래스가 정의하고 있는 인터페이스를 지원한다는 뜻을 내포한다.
```

영화 예매 시스템에서도 영화의 할인 조건을 구현한 타입 계층을 구현하기 위해 자바의 `인터페이스`와 `클래스`를 사용했다.

<script src="https://gist.github.com/BongHoLee/78b5c662b1db05fb4a945787cd84370f.js"></script>

이 예제에서는 할인 조건이라는 타입을 정의하기 위해 자바 인터페이스로 `DiscountCondition`을 정의했다. 클래스인 `SequenceCondition`과 `PeriodCondtion`은 `DiscountCondition` 타입으로 분류될 객체들에 대한 `구현`을 담고 있다.

```
클래스와 타입의 차이점을 이해하는 것은 설계 관점에서 매우 중요하다.

[타입]은 [동일한 퍼블릭 인터페이스]를 가진 객체들의 범주다.

[클래스]는 [타입에 속한 객체들을 구현]하기 위한 [구현 메커니즘]이다.

객체지향에서 중요한 것은 협력 안에서 객체가 제공하는 [행동]이라는 사실을 기억하자. 따라서 중요한 것은 [클래스 자체가 아니라 타입]이다.

[타입]이 먼저 식별된 후에 타입에 속하는 객체를 구현하기 위해 [클래스]를 사용하는 것이다.
```

이 예제는 클래스가 객체지향의 중심이 아니라는 사실을 잘 보여준다. **클래스가 아니라 타입에 집중하라.** 중요한 것은 `객체가 외부에 제공하는 행동`, 즉 `타입을 중심으로 객체들의 계층을 설계`하는 것이다. 타입이 아니라 클래스를 강조하면 객체의 퍼블릭 인터페이스가 아닌 세부 구현에 결합된 협력 관계를 낳게된다.

### 추상 클래스를 이용한 타입 계층 구현

클래스 상속을 이용해 `구현을 공유`하면서도 결합도로 인한 부작용을 피하는 방법도 있다. 바로 `추상 클래스`를 이용하는 방법이다. 영화 예매 시스템에서는 할인 정책을 구현하기 위한 `DiscountPolicy`가 추상 클래스에 해당한다.

<script src="https://gist.github.com/BongHoLee/345987b8865da14ebc4b8cf95257be2d.js"></script>

이제 추상클래스인 `DiscountPolicy`를 상속받는 구체 클래스를 추가함으로써 `타입 계층`을 구현할 수 있다.

<script src="https://gist.github.com/BongHoLee/48d0ec8fd8c07f878c48b7173822ad87.js"></script>

`구체 클래스로 타입을 정의`해서 상속받는 방법과 `추상 클래스로 타입을 정의`해서 상속받는 방법 사이에는 두 가지 주요한 차이점이 있다. 하나는 `추상화의 정도`이고 다른 하나는 `상속을 사용하는 의도`이다.

첫 번째로 **의존하는 대상의 추상화 정도가 다르다.** 앞에서 `클래스를 이용해 타입 계층을 구현했던 Phone 클래스`의 경우 자식 클래스인 `NightlyDiscountPhone의 calculateFee` 메서드가 부모 클래스인 `Phone의 calcuateFee` 메서드의 **구체적인 내부 구현에 강하게 결합된다.** 따라서 `Phone`의 내부 구현이 변경될 경우 자식 클래스인 `NightlyDiscountPhone`도 함께 변경될 가능성이 높다.

이에 비해 추상 클래스인 `DiscountPolicy`의 경우 자식 클래스인 `AmountDiscountPolicy`와 `PercentDiscountPolicy`가 `DiscountPolicy`의 **내부 구현이 아닌 추상 메서드의 시그니처에만 의존한다.** 이 경우 자식 클래스들은 `DiscountPolicy`가 어떤 식으로 구현되어 있는지 알 필요가 없다. 단지 추상 메서드로 정의된 `getDiscountPolicy` 메서드를 오버라이딩한다면 된다는 사실에만 의존해도 무방하다.

여기서 `부모 클래스와 자식 클래스 모두 추상메서드인 getDiscountAmount에 의존`한다는 사실이 중요하다. 이것은 `의존성 역전 원칙의 변형`이다. `DiscountPolicy`는 할인 조건을 판단하는 `고차원 모듈`이다. 그에 비해 `AmountDiscountPolicy`와 `PercentDiscountPolicy`는 할인 금액을 계산하는 `저차원 모듈`이다. **고차원 모듈과 저차원 모듈 모두 추상 메서드인 getDiscountAmount에 의존한다.**

또한 `DiscountPolicy`의 구체 메서드인 `calcuateDiscountAmount`가 추상 메서드 `getDiscountAmount`를 호출하며 자식 클래스들은 모두 이 추상메서드의 `시그니처를 준수`한다. 따라서 **구체적인 메서드가 추상적인 메서드에 의존하기 때문에 의존성 역전 원칙을 따른다고 할 수 있다.** 결과적으로 이 설계는 유연한 동시에 변화에 안정적이다.

한 가지 조언은 **모든 구체 클래스의 부모 클래스를 항상 추상 클래스로 만들기 위해 노력하라는 것이다.** **의존하는 대상이 더 추상적일수록 결합도는 낮아지고 결합도가 낮아질수록 변경으로 인한 영향도는 줄어든다.** `DiscountPolicy`의 자식 클래스들은 `구체적인 구현이 아닌 추상 메서드에 의존`하고 있기 때문에 추상메서드의 명세가 변경되지 않는 한 영향을 받지 않는다.

두 번째 차이점을 `상속을 사용하는 의도`다. `Phone`은 상속을 염두에 두고 설계된 것이 아니다. `Phone`의 설계자는 나중에 `NightlyDiscountPhone`이라는 개념이 추가될 것이라는 사실을 알지 못했다. 따라서 `Phone`에는 미래의 확장을 위한 어떤 준비도 돼있지 않다. 사실 `NightlyDiscountPhone`의 개발자가 `Phone`의 코드를 재사용하기 위해 상속을 사용한 것은 `트릭`에 가깝다.

그에 반해 `DiscountPolicy`는 처음부터 상속을 염두에 두고 설계된 클래스다. `DiscountPolicy`는 추상 클래스이기 때문에 자신의 인스턴스를 직접 생성할 수 없다. `DiscountPolicy`의 유일한 목적은 자식 클래스를 추가하는 것이다. 이 클래스는 추상메서드를 제공함으로써 상속 계층을 쉽게 확장할 수 있게 하고 결합도로 인한 부작용을 방지할 수 있는 안전망을 제공한다.






---

## 타입











### 참고 및 출처

  - 오브젝트
