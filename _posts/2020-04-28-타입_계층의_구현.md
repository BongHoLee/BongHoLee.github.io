---
layout: post
title: 타입 계층의 구현
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

앞서 `서브 클래싱과 서브 타이핑` 챕터를 학습하면서 객체지향 프로그래밍에서의 `타입 계층`이 무엇을 의미하는지 대략적으로 이해했다. 객체지향을 처음 접한 입문자들이 흔히 오해하는 부분이 `클래스와 타입`을 동일한 것으로 간주하는 것이다. **_타입은 개념의 분류를 의미하고 클래스는 타입을 구현하는 한 가지 방법일 뿐이다._**

`타입`은 다양한 방법으로 구현할 수 있다. 사실 `타입`의 개념을 이해하는데 가장 큰 걸림돌은 **_타입을 구현하는 방법이 다양하다는 것이다._** 심지어 타입을 구현할 수 있는 독자적인 방법을 제공하는 언어도 있다.

`타입 계층`은 `타입`보다 상황이 좀 더 복잡한데 **다양한 방식으로 구현된 타입들을 하나의 타입 계층 안에 조합할 수 있기 때문이다.** 예를 들어 자바에서는 `인터페이스`와 `클래스`를 이용하여 개별 타입을 구현한 후 이 두 가지 종류의 `타입 구현체`를 함께 포함하도록 `타입 계층`을 구성할 수 있다.

이번 챕터를 공부하면서 반드시 알아야 할 두 가지 사항이 있다.

1. **타입 계층은 동일한 메시지에 대한 행동 호환성을 전제로 하기 때문에 이번 챕터에서 언급하는 모든 방법은 타입 계층을 구현하는 방법인 동시에 다형성을 구현하는 방법이기도 하다.** 이번 장에서 설명하는 방법을 자세히 살펴보면 공통적으로 `슈퍼 타입`에 대해 전송한 `메시지`를 `서브타입 별로 다르게 처리`할 수 있는 방법을 제공한다는 사실을 알 수 있다. 이 방법들은 `동적 메서드 탐색`과 유사한 방식을 이용해 적절한 메서드를 검색한다.

2. 이번 장에서 제시하는 방법을 이용하여 `타입 계층`을 구현한다고 해서 **서브타이핑 관계가 보장되는 것은 아니다.** 앞선 챕터에서 설명한 것 처럼 `올바른 서브타이핑` 관계가 되기 위해서는 서브타입이 슈퍼타입을 `대체`할 수 있도록 `리스코프 치환 원칙을 준수`해야 한다. **리스코프 치환 원칙은 특정한 구현 방법에 의해 보장되는 것이 아니다.** 즉, 서브타이핑 관계를 구현하는 특정 구현 방법이 있는 것이 아니다. 따라서 **클라이언트의 관점에서 타입을 동일하게 다룰 수 있도록 [의미적]으로 [행동 호환성]을 보장하는 것은 전적으로 프로그래머의 책임이다.** 뒤에서 다루는 다양한 `구현 방법`을 이용할 때 **타입 사이의 리스코프 치환 원칙을 준수하도록 만드는 책임은 전적으로 우리에게 있다는 사실을 기억하자.**

이제부터 `타입`과 `타입 계층`을 구현할 수 있는 다양한 방법을 살펴보자.

### 클래스를 이용한 타입 계층 구현

`클래스 기반 객체지향 언어`를 사용하는 대부분의 사람들은 `타입`이라는 말에 반사적으로 `클래스`를 떠올린다. **타입은 객체의 [퍼블릭 인터페이스]를 가리키기 때문에 결과적으로 클래스는 객체의 타입과 구현을 동시에 정의하는 것과 같다.** 이것이 객체지향 언어에서 클래스를 `사용자 정의 타입`이라고 부르는 이유다.

10장에서 구현한 `Phone` 클래스를 살펴보자.

<script src="https://gist.github.com/BongHoLee/823332101dbbc4b1624516dd5d0186e4.js"></script>

`Phone`의 인스턴스는 `calculateFee`메시지를 수신할 수 있는 `퍼블릭 메서드`를 구현한다. 이 메서드는 결과적으로 `Phone의 퍼블릭 인터페이스를 구성`한다. `타입은 퍼블릭 인터페이스를 의미`하기 때문에 `Phone 클래스는 Phone 타입을 구현`한다고 말할 수 있다. **Phone은 calculateFee 메시지에 응답할 수 있는 타입을 선언하는 동시에 객체 구현을 정희하고 있는 것이다.**

`Phone`의 경우처럼 타입을 구현할 수 있는 방법이 단 한 가지만 존재하는 경우에는 타입과 클래스를 동일하게 취급해도 무방하다. 여기서 `타입의 구현 방법이 단 한 가지`라는 말이 중요하다. **타입을 구현할 수 있는 다양한 방법이 존재하는 순간 타입과 클래스는 갈라지기 시작한다.**

`Phone`과 `퍼블릭 인터페이스`는 동일하지만 `다른 방식으로 구현`해야 하는 객체가 필요하다고 가정해보자. 다시 말해서 `구현은 다르지만 Phone과 동일한 타입`으로 분류되는 객체가 필요한 것이다. `퍼블릭 인터페이스`는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 가장 간단한 방법은 `상속`을 이용하는 것이다.

<script src="https://gist.github.com/BongHoLee/4a26065b860a9ddb91accad7ca257ba1.js"></script>

`상속`을 이용하면 자식 클래스가 부모 클래스의 `구현`뿐 아니라 `퍼블릭 인터페이스`도 물려받을 수 있기 때문에 `타입 계층`을 쉽게 구현할 수 있다. 하지만 10장에서 살펴본 것 처럼 **상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시키기 때문에 구체 클래스를 상속받는 것은 피해야 한다.** 가급적 `추상 클래스`를 상속받거나 `인터페이스`를 구현하는 방법을 사용하자.

`클래스는 타입을 구현할 수 있는 다양한 방법 중 하나`일 뿐이다. 비교적 최근에 발표된 객체지향 언어들은 클래스를 사용하지 않고도 타입을 구현할 수 있는 방법을 제공한다. 대표적인 것이 자바와 C#의 `인터페이스`이다.

### 인터페이스를 이용한 타입 계층 구현

간단한 게임을 개발하고 있다고 가정하자. 게임은 사용자와 상호작용 할 수 있는 다양한 객체들로 구성된다. 수많은 객체들 중에서 실제로 플레이어의 `게임 플레이에 영향을 미치는 객체들을 동일한 타입으로 분류`하기를 원한다고 가정하자. 이 객체들의 타입을 `GameObject`라고 부를 것이다.

게임 안에는 `GameObject` 타입으로 분류될 수 있는 다양한 객체들이 존재한다. `화면 상에서 폭발 효과를 표현하는 Explosion`과 `사운드 효과를 표현하는 Sound`가 `GameObject` 타입의 대표적인 예다. 이 중에서 `Explosion`과 `Sound`는 게임에 필요한 다양한 효과 중 하나이기 때문에 이들을 다시 `Effect` 타입으로 분류할 수 있다. 이 중에서 `Explosion`은 `화면에 표시될 수 있기 때문에 Displayable 타입으로도 분류`될 수 있다. 아마 `Displayable 타입`에는 적대적인 `Monster`와 플레이어가 직접 조작 가능한 `Player` 타입도 존재할 것이다.

<img src="/assets/img/subtype1.PNG" width="100%" height="auto">

이제 `클래스와 상속`을 이용해 이 객체들을 구현하는 방법을 생각해보자. `Sound 타입은 Effect 타입의 서브타입`이기 때문에 `Effect` 클래스를 상속받아야 한다. `Explosion 타입은 Effect 타입인 동시에 Displayable 타입`이기 때문에 `Effect 클래스와 Displayable 클래스를 동시에 상속`받아야 한다.

문제는 대부분의 언어들이 `다중 상속`을 지원하지 않는다는 데 있따. 만약 자바를 사용하고 있다면 `Explosion 클래스`가 `Effect 클래스`와 `Displayable 클래스`를 동시에 상속받을 수 있는 방법은 없다.

<img src="/assets/img/subtype2.PNG" width="100%" height="auto">

게다가 이 클래스들을 동일한 상속 계층 안에 구현하고 싶지도 않다. **클래스들을 상속 관계로 연결하면 자식 클래스가 부모 클래스의 구현에 강하게 결합될 확률이 높다. 결과적으로 상속 계층 안의 클래스 하나를 변경했는데도 게임에 포함된 수많은 클래스들이 영향을 받을 수 있다.**

상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법은 `클래스가 아닌 인터페이스를 사용`하는 것이다.

<script src="https://gist.github.com/BongHoLee/5eaacb84a981922de1b51575838625ea.js"></script>

`GameObject` 타입은 좀 더 많은 행동을 가진 다른 타입에 의해 `확장`될 수 있다. 예를 들어, 게임의 많은 요소들은 화면으로 표시될 필요가 있다. 이 객체들은 `화면 표시라는 동일한 행동을 제공`하기 때문에 별도의 타입으로 분류돼야 한다. 이들을 `Displayable 타입`으로 분류하는 것이 좋을 것 같다.

<script src="https://gist.github.com/BongHoLee/38a5f56d8b546ef4772464e0867b3499.js"></script>

`Displayable 인터페이스`가 `GameObject를 확장`한다는 사실에 주목하자. 위 코드는 `Displayable 타입을 GameObject 타입의 서브타입으로 정의`한다. 결과적으로 `Displayable` 타입의 모든 인스턴스는 `GameObject` 타입의 인스턴스 집합에도 포함된다. 이처럼 **인터페이스가 다른 인터페이스를 [확장]하도록 만들면 슈퍼타입과 서브타입간의 [타입계층]을 구성할 수 있다.**





---

## 타입











### 참고 및 출처

  - 오브젝트
