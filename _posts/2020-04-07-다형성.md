---
layout: post
title: 합성과 유연한 설계
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

우리는 앞선 챕터에서 `코드 재사용`을 목적으로 `상속`을 사용하면 `컴파일 타임 의존성` 때문에 변경하기 어렵고 유연하지 못한 설계에 이를 확률이 높아진다는 점을 배웠다. 거듭 강조하지만 **_상속의 목적은 코드 재사용이 아니다._** **_상속은 타입 계층을 구조화 하기 위해 사용해야 한다._** 이번 챕터에서 살펴보겠지만 `타입 계층`은 객체지향 프로그래밍의 중요한 특성 중 하나인 `다형성`의 기반을 제공한다.

> 상속을 이용해 자식 클래스를 추가하려 한다면 스스로에게 다음과 같은 질문을 해보길 바란다. 상속을 사용하려는 목적이 단순히 코드 재사용을 위해서인가? 아니면 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서인가?

이번 장에서는 `상속`의 관점에서 `다형성`이 구현되는 기술적인 메커니즘을 살펴보기로 한다. 이번 장을 학습하고 나면 다형성이 `런타임에 메시지를 처리`하기 위해 적합한 메서드를 `동적으로 탐색`하는 과정을 통해 구현되며, `상속`이 이런 메서드를 찾기 위한 일종의 `탐색 경로를 클래스 계층의 형태로 구현`하기 위한 방법이라는 사실을 이해하게 될 것이다.
---

## 다형성

`다형성(Polymorphism)`이라는 단어는 컴퓨터 과학에서 **_하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력_** 으로 정의한다. 간단히 말해서 다형성은 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 잇는 방법이라고 할 수 있다.

다형성의 종류는 다양하다. `오버로딩 다형성`, `강제 다형성`, `매개변수 다형성`, `포함 다형성`과 같이 하나에만 국한되지 않는다. 하지만 객체지향 패러다임에서 말하는 `다형성`은 주로 `포함 다형성`을 의미한다. 이번 챕터에서도 `포함 다형성`에 대해서 학습한다.

`포함 다형성`은 **_메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미한다._**

<script src="https://gist.github.com/BongHoLee/fd31acbc8dc86df0f7f264e9da4ab5f0.js"></script>

위 코드는 `포함 다형성`의 전형적인 예를 잘 보여준다. `Movie` 클래스는 `discountPolicy`에게 `calculateDiscountAmount` 메시지를 전송하지만 실제로 실행되는 메서드는 메시지를 수신한 객체의 타입에 따라 달라진다.

포함 다형성을 구현하는 가장 일반적인 방법은 `상속`을 이용하는 것이다. 두 클래스를 상속 관계로 연결하고 자식 클래스에서 부모 클래스의 메서드를 `오버라이딩`한 후 클라이언트는 부모 클래스만 참조하면 포함 다형성을 구현할 수 있다.

`포함 다형성 -> 서브타입 다형성`이라고 부른다는 사실에서 예상할 수 있겠지만 포함 다형성을 위한 전제 조건은 `자식 클래스가 부모 클래스의 서브타입`이어야 한다는 것이다. 그리고 **_상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다._**

`포함 다형성`을 위해 `상속`을 사용하는 가장 큰 이유는 `상속`이 클래스들을 계층으로 쌓아 올린 후 **_상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문이다._**

> 객체가 메시지를 수신하면 객체지향 시스템은 메시지를 처리할 적절한 메서드를 상속 계층 안에서 탐색한다. 실행할 메서드를 선택하는 기준은 어떤 메시지를 수신했느냐에 따라, 어떤 클래스의 인스턴스인지에 따라, 상속 계층이 어떻게 구성되어있는지에 따라 달라진다.

이번 장의 목표는 `포함 다형성`의 관점에서 `런타임에 상속 계층 안에서 적절한 메서드를 선택하는 방법을 이해`하는 것이다.

---

## 상속의 양면성

**_상속의 목적은 코드 재사용이 아니다._** `상속`은 프로그램을 구성하는 개념들을 기반으로 `다형성`을 가능하게 하는 `타입 계층을 구축`하기 위한 것이다. `타입 계층`에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다. 문제를 피할 수 잇는 유일한 방법은 **_상속이 무엇이고 언제 사용해야 하는지를 이해하는 것 뿐이다._**

이번 장에서는 `상속의 메커니즘`을 이해하기 위해 필요한 몇 가지 개념을 살펴보자.

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조

### 상속을 사용한 강의 평가

**_Lecture 클래스 살펴보기_**
상속의 예를 보기 위해 `Lecture`라는 클래스를 살펴보자.

<script src="https://gist.github.com/BongHoLee/ec997393b08e1f4a899ee214ecb525da.js"></script>

아래는 이수 기준이 70점인 객체지향 프로그래밍 과목의 수강생 5명에 대한 성적 통계를 구하는 코드를 나타낸 것이다.

<script src="https://gist.github.com/BongHoLee/f941831223335f2222ec94a3dd025966.js"></script>

**_상속을 이용해 Lecture 클래스 재사용하기_**
`Lecture` 클래스는 새로운 기능을 구현하는 데 필요한 대부분의 데이터와 메서드를 포함하고 있다. 따라서 `Lecture` 클래스를 상속받으면 새로운 기능을 쉽고 빠르게 추가할 수 있을 것이다. 원하는 기능은 `Lecture`의 출력 결과에 등급별 통계를 추가하는 것이므로 클래스의 이름으로는 `GradeLecture`가 적절할 것 가다. `GradeLecture` 클래스에는 `Grade` 인스턴스들을 리스트로 보관하는 인스턴스 변수 `grades`를 추가하자.

<script src="https://gist.github.com/BongHoLee/d03830bd04e87cba92604bc96cf1204a.js"></script>

`Grade` 클래스는 `등급의 이름(name)`과 각 등급 범위를 정의하는 최소 성적과 최대 성적을 인스턴스 변수로 포함한다. `include` 메서드는 수강생의 성적이 등급이 포함되는지를 검사한다.

<script src="https://gist.github.com/BongHoLee/0b14212bfdff2c0ceaf74a5fc598f04a.js"></script>

이제 `GradeLecture` 클래스에 학생들의 이수 여부와 등급별 통계를 함께 반환하도록 `evaluate` 메서드를 재정의하자.

<script src="https://gist.github.com/BongHoLee/ee2517bf8df863f5d4c792bdf6b07dbb.js"></script>

`GradeLecture`의 `evaluate` 메서드에서는 예약어 `super`를 사용해 `Lecture` 클래스의 `evaluate` 메서드를 먼저 실행한다.

여기서 주목할 부분은 `GradeLecture`와 `Lecture`에 구현된 두 `evaluate` 메서드의 `시그니처가 완전히 동일(Override)`하다는 것이다. **_부모 클래스와 자식 클래스에 동일한 시그니처를 가진 메서드가 존재할 경우 자식 클래스의 메서드 우선순위가 더 높다._**

이처럼 `상속받은 메서드와 동일한 시그니처 메서드를 재정의하여 부모 클래스의 구현을 새로운 구현을 대체`하는 것을 `메서드 오버라이딩`이라고 부른다.

부모 클래스에 없던 새로운 메서드를 자식 클래스에 추가하는 것도 가능하다. 예를 들어, 다음과 같이 등급별 평균 성적을 구하는 `average` 메서드를 추가할 수 있다.

<script src="https://gist.github.com/BongHoLee/d79ddfee395436554a960155478f0783.js"></script>

`evaluate` 메서드와 달리 `GradeLecture`의 `average` 메서드는 부모 클래스인 `Lecture`에 정의된 `average` 메서드와 이름은 같지만 시그니처는 다르다. **_두 메서드의 시그니처가 다르기 때문에 GradeLecture의 average 메서드는 Lecture의 average 메서드를 대체하지 않으며 결과적으로 두 메서드는 사이좋게 공존할 수 있다._**

이처럼 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것을 `메서드 오버로딩`이라고 부른다.

### 데이터 관점의 상속

다음과 같이 `Lecture`의 인스턴스를 생성했다고 가정하자.

<script src="https://gist.github.com/BongHoLee/c393be4743357facda69db12d18fc5fb.js"></script>

`Lecture`의 인스턴스를 생성하면 시스템은 인스턴스 변수 title, pass, scores를 저장할 수 있는 `메모리 공간을 할당`하고 생성자의 매개변수를 이용해 값을 설정한 후 생성된 `인스턴스의 주소를 lecture라는 이름의 변수에 대입`한다. 아래의 그림은 메모리 상에 생성된 객체의 모습을 `개념적`으로 표현한 것이다.

<img src="/assets/img/poly1.PNG" width="100%" height="auto">

이번에는 `GradeLecture`의 인스턴스를 생성했다고 가정하자. `GradeLecture` 클래스의 인스턴스는 직접 정의한 인스턴스 변수 뿐만 아니라 부모 클래스인 `Lecture`가 정의한 인스턴스 변수도 함께 포함된다.

<script src="https://gist.github.com/BongHoLee/badee5f12145e9d86ae6d104c4290005.js"></script>

메모리 상에 생성된 `GradeLecture`는 아래의 그림과 같이 표현할 수 있다. `상속`을 인스턴스 관점에서 바라볼 때는 개념적으로 `자식 클래스`의 인스턴스에서 `부모 클래스`의 인스턴스로 접근 가능한 링크가 존재한다는 것처럼 생각하는것이 유용하다. 인스턴스를 참조하는 `lecture`는 `GradeLecture`의 인스턴스를 가리키기 때문에 특별한 방법을 사용하지 않으면 `Lecture`의 인스턴스에 직접 접근할 수 없다.

<img src="/assets/img/poly2.PNG" width="100%" height="auto">

요약하면 `데이터 관점`에서 상속은 `자식 클래스의 인스턴스에서 부모 클래스로 접근 가능한 링크가 존재`하는 것으로 볼 수 있다.

### 행동 관점의 상속

`행동 관점의 상속`은 **_부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다._** 즉, 부모 클래스의 모든 `퍼블릭 메서드`는 자식 클래스의 `퍼블릭 인터페이스`에 포함된다. 따라서 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다. 앞에서 부모 클래스인 `Lecture` 클래스에서 `evaluate`를 구현하고 있기 때문에 자식 클래스인 `GradeLecture`에서 `evaluate` 메서드를 구현하지 않더라도 `evaluate` 메시지를 처리할 수 있는 이유가 바로 이 때문이다.

> 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 포함되어진다고 표현했지만 실제로 클래스의 코드를 합치거나 복사하는 작업이 수행되는 것은 아니다.

그렇다면 **_어떻게 부모 클래스에서 구현한 메서드를 자식 클래스의 인스턴스에서 수행할 수 있을까?_** 그 이유는 `런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스에서 탐색`하기 때문이다.

> 다시한번 강조한다. 런타임에 메서드를 탐색하다가 자식 클래스에 해당 메서드가 없을 경우 부모 클래스에서 메서드를 탐색한다.

이처럼 행동 관점에서 상속과 다형성의 기본적인 개념을 이해하기 위해서는 `상속 관계로 연결된 클래스 사이의 메서드 탐색 과정을 이해`하는 것이 가장 중요하다.

객체의 경우에는 서로 다른 상태를 저장할 수 있도록 각 인스턴스 별로 독립적인 메모리를 할당받아야 한다. 하지만 **_메서드의 경우에는 동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 클래스는 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다._**

아래 그림은 두 개의 `Lecture` 인스턴스를 생성한 후의 메모리 상태를 `개념적`으로 표현한 것이다. 그림에서 오른쪽에 위치한 사각형들은 `메모리에 로드된 클래스`를 표현한다. **_인스턴스는 두개가 생성됐지만 클래스는 단 하나만 메모리에 로드되었다는 사실에 주목하라._** 각 객체는 자신의 클래스인 `Lecture`의 위치를 가리키는 `class`라는 이름의 포인터를 가지며 이 포인터를 이용해 `자신의 클래스 정보에 접근`할 수 있다.

`Lecture` 클래스가 자신의 부모 클래스인 `Object`의 위치를 가리키는 `parent`라는 이름의 포인터를 가진다는 사실에도 주목하자. 이 포인터를 이용하면 클래스의 상속 계층을 따라 부모 클래스의 정의로 이동하는 것이 가능하다.

<img src="/assets/img/poly3.PNG" width="100%" height="auto">


이제 자식 클래스의 인스턴스를 통해 어떻게 부모 클래스에 정의된 메서드를 실행할 수 있는지 살펴보자. 메시지를 수신한 객체는 `class 포인터`로 연결된 자신의 클래스에서 적절한 메서드가 존재하는지를 찾는다. 만약 메서드가 존재하지 않으면 클래스의 `parent` 포인터를 따라 부모 클래스를 차례로 훑어가며 적절한 메서드가 존재하는지를 검색한다.

`자식 클래스에서 부모 클래스로의 메서드 탐색이 가능`하기 때문에 자식 클래스는 마치 부모 클래스에 구현된 메서드의 복사본을 갖고 있는 것 처럼 보이게 된다. 따라서 **_각 객체에 포함된 class 포인터와 클래스에 포함된 parent 포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스에 이르기 까지 모든 부모 클래스에 접근하는 것이 가능하다._**

마지막으로 `GradeLecture` 클래스의 인스턴스를 생성했을 때의 메모리 구조를 살펴보자. `GradeLecture` 클래스는 `Lecture` 클래스의 자식 클래스이기 때문에 아래 그림에서 볼 수 있는 것 처럼 `GradeLecture`의 인스턴스는 `Lecture`의 인스턴스를 내부에 포함한다. `GradeLecture` 인스턴스의 `class 포인터`를 따라가면 `GradeLecture` 클래스에 이르고 `GradeLecture` 클래스의 `parent 포인터`를 따라가면 부모 클래스인 `Lecture` 클래스에 이르게 된다. `Lecture` 클래스의 `parent 포인터`는 자바에서 모든 클래스의 부모 클래스인 `Object`를 가리키기 때문에 상속 계층은 여기서 끝나게 된다.

<img src="/assets/img/poly4.PNG" width="100%" height="auto">

---

## 업캐스팅과 동적 바인딩

### 같은 메시지, 다른 메서드

`실행 시점에 메서드를 탐색`하는 과정을 자세히 살펴보기 위해 지금까지 작성한 성적 계산 프로그램에 각 교수별로 강의에 대한 성적 통계를 계산하는 기능을 추가해보자. 통게를 계산하는 책임은 `Professor` 클래스가 맡기로 하자. `Professor` 클래스의 `compileStatistics` 메서드는 통계 정보를 생성하기 위해 `Lecture`의 `evaluate` 메서드와 `average` 메서드를 호출한다.

<script src="https://gist.github.com/BongHoLee/d7b14dba89031f8a590f5eb45adc9e3d.js"></script>

다음은 다익스트라 교수가 강의한느 알고리즘 과목의 성적 통계를 계산하는 코드다.

<script src="https://gist.github.com/BongHoLee/8c9e8699ca10ecd0d389e24fd7a24727.js"></script>

위 코드에서 `Professor` 클래스의 인스턴스를 생성할 때 생성자의 두 번째 인자로 `Lecture` 클래스의 인스턴스를 전달했다. 만약 `Lecture` 클래스 대신 자식 클래스인 `GradeLecture`의 인스턴스를 전달하면 어떻게 될까?

<script src="https://gist.github.com/BongHoLee/8ec9a13ba04f8e7a558191532cbfc056.js"></script>

생성자의 인자 타입은 `Lecture`로 선언돼 있지만 `GradeLecture`의 인스턴스를 전달하더라도 아무 문제 없이 실행된다는 사실을 알 수 있다. 위 예제는 **_동일한 객체 참조인 lecture에 대해 동일한 evaluate 메시지를 전송하는 동일한 코드 안에서 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다는 사실을 알 수 있다._**

이처럼 코드 안에 선언된 `참조 타입`과 무관하게 `실제로 메시지를 수신하는 객체의 타입`에 따라 실행되는 메서드가 달라질 수 있는 것은 `업캐스팅`과 `동적 바인딩`이라는 메커니즘이 작용하기 때문이다.

- 부모 클래스(Lecture) 타입으로 선언된 변수에 자식 클래스(GradeLecture)의 인스턴스를 할당하는 것이 가능하다. 이를 `업캐스팅`이라고 부른다.

- 선언된 변수의 타입이 아니라 `메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정`된다. 이것은 객체지향 시스템이 `메시지를 처리할 적절한 메서드를 컴파일 타임이 아닌 런타임에 결정`하기 때문이다. 이를 `동적 바인딩`이라 부른다.

> 동일한 수신자(lecture)에게 동일한 메시지를 전송(lecture.evalute())하는 동일한 코드를 이용해 서로 다른 메서드(Lecture.evaluate() of GradeLecture.evaluate())를 실행할 수 있는 이유는 업캐스팅과 동적 메서드 탐색이라는 기반 메커니즘이 존재하기 때문이다.

`업캐스팅`은 서로 다른 클래스의 인스턴스를 동일한 타입에 할당하는 것을 가능하게 해준다. 따라서 부모 클래스에 대해 작성된 코드를 전혀 수정하지 않고도 자식 클래스에 적용할 수 있다. `동적 메서드 탐색`은 부모 클래스의 타입에 대해 메시지를 전송하더라도 실행 시에는 `실제 클래스(메시지를 수신한 객체의 타입)`를 기반으로 실행될 메서드가 선택되게 해준다. 따라서 코드를 변경하지 않고도 실행되는 메서드를 변경할 수 있다.

### 개방-폐쇄 원칙과 의존성 역전 원칙

`업캐스팅`과 `동적 메서드 탐색`에 대한 설명을 읽다 보면 자연스럽게 머릿속에서 `개방-폐쇄 원칙`이 떠오를 것이다. `업캐스팅`과 `동적 메서드 탐색`은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주며, 이것은 `개방-폐쇄 원칙`의 의도와도 일치한다.

`개방-폐쇄 원칙`은 유연하고 확장 가능한 코드를 만들기 위해 `의존 관계를 구조화`하는 방법을 설명한다. 업캐스팅과 동적 메서드 탐색은 `상속`을 이용해 `개방-폐쇄 원칙`을 따르는 코드를 작성할 때 `하부에서 동작하는 기술적인 내부 메커니즘`을 설명한다. `개방-폐쇄 원칙`이 목적이라면 `업캐스팅`과 `동적 메서드 탐색`은 목적에 이르는 방법이다.

아마 바로 전에 살펴본 `Professor` 예제가 `의존성 역전 원칙`을 따른다고 생각할지도 모르겠다. 하지만 `Professor`는 `추상화가 아닌 구체 클래스(Lecture 클래스)`에 의존하고 있기 때문에 `의존성 역전 원칙`을 따른다고 말하기는 어렵다. 사실 현재의 코드가 `개방-폐쇄 원칙`을 따르는 코드를 만들기 위해 상속을 올바르게 사용했다고 말하기도 어려운데 `개방-폐쇄 원칙`의 중심에는 `추상화`가 위치하고 있기 때문이다.

---

### 업캐스팅

상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지는 것 처럼 보이기 때문에 부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있다. 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용하더라도 메시지를 처리하는 데는 아무런 문제가 없으며, 컴파일러는 명시적인 타입 변환 없이도 자식 클래스가 부모 클래스를 대체할 수 있게 허용한다.






























### 참고 및 출처
  - 오브젝트
