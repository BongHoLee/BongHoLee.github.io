---
layout: post
title: Ch8 요약(의존성 관리)
author: Bong5
categories: [Java, Books/Object]
---

## Ch8 의존성 관리

[본문](https://bongholee.github.io/java/books/object/2020/02/11/%EC%9D%98%EC%A1%B4%EC%84%B1_%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0.html)

---

## 들어가며

6장까지 이르며 `자율적인 객체`, `캡슐화`, `응집도`, `결합도`에 대한 개념과 `책임 주도 설계` 에 따른 `책임 할당 방법`을 학습했다.

또한 `책임 주도 설계`에 더하여 `품질 높은 퍼블릭 인터페이스`를 얻기 위한 기법으로 **협력의 경로를 통제함으로써 결합도를 낮추는 디미터 법칙** , **디미터 법칙을 위한 스타일인 묻지말고 시켜라 원칙** , **협력에 어울리는 오퍼레이션을 얻기 위한 클라이언트의 의도를 드러내는 인터페이스** , **예측 가능한 코드를 위한 명령-쿼리 분리 원칙** 에 대하여 배웠다.

이번 장에서는 객체지향 설계에서 아주 중요한 `의존성 관리`에 대해서 학습한다.

이번 장에서 반드시 기억해야 할 점은 `컨텍스트 독립성`이다. 즉, 특정한 문맥에 종속적인 컨텍스트에 의존하는 것이 아니라 `충분히 추상적인 컨텍스트`에 의존함으로써 **동일한 소스코드로 다양한 컨텍스트의 협력이 가능하다.**

여기서 `다양한 컨텍스트`란 단순히 `한 가지 행동이 다른 객체`정도로 생각하면 오산이다.

말 그대로 `컨텍스트`란 `실행 문맥`을 의미한다. 물론 `추상적인 컨텍스트`라는 의미가 `리스코프 치환 원칙`을 위배한다는 의미는 아니지만, `서로 다른 컨텍스트`가 `서로 다른 협력`을 구성할 수 있다는 것은 상당히 의미가 크다.

이를테면 `DB에 저장`하는 컨텍스트와 `File에 저장`하는 컨텍스트는 `저장`이라는 동일한 행위를 수행하지만 협력 구조는 현저히 다르다. 단순히 `save()` 라는 하나의 메서드 내의 구현만 조금 다른것이 아니라 해당 객체들이 협력하는 대상까지 생각해본다면 짐작이 될 것이다.

그리고 이러한 `추상적인 컨텍스트`에 의존함으로써 `다양한 컨텍스트의 협력이 가능`하게 해주는 것은 바로 `런타임 의존성`과 `컴파일타임 의존성`을 서로 다르게 구성하는 것이다.

자세한 내용은 본문을 확인하자.

---

## 핵심.

- 일반적인 애플리케이션의 기능을 구현하기 위해서는 다른 객체에게 도움을 요청해야 한다. **이런 요청이 객체사이의 협력을 낳는다.**

- 다른 객체와 협력하기 위해서는 해당 객체가 존재한다는 사실을 알고있어야 한다. 또한 객체가 수신할 수 있는 메시지에 대해서도 알고있어야 한다. **이런 지식이 객체 사이의 의존성을 낳는다.**

- 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. **객체지향 설계의 햅ㄱ심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 것이다.**

- `의존성`은 방향성을 가지며 **항상 단방향이다.**

- 두 요소 사이의 `의존성`은 **의존되는 대상(서버)가 변경될 때 의존하는 요소(클라이언트)도 변경될 수 있는 "가능성"을 의미한다.**

- **의존성은 변경에 의한 영향의 전파 가능성(파급 효과가 있을 수 있음)을 의미한다.**

- `의존성`은 여러 형태(인스턴스 변수, 메서드 인자, 구현 및 상속 대상, 아예 별개의 시스템 등)로 나타날 수 있지만 `근본적인 특성은 동일`하다. **의존하는 대상이 변경될 때 함께 변경될 수 있다는 것이다.**

- `변경`과 관련있는 어떤 것이라도 `의존성`이라는 개념을 적용할 수 있다. **의존성의 대상은 객체일 수도, 모듈이나 더 큰 규모의 실행 시스템일 수도 있다. 하지만 의존성의 본질은 변하지 않는다.**

- `런타임 의존성`과 `컴파일타임 의존성`을 구분해야 한다.

- `런타임 의존성`이 다루는 주제는 `객체 사이의 의존성`이고 `컴파일타임 의존성`이 다루는 주제는 `클래스 사이의 의존성`이다.

- **런타임 의존성과 컴파일타임 의존성은 다를 수 있다. 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.**

- 클래스는 자신과 협력할 객체의 `구체적인 클래스`를 알아서는 안된다. **구체적인 클래스를 알면 알수록(더 자세히 알수록) 그 클래스가 사용되는 "특정한 문맥"에 강하게 결합되기 때문이다.**

- **클래스가 특정 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.**

- **클래스가 사용될 특정한 문맥에 대해 "최소한의 가정"만으로 이뤄져 있다면 다른 문맥에서 "재사용"하기 더 수월해지는데 이를 "컨텍스트 독립성"이라 부른다.**

- 설계가 유연해지기 위해서는 가능한 자신이 실행 될 `컨텍스트`에 대한 구체적인 정보를 `최대한 적게`알아야 한다. **컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용 가능하다.**

- **컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.**

- `컴파일타임 의존성`을 실행 컨텍스트에 맞는 적절한 `런타임 의존성`으로 교체하는 것을 `의존성 해결`이라고 부른다.

- `의존성 해결`을 위해서는 일반적으로 `생성자 주입`, `setter 메서드 주입`, `메서드 실행 시 인자로 주입`하는 세 가지 방법을 사용한다.

- `바람직한 의존성`이란 `재사용성`과 관련이 있다. **어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 바람직하지 못한 의존성이다. 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.**

- **특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.**

- 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용 할 수 있는 유일한 방법은 구현을 변경하는 것 뿐이다.

- **다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성이다.**

- **바람직한 의존성이란 컨텍스트에 독립적인 의존성을 의미하며 다양한 환경에서 재사용될 수 있는 가능성을 열어놓는 의존성을 의미한다.**

- **지식이 결합을 낳는다.**

- **결합도는 상대적이다. 추상적인 인터페이스에 의존하는 것과 세부 구현이 드러나는 인터페이스에 의존하는 것, 구체적인 클래스에 의존하는것과 추상화에 의존하는것 모두 상대적으로 결합도를 비교할 수 있다.**

- `결합도`의 정도는 한 요소가 `자신이 의존하고 있는 대상에 대해 알고있는 정보의 양`으로 결정된다.

- 더 많은 정보를 알고 있을수록 두 요소는 `강하게 결합`된다.

- **결합도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야 한다.**

- **결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.**

- `추상화`에 의존하면 결합도를 느슨하게 유지할 수 있다.

- `추상화`란 구체적인 절차나 세부내용을 의도적으로 감추고 `공통적이고 일반적`인 부분만을 드러냄으로써 `복잡도를 극복`하는 방법이다.

- **추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다. 따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.**

- **의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.**

- `의존성`은 `명시적`으로 표현되어야 한다. `의존성`을 구현 내부에 숨겨두지 마라

- **유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.**

- `명시적인 의존성`을 사용해야만 퍼블릭 인터페이스를 통해 `컴파일 타임 의존성`을 적절한 `런타임 의존성`으로 교체할 수 있다.

- `사용과 생성의 책임을 분리`하고 `의존성을 생성자에 명시화`하고 `구체 클래스가 아닌 추상화에 의존`하게 함으로써 `설계를 유연`하게 할 수 있다. 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 `클라이언트`로 옮기는 것이다.

- **어떤 경우든 코드 내부를 직접 수정하는 것은 버그의 발생 가능성을 높이는 것이다.**

- 어떤 객체와 협력하느냐에 따라 객체의 `행동`이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.

- **유연하고 재사용 가능한 설계는 객체가 어떻게(how)하는지를 장황하게 나열하지 않고 객체들의 조합을 통해 무엇(what)을 하는지를 표현하는 클래스들로 구성된다.**

- **유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.**

---

##




### 참고 및 출처

  - 오브젝트
