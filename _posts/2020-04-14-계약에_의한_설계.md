---
layout: post
title: 계약에 의한 설계
author: Bong5
categories: [Java, Books/Object]
---


## 들어가며

객체지향을 설계 할 때에 있어 `다형성`을 구현하는 메커니즘으로 주로 `상속`을 사용한다. 하지만 이러한 `상속`은 `코드 재사용`이 아닌 `타입 계층`을 구축할 때에 비로소 유연하고 확장 가능한 설계로 이어진다. 이번 장에서 살펴볼 `계약에 의한 설계`는 클래스 간의 `상속` 관계에서 `리스코프 치환 원칙`을 준수하기 위해 지켜야 할 조건들이 어떤 것이 있는지 알아본다.

---

## 계약에 의한 설계

`인터페이스` 만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다. 우리에게 필요한 것은 `명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단`이다. 이 시점이 되면 **_계약에 의한 설계(Design By Contract, DBC)_** 가 주는 혜택으로 눈을 돌릴 때가 된 것이다.

`계약에 의한 설계`를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화 할 수 있다. **_클라이언트 개발자는 오퍼레이션의 구현을 살펴보지 않더라도 객체의 사용법을 쉽게 이해할 수 있다._** `계약`은 실행 가능하기 때문에 구현에 동기화돼 있는지 여부를 `런타임`에 검증할 수 있다. 따라서 주석과 다르게 시간의 흐름에 뒤쳐질 걱정을 할 필요가 없다.

> "계약에 의한 설계"는 클래스의 부수효과를 명시적으로 문서화하고 명확하게 커뮤니케이셔할 수 있을 뿐만 아니라 실행 가능한 검증 도구로써 사용할 수 있다.

이번 장에 소개할 예제 일부는 C# 언어로 작성돼 있으며 `계약에 의한 설계 라이브러리`로 Code Contract를 사용한다.

이번 장에서 중요한 것은 코드가 아니라 `개념`이다. `코드를 구현하는 방법보다는 계약에 의한 설계를 사용하는 이유와 장점`을 이해하는 것이 이번 장의 목표다.

---

## 협력과 계약

### 부수 효과를 명시적으로

객체지향의 핵심은 `협력` 안에서 객체들이 수행하는 `행동`이다. 안타깝게도 프로그래밍 언어로 작성된 `인터페이스`는 객체가 수신할 수 있는 `메시지`는 정의할 수 있지만 객체 사이의 `의사소통 방식`은 명확하게 정의할 수 없다. `메시지의 이름`과 `파라미터 목록`은 `시그니처`를 통해 전달할 수 있지만 협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 때문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게된다.

여기서는 6장 `명령-쿼리 분리 원칙`을 설명하기 위해 소개했던 일정 관리 프로그램의 C# 버전을 이용해 계약에 의한 설계 개념을 설명하기로 한다. 명령과 쿼리를 분리했기 때문에 `Event` 클래스의 클라이언트는 먼저 `IsSatisfed` 메서드를 호출해서 `RecurringSchedule`의 조건을 만족시키는지 여부를 확인한 후에 `Reschedule` 메서드를 호출해야 한다. 인터페이스만으로 메서드의 순서와 관련된 제약을 설명하기 쉽지 않지만 계약에 의한 설계 라이브러리인 Code Contract를 사용하면 `IsSatisfed` 메서드의 실행 결과가 `true`일 때만 `Reschedule` 메서드를 호출할 수 있다는 사실을 명확하게 표현할 수 있다.

<script src="https://gist.github.com/BongHoLee/b45479e0e506e5044f33e4c499ea2108.js"></script>

이렇게 작성된 `계약`은 문서화가 가능하다. 또한 문서화로 끝나는 것이 아니라 `제약 조건의 만족 여부`를 실행 중에 체크할 수 도 있다. 따라서 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 사용하고 자동으로 문서화 할 수 있을 뿐 아니라 실행을 통해 검증할 수 있다.

### 계약

현재 살고 있는 집을 리모델링 하고 싶다고 가정해보자. 우리게에는 리모델링 할 수 잇는 전문적인 지식이 부족하기 때문에 적절한 인테리어 전문가에게 작업을 위탁하고 계약을 체결할 것이다.

계약의 세부적인 내용은 상황에 따라 다르겠지만 일반적으로 다음과 같은 특성을 가진다.

- 각 계약 당사자는 계약으로부터 `이익(benefit)`을 기대하고 이익을 얻기 위해 `의무(obligation)`을 이행한다.
- 각 계약 당사자의 이익과 의무는 계약서에 `문서화`된다.

여기서 눈여겨볼 부분은 `한쪽의 의무가 반대쪽의 권리`가 된다는 것이다. 리모델링을 위탁하는 클라이언트 입장에서 `의무`는 인테리어 전문가에게 대금을 지급하는 것이다. 그로 인해 얻게되는 `이익`은 원하는 품질로 리모델링 된 집을 얻는 것이다. 리모델링 작업을 수행하는 인테리어 전문가 입장에서 `의무`는 고객이 원하는 품질로 집을 리모델링 하는 것이다. 그로 인해 얻는 `이익`은 대금을 지급받는 것이다.

두 계약 당사자 중 어느 한쪽이라도 계약서에 명시된 내용을 위반한다면 계약은 정상적으로 완료되지 않을것이다. 인테리어 전문가가 자신의 `의무`인 리모델링 작업을 완료하지 못했다면 `이익`으로 명시된 대금을 지급받지 못할 것이다. 인테리어 전문가가 리모델링 작업을 완료했는데도 고객이 자신의 `의무`인 대금을 지급하지 못한다면 고객의 `이익`인 리모델링된 집에서의 생활은 물거품이 될 것이다.

비록 우리가 계약상 `클라이언트`라고 하더라도 인터레이 전문가가 **_계약을 이행하는 구체적인 방식에 대해서는 간섭하지 않는다는 사실을 기억하라._** 리모델링 공사를 진행하는 `구체적인 방법`은 인테리어 전문가가 자유롭게 결정할 수 있다. 작업 방식과 상관 없이 리모델링된 결과가 만족스럽다면 클라이언트는 인테리어 전문가가 계약을 정상적으로 이행한 것으로 간주할 것이다.

이처럼 **_계약은 협력을 명확하게 정의하고 커뮤니케이션 할 수 있는 범용적인 아이디어다._** 그리고 사람들이 협력을 위해 사용하는 계약이라는 아이디어를 객체들이 협력하는 방식에도 적용할 수 있지 않을까 의문을 품음으로써 `계약의 의한 설계`가 탄생되었다.

---

## 계약에 의한 설계

`계약`은 `협력`에 참여하는 두 객체 사이이의 `의무와 이익`을 문서화 한 것이다.

- `협력`에 참여하는 각 객체는 `계약`으로부터 `이익`을 기대하고 이익을 얻기위해 `의무`를 이행한다.
- `협력`에 참여하는 각 객체의 `이익`과 `의무`는 객체의 `인터페이스 상에 문서화`된다.

`계약에 의한 설계` 개념은 `인터페이스에 대해 프로그래밍 하라`는 원칙을 확장한 것이다. 계약에 의한 설계를 이용하면 `오퍼레이션의 시그니처`를 구성하는 다양한 요소들을 이용해 협력에 참여하는 객체들이 지켜야 하는 제약조건을 명시할 수 있다. 이 제약 조건을 인터페이스의 일부로 만듦으로써 코드를 분석하지 않고도 인터페이스의 사용법을 이해할 수 있다.

아래 코드는 자바 언어로 작성된 `reverse` 메서드의 구성 요소를 표현한 것으로, 협력을 위한 다양한 정보를 제공한다. 이 메서드는 `public` 가시성을 가지기 때문에 외부에서 호출 가능하다. 이 메서드를 사용하기 위해서는 `Customer` 타입과 `int` 타입의 인자를 전달해야 한다. 메서드 실행이 성공하면 반환 타입으로 `Reservation` 인스턴스를 반환한다는 사실도 알 수 있다.

<script src="https://gist.github.com/BongHoLee/38ffdfca37f50cc7270769760219cf6b.js"></script>

우리는 `메서드의 이름`과 `매개변수의 이름`을 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려고 하는지를 충분히 설명할 수 있다. 6장에서 설명한 `클라이언트의 관점에서 의도를 드러내는 인터페이스`를 만들면 오퍼레이션의 시그니처만으로도 어느 정도 까지는 클라이언트와 서버가 협력을 위해 수행해야 하는 제약조건을 명시할 수 있다.

계약은 여기서 한 걸음 더 나아간다. `reverse` 메서드를 호출할 때 클라이언트 개발자는 `customer`의 값으로 `null`을 전달할 수 있고 `audienceCount` 값으로 음수를 포함한 어떤 정수도 전달할 수 있다고 가정할지 모른다. 하지만 이 메서드는 고객의 예약 정보를 생성하는 것이기 때문에 한 명이상의 예약자에 대해 예약 정보를 생성해야 한다. 따라서 `customer`는 `null`이 되면 안되고 `audienceCount`의 값은 1보다 크거나 최소한 같아야 한다. 클라이언트가 이 조건을 만족하는 인자를 전달했다면 `reverse` 메서드가 반환하는 `Reservation` 인스턴스는 `null`이 아니어야 한다.

**_협력하는 클라이언트는 정상적인 "상태"를 가진 객체와 협력해야 한다._** 아래와 같이 정삭적인 `Screening`은 `movie`가 `null`이 아니어야 하고 `squence`는 1보다 크거나 같아야 하며, `whenScreened`는 현재 시간 이후의 값을 가지고 있어야 한다. 이 조건을 만족하지 않는 `Screening`은 예매할 수 없다. 따라서 어떤 `Screening` 인스턴스가 이 조건을 만족하지 않는다면 `reverse` 메서드를 호출할 수 없어야 한다.

<script src="https://gist.github.com/BongHoLee/2847793f155880c995ed4ad8d0f6563f.js"></script>

`서버`는 자신이 처리할 수 있는 범위의 값들을 `클라이언트가 전달`할 것이라고 기대한다. `클라이언트`는 자신이 원하는 값을 `서버가 반환`할 것이라고 기대한다. **_클라이언트는 메시지 전송 전과 후의 서버의 상태가 정상일것이라고 기대한다._** 이 세 가지 기대가 바로 계약에 의한 설계를 구성하는 세 가지 요소에 대응된다. 이 요소들을 순서대로 `사전조건`, `사후조건`, `불변식`이라고 부른다.

- `사전조건(precondition)` : 메서드가 호출되기 위해 만족돼야 하는 조건. 이것은 `메서드의 요구사항`을 명시한다. `사전조건`이 만족되지 않을 경우 메서드가 실행되어서는 안된다. 사전조건을 만족시키는 것은 `메서드를 실행하는 클라이언트의 의무`이다.

- `사후조건(postcondition)`: 메서드가 실행된 후에 `클라이언트에게 보장해야 하는 조건`. 클라이언트가 사전 조건을 만족시켰다면 메서드는 `사후조건` 에 명시된 조건을 만족시켜야 한다. 만약 클라이언트가 `사전조건`을 만족시켰는데도 `사후조건`을 만족시키지 못한 경우에는 **_클라이언트에게 예외를 던져야 한다._** `사후조건을 만족시키는 것은 서버의 의무`이다.

- `불변식(invariant)` : 항상 `참`이라고 보장되는 `서버의 조건`. 메서드가 실행되는 도중에는 `불변식`을 만족시키지 못할 수도 있지만 **_메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야 한다._**

`사전조건`, `사후조건`, `불변식`을 기술할 때는 `실행 절차를 기술할 필요 없이 상태 변경만을 명시`하기 때문에 코드를 이해하고 분석하기 쉬워진다. `클라이언트 개발자`는 사전 조건에 명시된 조건을 만족시키지 않으면 메서드가 실행되지 않을 것이라는 사실을 잘 알고있따. `불변식`을 사용하면 클래스의 의미를 쉽게 설명할 수 있고 클라이언트 개발자가 객체를 더욱 쉽게 예측할 수 있다. `사후조건`을 믿는다면 객체가 내부적으로 어떤 방식으로 동작하는지 걱정할 필요가 없다. **_'사전조건', '사후조건', '불변식'에는 클라이언트 개발자가 알아야 하는 모든 것이 포함돼 있을 것이다._**

여기서는 `Screening`에 대한 제약 조건을 `사전조건`, `사후조건`, `불변식`으로 구현할 것이다. 자바의 경우는 계약에 의한 설계 개념을 지원하지 않기 때문에 여기서는 C#으로 작성된 예제를 살펴본다.


### 사전 조건

`사전조건`이란 `메서드가 정상적으로 실행되기 위해 만족해야 하는 조건`이다. 사전조건을 만족시키는 것은 `메서드를 실행하는 클라이언트의 의무`이다. 따라서 사전조건을 만족시키지 못해서 메서드가 실행되지 않을 경우 `클라이언트에 버그`가 있다는 것을 의미한다. **_사전조건이 만족되지 않을 경우 서버는 메서드를 실행할 의무가 없다._**

**_일반적으로 사전조건은 메서드에 전달된 인자의 '정합성'을 체크하기 위해 사용된다._** 예를 들어 `reverse` 메서드의 경우 인자로 전달된 `customer`가 `null`이 아니어야 하고 `audienceCount`의 값은 1보다 크거나 같아야 한다. 이 조건을 만족시키지 못할 경우 `reverse` 메서드는 실행되지 말아야 한다. 따라서 이 조건을 `메서드의 사전조건`으로 정의함으로써 메서드가 잘못된 값을 기반으로 실행되는 것을 방지할 수 있다.

아래는 메서드의 `사전조건`을 정의하기 위해 사용되는 `Contract`의 `Reuqires` 메서드다.

<script src="https://gist.github.com/BongHoLee/97b67916d51f0acbd8126419a6902139.js"></script>

`사전 조건`을 만족시킬 책임은 `Reverse` 메서드를 호출하는 `클라이언트`에게 있다는 사실을 기억하자. `클라이언트`가 `사전조건`을 만족시키지 못할 경우 `Reverse` 메서드는 최대한 빨리 실패해서 클라이언트에게 버그가 있다는 사실을 알린다.

이 에제는 `계약에 의한 설계`의 장점이 무엇인지를 잘 보여준다. 계약에 의한 설계를 사용하면 계약만을 위해 준비된 `전용 표기법`을 사용해 계약을 명확하게 표현할 수 있다. 또한 계약을 일반 로직과 분리해서 서술함으로써 계약을 좀 더 두드러지게 강조할 수 있다. 또한 `계약이 메서드의 일부로 실행`되도록 함으로써 `계약을 강제`할 수 있다.

### 사후 조건

`사후조건`은 메서드의 `실행 결과`가 올바른지 검사하고 실행 후에 객체가 유효한 상태로 남아있는지를 검증한다. 간단히 말해서 `사후 조건`을 통해 메서드를 호출한 후에 어떤 일이 일어났는지를 설명할 수 있는 것이다. `클라이언트`가 `사전조건`을 만족시켰는데도 `서버`가 `사후조건`을 만족시키지 못한다면 `서버에 버그`가 있음을 의미한다.

일반적으로 `사후조건`은 다음과 같은 세 가지 용도로 사용된다.

- 인스턴스 변수의 상태가 올바른지를 서술하기 위해

- 메서드에 전달된 파라미터의 값이 올바르게 변경되었는지 서술하기 위해

- 반환 값이 올바른지 서술하기 위해

다음과 같은 두 가지 이유로 인해 `사전조건`보다 `사후조건`을 정의하는 것이 더 어려울 수 있다.

- 한 메서드 안에서 `return` 문이 여러 번 나올 경우
  - 모든 `return` 문 마다 결괏값이 올바른지 검증하는 코드를 추가해야 한다. 다행히도 `계약에 의한 설계`를 지원하는 대부분의 라이브러리는 결괏값에 대한 사후 조건을 한 번만 기술할 수 있게 해준다.

- 실행 전과 실행 후의 값을 비교해야 하는 경우
  - 실행 전의 값이 메서드 실행으로 인해 다른 값으로 변경됐을 수 있기 때문에 두 값을 비교하기 어려울 수 있다. 다행히 계약에 의한 설계를 지원하는 대부분의 라이브러리는 실행 전의 값에 접근할 수 있는 간단한 방법을 제공한다.

`Code Contracts`에서 `사후조건`을 정의하기 위해서는 `Contract.Ensures` 메서드를 제공한다. `Reserve` 메서드의 `사후조건`은 반환값이 `Reservation` 인스턴스가 `null`이어서는 안된다는 것이다. 따라서 다음과 같이 `사후조건`을 추가할 수 있다.

<script src="https://gist.github.com/BongHoLee/a3840d59baebd6e393577f4e6709ede2.js"></script>

`Ensures` 메서드 안에서 사용된 `Contract.Result<T>` 메서드가 바로 `Reserve` 메서드의 실행 결과에 접근할 수 있게 해주는 메서드다. 이 메서드는 `제네릭 타입`으로 메서드의 반환 타입에 대한 정보를 명시할 것을 요구한다.

`Contract.Result<T>` 메서드는 하나 이상의 종료 지점을 가지는 메서드에 대한 `사후조건`을 정의할 때 유용하게 사용할 수 있다. 다음 메서드를 살펴보자.

<script src="https://gist.github.com/BongHoLee/fdc2d83bf8ba5f43d5c97cccf8bd3867.js"></script>

`Buy` 메서드는 초대장이 있을 경우에는 0원을, 초대장이 없을 경우에는 티켓의 요금을 반환한다. 이 메서드에는 두 개의 `return` 문이 존재한다는 점을 주목하자. 만약 `Code Contracts`를 사용하지 않는다면 `사후조건`을 두 개의 `return` 문 모두에 중복해서 작성해야 했을 것이다. `Contract.Result<T>` 메서드는 이런 경우에 수고를 덜어준다. `Contract.Result<T>`는 메서드 실행이 끝난 후에 실제로 반환되는 값을 전달하기 때문에 몇 번의 `return`문이 나오더라도 다음과 같이 한 번만 기술하면 된다.

<script src="https://gist.github.com/BongHoLee/edc9944046c8828f62cc71abb355aae2.js"></script>

`Contract.OldValue<T>`를 이용하면 `메서드 실행 전의 상태`에도 접근할 수 있다. 이 메서드를 이용하면 실행 중에 값이 변경되더라도 `사후조건`에서 변경 이전의 값을 이용할 수 있게 해준다. 아래 코드에서 파라미터로 전달된 `text`의 값이 메서드 실행 중에 변경되기 때문에 `text`의 값을 이용하는 `사후조건`이 정상적으로 체크되지 않는다.

<script src="https://gist.github.com/BongHoLee/62318f0ed2d377a170e48e8043dae176.js"></script>

이 경우 `Contract.OldValue<T>`를 이용하면 메서드를 실행할 때의 `text`의 값에 접근할 수 있다. 따라서 위 코드를 다음과 같이 변경하면 문제 없이 `사후조건`을 검증할 수 있다.

<script src="https://gist.github.com/BongHoLee/e7f74eaf3856862cb5f802e02e95fc8f.js"></script>











### 참고 및 출처
  - 오브젝트
