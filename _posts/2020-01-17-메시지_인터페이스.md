---
layout: post
title: 메시지와 인터페이스
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

---

## 메시지와 인터페이스

객체지향 세계에서 가장 중요한 것은 __자율적인 객체가 수행하는 행동__ 즉, __책임__ 이다. 여기서 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것이다.

클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환하는 것은 객체지향 설계자로 성장하기 위한 첫 걸음이다.

>애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하자.

객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다. **_유연하고 재사용 가능한 퍼블릭 인터페이스_** 를 만드는데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 하는 방법들을 살펴보자.

---

## 협력과 메시지

#### 클라이언트-서버 모델

협력은 어떤 객체가 다른 객체에게 무언가를 __요청__ 할 때 시작된다. **_메시지는 객체 사이의 협력을 가능하게 하는 유일한 매개체이다._** 즉, 어떤 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 바로 메시지를 전송하는 것 뿐이다.

여기서 메시지를 전송하는 객체가 __클라이언트__ 가 되고 메시지를 수신함으로써 책임을 수행하고 응답하는 객체가 __서버__ 가 된다. 협력은 클라이언트가 서버의 서비스를 요청하는 __단방향 상호작용__ 이다.

앞서 살펴본 극장, 영화 예매와 같이 객체는 협력에 참여하는 동안 __클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.__ 객체지향 설계를 설명하면서 **_메시지, 인터페이스, 오퍼레이션, 메서드_** 와 같이 언뜻 비슷해 보이지만 서로 다른 용어들이 머릿속에 확립되지 않으면 커뮤니케이션에서나 의도를 파악하는데 헷갈릴 수 있으니 먼저 용어 부터 정리하고 넘어가겠다.

---

#### 메시지와 메시지 전송

__메시지(message)__ 는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

**_메시지 전송_** : 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송이라 한다. ex) __condition.isSatisfiedBy(screening)__

**_메시지_** : __오퍼레이션 명과 인자(argument)__ 로 구성된다. ex) __isSatisfiedBy(screening)__

---

#### 메시지와 메서드

계속해서 __메시지와 메서드를 분리하여 생각__ 해야 함을 강조했다. 위의 메시지의 형태에서 확인할 수 있듯이 메시지는 __구현__ 을 포함하지 않는다. 클라이언트가 서버에게 요청하는 __오퍼레이션 명과 인자__ 만을 갖고 있을 뿐이다. 그리고 메서드는 서버가 메시지를 수신했을 때 실행하는 코드 블럭, 즉 실제 구현이다. 따라서 평소에 아무 거리낌 없이 사용하는 __메서드 호출__ 이란 표현보다는 __오퍼레이션 호출__ 또는 __메시지 전송__ 이라는 표현이 맞는 표현이다.

메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 __메시지 수신자(서버)의 실제 타입이 무엇인가__ 에 달려있다. 이를테면 **_condition.isSatisfiedBy(screening)_** 와 같은 메시지를 전송했을 때 메시지 수신자인 condition은 **_DiscountCondition_** 이라는 인터페이스 타입으로 정의되어 있지만 실제로 실행되는 코드는 인터페이스를 구현한 클래스의 종류(**_PeriodCondition || SequenceCondition_**)에 따라 달라진다.

>메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라 한다.

중요한 것은 **_코드 상(컴파일 시점)에서 동일한 이름의 변수(condition)에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메시지가 달라질 수 있다는 것_**. 다시말해 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 __실행 시점에 연결(런타임에 바인딩)__ 해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

>메시지와 메서드의 구분은 메시지 전송자(클라이언트)와 메시지 수신자(서버) 사이의 결합도를 느슨하게 한다.

어떻게 메시지와 메서드의 구분이 클라이언트와 서버간 느슨한 결합도를 가능하게 할까? 클라이언트는 서버가 어떤 클래스의 타입인지 알 필요 없이 단지 메시지를 전송함으로써 서비스를 요청하기만 하면 된다. 즉, 서버의 내부 구현이나 구체적인 타입(클래스의 타입)을 알 수 없다. 마찬가지로 서버 역시 메시지를 전송한 외부 객체가 어떤 객체인지 알 필요가 없다. 단순히 __메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.__ 이처럼 클라이언트와 서버는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지로만 연결된다.

>메시지와 메서드를 구분하고 실행 시점(런타임)에 메시지와 메서드가 바인딩되는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

---

#### 퍼블릭 인터페이스와 오퍼레이션

객체는 안과 밖을 구분하는 뚜렷한 경계를 갖는 __캡슐화 단위__ 이다. 외부에서 볼 때 객체의 안쪽은 캡슐로 차단된 미지의 영역이다. **_외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용_** 할 수 있다. 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 __퍼블릭 인터페이스__ 라고 부른다.

프로그래밍 언어의 관점에서 **_퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라 부른다._** 오퍼레이션은 수행 가능한 어떤 행동에 대한 __추상화__ 이다. 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다. 앞에서 예로 든 __DiscountCondition__ 인터페이스에 정의된 __isSatisfiedBy__ 가 오퍼레이션에 해당한다.

그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다. __SequenceCondition, PeriodCondition에 정의된 isSatisfiedBy는 실제 구현을 포함하기 때문에 메서드__ 라고 부른다. 즉, __SequenceCondition, PeriodCondition의 두 메서드는 DiscountCondition 인터페이스에 정의된 isSatisfiedBy 오퍼레이션의 여러 가능한 구현중 하나이다.__

>인터페이스 타입의 각 요소는 오퍼레이션이다. 즉, 오퍼레이션은 구현이 아니라 추상화다. 반면 메서드는 오퍼레이션을 구현한 것이다.

프로그래밍 언어의 관점에서 객체가 다른 객체에게 메시지를 전송했을때의 흐름을 살펴보면, **_런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아서 실행_**

즉, 순서를 나열해본다면
**_1. 클라이언트가 서버에 메시지를 전송_**

**_2. 런타임 시스템은 클라이언트의 메시지 전송을 오퍼레이션 호출로 해석_**

**_3. 런타임 시스템은 오퍼레이션 호출에 따라 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행_**

---

#### 시그니처

오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 __시그니처__ 라고 부른다.

**_오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것._**

**_메서드는 이 시그니처에 구현을 더한 것_**

하나의 오퍼레이션에 대해 하나의 메서드만 존재한다면 오퍼레이션과 메서드를 굳이 구분할 필요가 없다. 하지만 __다형성의 축복을 받기 위해서는 하나의 오퍼레이션에 다양한 메서드를 구현해야 한다.__

>오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것

---

#### 용어 정리

**_메시지_** : 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘. 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 __메시지 전송__ 이라고 부른다.

**_오퍼레이션_** : 객체가 다른 객체에게 제공하는 __추상적인 서비스__ 이다. 메시지가 전송자와 수신자 사이의 협력 관계를 강조하는 데 비해 오퍼레이션은 메시지를 수신하는 객체의 인터페이스를 강조한다. 다시 말해서 메시지 전송자는 고려하지 않은 채 메시지 수신자의 관점만을 다룬다. __메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것을 의미한다.__

**_메서드_** : 메시지에 응답하기 위해 실행되는 코드 블록을 메서드라고 부른다. __메서드는 오퍼레이션의 구현이다.__ 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다. __오퍼레이션과 메서드의 구분은 다형성의 개념과 연결된다.__

**_퍼블릭 인터페이스_** : 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음. __클래스의 퍼블릭 메서드 집합이나 메시지의 집합을 가리키는데 사용된다.__ 객체를 설계할 때 가장 중요한 것은 훌륭한 퍼블릭 인터페이스를 설계하는 것이다.

**_시그니처_** : 시그니처는 오퍼레이션이나 메서드의 명세를 나타낸 것으로, 이름과 인자의 목록을 포함한다.

---

## 인터페이스의 설게와 품질

좋은 인터페이스는 **_최소한의 인터페이스와 추상적인 인터페이스_** 라는 조건을 만족해야 한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. __추상적인 인터페이스는 어떻게(How) 수행하는지가 아니라 무엇(What)을 하는지를 표현__ 한다.

최소한의 인터페이스, 추상적인 인터페이스를 만족하기 위해서는 __책임 주도 설계__ 방법을 따르는 것이 좋다. 책임 주도 설계 방법은 __메시지를 먼저 선택__ 함으로써 협력과 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다. 또한 __객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택__ 하게 함으로써 __클라이언트의 의도를 메시지에 표현__ 할 수 있게 한다. 따라서 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.

좋은 인터페이스를 얻기 위한 방법이 몇 가지 있는데 대표적으로 다음과 같다.

**_디미터 법칙_**

**_묻지 말고 시켜라_**

**_의도를 드러내는 인터페이스_**

**_명령-쿼리 분리_**

먼저 __디미터 법칙__ 은 협력하는 객체의 __내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결__ 하기 위해 제안된 원칙이다.

>디미터 법칙은 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한한다.

__오직 하나의 도트만 사용하라__ 라는 말로 요약되기도 한다. 디미터 법칙을 따르기 위해서는 클래스가 __특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 제한__ 해야 한다.

1. this 객체
2. 메서드의 매개변수로 전달된 객체
3. this의 속성(멤버 객체)
4. this의 속성인 컬렉션의 요소
5. 메서드 내에서 생성된 지역 객체

아래와 같은 예시 코드를 살펴보자.
<script src="https://gist.github.com/BongHoLee/c3ecf8a149b918f4c014f07d1b7f31e3.js"></script>

이 코드의 가장 큰 단점은 **_ReservationAgency_** 와 인자로 전달된 **_Screening_** 사이의 결합도가 너무 높기 때문에 **_Screening_** 내부 구현을 변경할 때 마다 **_ReservationAgency_** 역시 함께 변경된다는 것이다. 문제의 원인은 주석에도 써놓았지만 **_ReservationAgency_** 가 **_Screening_** 뿐만 아니라 **_Movie, DiscountCondition_** 에도 직접 접근하기 때문이다.

이렇게 협력하는 객체에 직접 접근하는 절차지향적 코드는 캡슐화가 깨지고 결합도가 높아지며 응집도는 낮아지게 되는 현상을 초래한다. 이제 __디미터 법칙__ 을 적용하여 코드를 수정해보자.
<script src="https://gist.github.com/BongHoLee/d5e3e8810f43e6d1a496c8a9f96b243e.js"></script>

수정된 코드에서 **_ReservationAgency_** 는 메서드의 인자로 전달된 **_Screening_** 인스턴스에게만 메시지를 전송한다. **_ReservationAgency_** 는 **_Screening_** 내부에 대한 어떤 정보도 알지 못한다. **_ReservationAgency_가 Screening의 내부 구조에 결합되어있지 않기 때문에 Screening의 내부 구현을 변경할 때 ReservationAgency를 함께 변경할 필요가 없다._**

디미터 법칙을 따르면 __부끄럼타는 코드__ 를 작성할 수 있다.

>부끄럼타는 코드(shy code)란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며 다른 객체의 구현에 의존하지 않는 코드

즉 디미터 법칙을 따르는 코드는 메시지 수신자(서버)의 내부 구조가 전송자(클라이언트)에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.

>디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 디미터 법칙이 가치 있는 이유는 클래스를 캡슐화하기 위해 따라야하는 구체적인 지침을 제공하기 때문이다. 캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.

아래와 같은 코드는 디미터 법칙을 위반하는 코드의 전형적인 모습을 보여준다.

**_screening.getMovie().getDiscountConditions();_**

메시지 전송자가 수신자의 내부 구조에대해 물어보고(getMovie()) 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다. 이와 같은 코드를 __기차 충돌__ 이라고 부르는데 이와 같은 기차 충돌은 __클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태__ 로써 메시지 전송자(클라이언트)는 메시지 수신자(서버)의 내부 정보를 자세하게 알게된다. **_따라서 메시지 수신자의 캡슐화는 무너지고 메시지 전송자가 메시지 수신자의 내부 구현에 강하게 결합된다._**

디미터 법칙을 따르도록 코드를 개선하면 메시지 전송자(클라이언트)는 더 이상 메시지 수신자(서버)의 내부 구조에 관해 묻지 않게 된다. 단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청한다.
**_screening.calculate(audienceCount);_**

>디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재라는 사실을 강조한다. 정보를 처리하기위한 책임 할당을 정보를 알고있는 객체에게 할당하기 때문에 응집도가 높은 객체가 만들어진다.

디미터 법칙에 대해 살펴보았다. 꼭 기억해야 할 부분만 다시 짚고 넘어가자면

1. 디미터 법칙 좋은 인터페이스를 얻기 위한 방법이다.
2. 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것으로, 클래스의 캡슐화를 지키기 위한 구체적인 지침을 제시한다.
3. 그 구체적인 지침이란 바로 도트연산자(.)을 하나만 사용하도록 제한하는 것이다.
4. 도트연산자(.)를 하나만 사용함으로써 메시지 수신자(서버)의 내부 구조와 결합되지 않게 한다.
5. 서버의 내부 구조와 결합되지 않으므로 서버는 캡슐화를 유지할 수 있다.
6. 또한 캡슐화를 유지함으로써 서버 객체는 수신한 메시지를 스스로 처리하는 응집도 높은 객체가 된다.

---

#### 묻지말고 시켜라

**_묻지말고 시켜라_** 는 디미터 법칙을 지키는 오퍼레이션 작성을 장려한다. 메시지 전송자(클라이언트)는 메시지 수신자(서버)의 상태를 기반으로 결정을 내린 후 서버의 상태를 바꿔서는 안된다. 객체의 외부에서 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.

>묻지말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.

**_묻지말고 시켜라 원칙을 따르도록 메시지를 결정 _** 하다 보면 자연스럽게 정보전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 갖게 된다.

묻지말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.













### 참고 및 출처
  - 오브젝트
