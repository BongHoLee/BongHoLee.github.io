---
layout: post
title: 캡슐화, 응집도, 결합도
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

---

#### 데이터 중심 관점의 폐해

앞선 챕터에서 __역할, 책임, 협력__ 의 관점에서 객체지향 설계를 하는것의 중요성을 살펴보았다.

지금까지 우리는 __객체는 자율적으로 판단하고 행동하며 스스로를 책임지는 존재__ 라고 배웠다. 즉, 자율적으로 __행동__ 하는 객체에 대해 공부했다.

만일 객체를 단순히 데이터의 집합으로 본다면 어떻게 될까?

가장 먼저 __캡슐화__ 가 저해된다. 왜일까? 그 이유를 살펴보자.

객체를 데이터 중심의 관점으로 바라보게 된다면 __내부 구현이 퍼블릭 인터페이스에 노출__ 될 확률이 높아진다. 좀 더 구체적인 예시를 든다면 객체가 가진 __데이터__ 에 대한 구체적인 명칭을 활용하게끔 퍼블릭 인터페이스를 설계할 가능성이 높아진다.

__customer.getBag().setMoney()__ 와 같은 예시를 들 수 있겠다. __customer__ 객체의 __Bag__ 이라는 데이터의 __Money__ 라는 데이터를 활용하려는 목적이 너무 상세한 수준으로 인터페이스에 들어나게 되면서 캡슐화가 저해된다.

또한 __데이터는 구현에 속한다.__ 그리고 __구현은 불안정 하기 때문에 변하기가 쉽다.__
만일 데이터를 객체 분할의 중심축으로 삼게 된다면 __구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되고 캡슐화의 원칙이 무너지게 된다.__ 즉, 상태 변경으로 인터페이스의 변경이 초래될 것이고 인터페이스에 의존하는 다른 객체들에게 변경의 여파가 미치는 상황이 오게 된다.


이 외에도 여러가지 이유가 있지만 중요한 것은 __객체의 책임에 초점__ 을 맞춰야 한다는 것이다. 객체와 객체의 상호작용인 __책임__ 에 초점을 맞추게 된다면 자연스럽게 응집도는 높고 결합도는 낮은 설계가 탄생할 것이다.

왜그럴까?

객체의 책임, 즉 행동에 초점을 맞춤으로써 행동을 수행하기 위해 알아야 하는 데이터가 파생되고 결국 자신의 데이터를 스스로 책임지는 응집도 높은 객체가 탄생하기 때문이다. 그리고 데이터를 스스로 책임지고 처리하기 때문에 다른 객체들에게 불필요한 의존을 하지 않아 결합도는 낮게 유지된다.

이번에는 좀더 세부적으로 __캡슐화, 응집도, 결합도__ 측면에서의 객체지향 설계를 살펴보자.

---

#### 캡슐화.

상태와 행동을 하나의 객체 안에 모으는 이유는 __객체의 내부 구현을 외부로 부터 감추기 위함__ 이다.
여기서 __내부 구현__ 이란 __나중에 변경될 가능성이 높은 것들__ 로써 __데이터, 메서드__ 를 생각하면 된다. 그리고 상대적으로 __구현__ 에 비해 안정적인 부분을 __인터페이스__ 라고 한다.

캡슐화를 통해 __구현과 인터페이스를 분리__ 하고 외부에서는 __인터페이스에만 의존__ 하도록 하는 것이 변경에 보다 유연한 설계를 얻게 된다.

가장 중요한 원칙은 __캡슐화__ 다. __캡슐화__ 가 완벽하면 __낮은 결합도 / 높은 응집도__ 는 절로 따라오기 마련이다.

__캡슐화__ 는 변경 가능성이 높은 구현 부분을 객체 내부로 숨기는 __추상화__ 기법이다.
즉, __객체 내부의 변경될 수 있는 어떤 것이라도 캡슐화__ 를 하는것이 바람직하다.
























### 참고 및 출처
  - 오브젝트
