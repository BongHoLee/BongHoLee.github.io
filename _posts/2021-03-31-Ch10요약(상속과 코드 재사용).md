---
layout: post
title: Ch10 요약(상속과 코드 재사용)
author: Bong5
categories: [Java, Books/Object]
---

## Ch10 상속과 코드 재사용

[본문](https://bongholee.github.io/java/books/object/2020/02/23/%EC%9C%A0%EC%97%B0%ED%95%9C_%EC%84%A4%EA%B3%84.html)

---

## 들어가며

앞선 8장, 9장을 통해서 우리는 `재사용 가능한 설계`, `유연한 설계`를 위한 `의존성 관리 기법`들에 대해 학습하였다.

이번 장에서는 `코드 재사용`을 위해 `상속`을 활용했을 때 어떤 부작용들이 있는지, 왜 이러한 부작용들이 생기는지에 대해서 학습하고 이러한 부작용을 `추상화에 의존`하는 방법을 통해 어떻게 최소화 할 수 있는지 살펴본다.

이번 챕터의 제목이 `상속과 코드 재사용`이지만 내용은 **코드 재사용을 위해서 상속을 사용하면 좋지 않다.** 라는 점을 부각시킨다.

---

## 핵심.

- **중복 코드는 변경을 방해한다.**

- **중복 코드는 수정과 테스트에 드는 비용을 증가시킨다.**

- 중복 여부를 판단하는 기준은 `변경`이다.

- `요구사항이 변경`되었을 때 두 코드를 `함께 변경`해야 한다면 이 코드는 `중복`이다. 함께 수정할 필요가 없다면 중복이 아니다.

- **중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.**

- `중복 코드`는 항상 함께 수정해야 하기 때문에 하나라도 빠트리면 버그로 이어진다.

- **중복 코드가 늘어날 수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다.**

- 객체지향 개발에 있어 가장 큰 오해와 안티패턴 중 하나는 **코드 재사용(중복 제거)를 위해 상속을 사용하는 것이다.**

- `상속`을 염두에 두지 않고 설계된 클래스를 `상속`을 이용해 `재사용`하는 것은 생각보다 쉽지 않다. 개발자는 `재사용`을 위해 상속 계층 사이에 무수히 많은 가정을 세웠을지도 모른다. 그리고 이 `가정`은 **코드를 이해하기 어렵게 만들 뿐만 아니라 직관에도 어긋날 수 있다.**

- **상속을 이용해 코드를 재사용하기 위해서는 부모 클래스 개발자가 세웠던 가정이나 추론 과정을 정확히 이해해야 한다. 이것은 자식 클래스 개발자가 부모 클래스의 세부 구현에 대해 정확한 지식을 가져야 함을 의미하기 때문에 상속은 결합도를 높인다.**

- **상속은 결합도를 높인다. 즉, 자식 클래스는 부모 클래스의 세부 구현에 대해 정확히 알고있어야 한다.** 이러한 `결합도`가 코드를 수정하기 어렵게 만든다.

- `자식 클래스`의 메서드 안에서 `super` 참조를 이용해 `부모 클래스`의 메서드를 직접 호출하는 경우 두 클래스는 강하게 결합된다. 따라서 `super` 호출을 제거할 수 있는 방법을 찾아 결합도를 낮춰야 한다.

- `자식 클래스`가 `부모 클래스`의 구현에 강하게 결합된 경우 `부모 클래스`의 변경에 의해 `자식 클래스`가 영향을 받는다.

- 상속 관계로 연결된 자식 클래스가 `부모 클래스의 변경에 취약`해지는 현상을 가리켜 `취약한 기반 클래스 문제`라고 부른다.

- `취약한 기반 클래스 문제`는 **코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제다.**

- 즉, `코드 재사용을 위해 상속을 사용`하게 되면 `부모 클래스`의 세부 구현에 `자식 클래스`가 강하게 결합되기 때문에 `부모 클래스의 변경`에 `자식 클래스가 영향`을 받을 가능성이 커진다.

- **상속은 자식 클래스와 부모 클래스의 결합도를 높이고 이 결합도로 자식 클래스는 부모 클래스의 불필요한 세부 사항에 엮이게 된다.**

- `취약한 기반 클래스 문제`는 `캡슐화`를 약화시키고 `결합도`를 높인다.

- `상속`은 자식 클래스가 부모 클래스의 `구현 세부사항에 의존`하도록 만들기 때문에 `캡슐화`를 약화시킨다.

- 객체지향의 기반은 `캡슐화를 통한 변경의 통제`다. `상속`은 `코드 재사용`을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높인다.

- `상속`으로 인해 `불필요한 인터페이스 상속 문제`가 발생할 수 있다.

- 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다.

- **상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다.**

- `상속`으로 인해 `메서드 오버라이딩의 오작용 문제`가 발생할 수 있다.

- **자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스의 메서드 구현 세부사항에 자식 클래스가 결합될 수 있다.**

- `코드 재사용`을 위한 `상속`은 `캡슐화를 희생`한다.

- **완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야 한다.**

- `상속`으로 인해 **부모 클래스를 수정할 때 자식 클래스도 함께 수정해야 하는 경우가 생길 수 있다.**

- **상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문에 동시 수정 문제를 피하기 어렵다.**

- `결합도`란 `다른 대상에 대해 알고 있는 지식의 양`이다. **상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 자세히 알도록 강요한다.**

- **결국 "코드 재사용을 위한 상속"은 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 함께 수정해야 하는 상황이 빈번하게 발생한다.**

- `자식 클래스`가 `부모 클래스`의 `구현`이 아닌 `추상화`에 의존하도록 만듦으로써 `캡슐화 약화` 문제를 어느정도 해결할 수 있다.

- **부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정하라.**

- **차이를 메서드로 추출하라.**

- **중복 코드를 부모 클래스로 올려라**

- `추상화`가 핵심이다.

- 상속 계층이 걸림돌이 된다면 **추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링 하라.**

- **차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라.**

---

## 상속과 중복 코드

### DRY 원칙

**중복 코드는 변경을 방해한다.** 이것이 중복 코드를 제거해야 하는 가장 큰 이유다. 프로그램의 본질은 `비즈니스와 관련된 로직을 코드로 변환하는 것`이다. 그리고 이 지식은 항상 변하며, 그에 맞춰 `지식을 표현하는 코드 역시 변경`시켜야 한다.

**중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다.** 중복되는 지점을 하나하나 찾아야하고 모든 중복코드를 개별적으로 테스트해서 동일한 결과를 내놓는지 확인해야만 한다. 또한 `중복 코드는 수정과 테스트에 드는 비용을 증가`시킨다.

**중복 여부를 판단하는 기준은 '변경'이다.** 어떤 요구사항이 변경되었을 때 `두 코드를 함께 수정`해야 한다면 이 코드는 `중복`이다. 함께 수정할 필요가 없다면 중복이 아니다. 여기서 말하는 `함께 수정`이란 `응집도`의 관점이 아님을 유의하자.

> 중복 여부를 결정하는 기준은 코드의 모양이 아니다. 코드가 변경에 반응하는 방식이다.

### 중복과 변경

어떤 두 코드가 중복이 되었을 때를 가정해보자. (코드를 이용한 예시는 [본문](https://bongholee.github.io/java/books/object/2020/02/23/%EC%9C%A0%EC%97%B0%ED%95%9C_%EC%84%A4%EA%B3%84.html)을 확인하자.) 중복 코드가 적용되고 나서 얼마 후 `요구사항 변경`이 발생하였다. 개발자는 요구사항을 반영하기 위해 `중복 코드`를 하나하나 찾아가며 수정하고 테스트를 해야한다. 다시 말해 **하나의 요구사항 변경에 대해서 중복되는 지점을 모두 찾아 수정하고 테스트 하는 비용이 늘어난다.**

많은 코드 더미 속에서 어떤 코드가 중복인지를 파악하는 일은 쉬운 일이 아니다. `중복 코드는 항상 함께 수정`돼야 하기 때문에 수정할 때 하나라도 빠뜨린다면 `버그`로 이어질 것이다.

**중복 코드는 새로운 중복 코드를 부른다.** 중복 코드를 제거하지 않은 상태에서 요구사항 변경을 반영할 수 있는 유일한 방법은 `새로운 중복 코드를 추가`하는 것 뿐이다. **중복 코드가 생기기 시작하면 점점 늘어나는 악순환에 빠지게 된다.**

> 민첩하게 변경하기 위해서는 중복 코드를 추가하는 대신 제거해야 한다. 기회가 생길 때 마다 코드를 DRY하게 만들도록 노력하라.

### 타입 코드를 이용한 중복 제거

두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 `클래스를 하나로 합치는 것`이다. 그리고 `타입`에 따라 `분기`를 함으로써 중복 코드를 제거할 수 있다.

하지만 이 방법은 근본적으로 문제점을 갖고 있다. 앞선 장에서 설명한 바와 같이 **타입 코드를 사용하는 클래스는 '낮은 응집도'와 '높은 결합도'의 문제에 시달리게 된다.**

- **낮은 응집도** : 서로 다른 이유로 변경되는 코드가 하나의 클래스 내에 공존하게 된다. 다시 말해 서로 다른 이유로 서로 다른 시점에 변경되는 응집도 낮은 책임을 갖는 클래스가 탄생한다.

- **높은 결합도** : 타입을 구분하기 위해 구체 타입에 대한 정보를 알아야 한다. 다시말해 `타입`에 대해 알아야 할 지식이 많아지기 때문에(`세부 타입이 캡슐화 되지 않고 노출`) 타입의 종류가 변경되면 파급 효과가 미친다.

객체지향 프로그래밍 언어는 `타입 코드`를 사용하지 않고도 `중복 코드`를 관리할 수 있는 효과적인 방법을 제공한다. `상속`이 바로 그것이다.

### 상속을 이용한 중복 제거

`상속`의 기본 아이디어는 매우 간단한다. **이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하라** 는 것이다.

`상속`을 이용해서 코드를 재사용하게 되면 어떤 요구사항이 변경되었을 때 하나의 클래스(`부모 클래스`)만 수정하면 된다.

### 상속의 문제점

> 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하지 말라.

> 코드 재사용을 위한 상속은 코드의 품질을 낮춘다.

말로만 들으면 `상속`은 `중복 제거`를 위해, 즉 `코드 재사용`을 위한 완벽한 도구인 것 같다.

결론부터 이야기 하자면 **상속은 코드 재사용을 위한 도구가 아니다.** 정확히 이야기 하자면 **코드(구현) 재사용을 위한 상속은 코드의 품질을 현격히 낮추게 된다.**

코드 중복을 제거하기 위해 어떤 클래스를 상속한다고 가정해보자. `자식 클래스`의 개발자는 `부모 클래스`의 세부 구현 내용에 대해 정확한 지식을 가져야 한다. 또한 **부모 클래스의 코드를 재사용 하기 위해 직관적이지 않은 가정을 세우게 될 수 있다.**

단순히 하나의 상속 계층으로 구성된 코드라면 그렇게까지 큰 문제가 되지 않을 수 있다. 하지만 상속 계층이 상당히 깊다면 이 계층에 걸쳐 각 개발자들이 세운 무수한 가정들에 대해 이해해야 하기 떄문에 코드 이해가 쉽지 않을 수 있다.

중요한 것은 **개발자의 가정을 이해하기 전에는 코드를 이해하기가 어렵다.** `상속`을 염두에 두고 설계되지 않은 클래스를 `상속`하여  재사용 하는 것은 생각처럼 쉽지 않다.

더 큰 문제는 **자식 클래스가 부모 클래스의 세부 구현에 대해 자세히 알아야 한다는 것이다.** 다시 말해 **상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다.** 이것은 **자식 클래스의 개발자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다.**

따라서 `상속`은 `결합도`를 높인다. 그리고 **상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.**

`자식 클래스`가 `부모 클래스의 구현에 강하게 결합`될 경우 부모 클래스의 변경에 의해 `자식 클래스가 영향`을 받는다.

이처럼 `상속 관계`로 연결된 `자식 클래스`가 `부모 클래스의 변경에 취약`해지는 현상을 가리켜 `취약한 기반 클래스 문제`라고 부른다.

**취약한 기반 클래스 문제는 코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제다.**

---

<br>

## 취약한 기반 클래스 문제

> 상속은 자식 클래스와 부모 클래스를 강하게 결합되게 만든다. 이 강한 결합도로 인해 자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다. 부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 실행 에러라는 고통에 시달려야 할 수도 있다.

이처럼 `부모 클래스의 변경에 의해 자식 클래스가 영향`을 받는 현상을 `취약한 기반 클래스 문제`라고 일컫는다. 이 문제는 **상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.**







### 참고 및 출처

  - 오브젝트
