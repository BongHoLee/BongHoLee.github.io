---
layout: post
title: Ch6 요약(메시지와 인터페이스)
author: Bong5
categories: [Java, Books/Object]
---

## Ch6 메시지와 인터페이스

[본문](https://bongholee.github.io/java/books/object/2020/01/17/메시지_인터페이스.html)

---

## 들어가며

이전 장 까지 우리는 객체지향 설계에서 가장 중요한 것들을 살펴보았다. 

요약하자면 객체지향 설계란 **책임을 수행하는 자율적인 객체들과 역할 구성된 협력을 설계하는 것이다.**

결국 `객체`에게 가장 중요한 것은 `책임`이다. 객체에게 얼마나 품질 높은 책임을 할당했느냐에 따라 설계의 품질이 결정된다. 품질 높은 책임이란 어떤 책임을 의미하는가? 바로 `협력`에 어울리는 책임. 즉 **클라이언트의 관점을 반영한 책임** 을 의미한다.

우리는 위와 같이 `협력에 어울리는 책임`을 할당하기 위해 `책임 주도 설계`의 절차에 따라 `필요한 메시지를 식별`한 뒤 `객체를 선택`하였고, 그 결과로 `최소한의 인터페이스`와 `충분히 추상적인 인터페이스`를 얻을 수 있었다.

이와 같이 객체지향 설계에서 가장 중요한 것은 `품질 높은 책임`을 할당함으로써 `품질 높은 퍼블릭 인터페이스`를 구성하는 것이다.

이번 장에서는 `품질 높은 인터페이스`를 얻기 위해 `책임 주도 설계` 방법에 더불어 적용 할 수 있는 몇 가지 원칙들을 살펴볼 것이다.

기억해야 할 점은 **설계는 항상 트레이드오프가 존재한다는 사실이다.** 비록 `원칙`이라고 하더라도 현재의 설계에 적합하지 않다면 과감히 배제해야 한다는 사실을 기억하고 시작해 보자. 


---

## 핵심.

- 훌륭한 객체지향 코드를 얻기 위해서는 **클래스가 아니라 객체를 지향해야 한다.**

- 객체를 지향한다는 문장의 의미는 **객체가 수행하는 책임에 초점을 맞춰야 한다는 것이다.**

- 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체가 주고받는 `메시지`이다.

- 애플리케이션은 클래스로 구성되지만 `메시지를 통해 정의`된다는 사실을 기억하자.

- 객체가 수신하는 `메시지`들이 객체의 `퍼블릭 인터페이스`를 구성한다.

- 협력에 적합한 객체를 설계하기 위해서는 **외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.**

- `메시지`는 **객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.** 

- `메시지`를 수신했을 때 실제로 어떤 코드가 실행되는지는 `메시지 수신자의 실제 타입`이 무엇이냐에 달려있다.

- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 `메서드`라고 부른다.

- **메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결하기 때문에 컴파일 시점과 런타임 시점의 의미가 달라질 수 있다.**

- `메시지`와 `메서드`의 구분은 **메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.**

- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 `퍼블릭 인터페이스`라고 한다.

- `퍼블릭 인터페이스`에 속한 메시지의 집합을 `오퍼레이션`이라고 부른다.

- `메서드`는 `오퍼레이션`의 여러 가능한 구현 중 하나다.

- 인터페이스의 각 요소는 `오퍼레이션`이다. **오퍼레이션은 구현이 아닌 추상화다. 메서드는 오퍼레이션을 구현한 것이다.**

- 퍼블릭 인터페이스와 메시지의 관점에서 보면 `메서드 호춣`보다는 `오퍼레이션 호출`이 적합하다.

- 객체가 다른 객체에게 `메시지를 전송`하면 런타임 시스템은 `오퍼레이션 호출`로 해석하고 메시지를 수신한 객체의 `실제 타입을 기반`으로 하여 `적절한 메서드를 실행`한다.

- 오퍼레이션의 관점에서 `다형성`이란 **동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것으로 정의 할 수 있다.**

- `메시지`는 **협력에 참여하는 전송자와 수신자 양쪽 모두를 포함하는 개념이다.**

- `오퍼레이션`은 객체가 다른 객체에게 제공하는 `추상적인 서비스`이다. 

- `메시지`가 클라이언트오 서버 사이의 협력 관계를 강조하는데 비해 `오퍼레이션`은 메시지를 수신하는 서버객체의 `인터페이스`를 강조한다. 다시말해서 **메시지 전송자는 고려하지 않은 채 메시지 수신자의 관점만을 다루는 것이 오퍼레이션이다.**

- `메서드`는 메시지에 응답하기 위해 실행되는 `코드 블럭`이다. **메서드는 오퍼레이션의 구현이다.**

- `퍼블릭 인터페이스`는 객체가 협력에 참여하기 위해 `외부에서 수신할 수 있는 메시지 묶음`이다. **클래스의 퍼블릭 메서드 집합이나 메시지의 집합을 가리키는데 사용된다.** 

- 객체를 설계할 때 가장 중요한 것은 **품질 높은 퍼블릭 인터페이스를 설계하는 것이다.**

- `퍼블릭 인터페이스`의 품질에 영향을 미치는 몇 가지 원칙이 존재하는데 `디미터 법칙`, `묻지말고 시켜라`, `클라이언트의 의도를 드러내는 인터페이스`, `명령-쿼리 분리`로 나누어 볼 수 있다.

- `디미터 법칙`은 `협력하는 객체의 내부 구조에 대한 결합`으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.

- `디미터 법칙`을 간단하게 요약하면 **객체 내부의 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.**

- `디미터 법칙`은 `캡슐화`를 다른 관점에서 표현한 것이다. **클래스를 캡슐화 하기 위해 따라야 하는 구체적인 지침을 제공한다.**

- `디미터 법칙`은 훌륭한 메시지란 객체의 상태에 대해 묻지 말고 단지 **원하는 것을 시켜야 한다는 사실을 강조한다.**

- 메시지 전송자(`클라이언트`)는 메시지 수신자(`서버`)의 상태를 기반으로 결정을 내린 후 메시지 수신자(`서버`)의 상태를 바꿔서는 안된다. **객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.**

- `묻지말고 시켜라` 원칙을 따르면 **밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.**

- `묻지말고 시켜라` 원칙을 따르면 **객체의 정보를 이용하는 행동을 객체의 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.**

- **상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스의 품질을 향상시켜라.**

- 인터페이스는 `어떻게`가 아니라 `무엇`을 하는지를 드러내야 한다.

- `어떻게` 수행하는지 드러내는 인터페이스는 `내부 구현`을 설명하는(드러내는) 인터페이스다.

- `무엇`을 하는지 드러내는 인터페이스를 얻기 위해서는 **객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.**

- 가끔씩은 물어야 하는 경우도 존재한다.

- 객체에게 시키는 것이 항상 가능한 것은 아니다. **소프트웨어 설계에 있어서 법칙이란 존재하지 않는다.** 원칙을 맹신하지 말자.

- `명령`이란 객체의 `상태`를 수정하는 오퍼레이션을 의미한다.

- `쿼리`란 객체와 관련된 `정보`를 반환하는 오퍼레이션을 의미한다.

- `명령-쿼리 분리` 원칙의 요지는 **오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다.**

- **객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.**

- **객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.**

- **훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.**


---

## 협력과 메시지

### 클라이언트-서버 모델

두 객체 사이의 협력 관계를 설명하기 위해 사용되는 전통적인 메타포는 `클라이언트-서버` 모델이다. 협력 안에서 메시지를 전송하는 객체를 `클라이언트`, 메시지를 수신하는 객체를 `서버`라고 부른다. **협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.**

객체는 협력에 참여하는 동안 `클라이언트와 서버의 역할을 동시에 수행`하는 것이 일반적이다. 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다. 하나는 `객체가 수신하는 메시지 집합`이고 다른 하나는 `외부의 객체에게 전송하는 메시지의 집합`이다. **협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.**

요점은 **객체가 독립적으로 수행할 수 있는 것 보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것이다.**

### 메시지와 메시지 전송

`메시지(Message)`는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. 한 객체가 다른 객체에게 도움을 요청하는 것을 `메시지 전송`이라고 부른다. 이 때 메시지를 전송하는 객체를 `메시지 전송자`라고 부르고 메시지를 수신하는 객체를 `메시지 수신자`라고 부른다. `클라이언트-서버` 모델에서는 `메시지 전송자를 클라이언트`, `메시지 수신자를 서버`라고 부르기도 한다.

`메시지`는 `오퍼레이션`과 `인자`로 구성되며 `메시지 전송`은 여기에 `메시지 수신자를 추가`한 것이다. 따라서 메시지 전송은 `메시지 수신자`, `오퍼레이션 명`, `인자`의 조합이다.

- **메시지** : `isSatisfiedBy(screening)`
- **메시지 전송** : `condition.isSatisfiedBy(screening)`

### 메시지와 메서드

**메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인지에 달려있다.** 이처럼 **메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 한다.** 중요한 것은 코드 상에서 동일한 이름의 변수(`condition`)에게 동일한 메시지를 전송하더라도 `객체의 타입`에 따라 실행되는 메서드가 달라질 수 있다는 것이다.

> 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결(바인딩)해야 하기 때문에 컴파일 시점과 런타임 시점의 의미가 달라질 수 있다.

이처럼 `메시지 전송`을 코드 상에 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다.** 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 `적절한 메서드를 선택`해서 응답할 것이라고 믿을 수 밖에 없다.

**메시지와 메서드의 구분은 메시지 전송자(클라이언트)와 메시지 수신자(서버)가 느슨하게 결합할 수 있도록 한다.** 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다. **수신자가 어떤 클래스의 인스턴스인지 어떤 방식으로 요청을 처리하는지 모르더라도 원활한 협력이 가능하다.** 메시지 수신자 역시 누가 메시지를 전송하는지 알 필요가 없다. 단지 메시지가 도착했다는 사실만 알면 된다. **메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.**

> 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 가느다란 끈을 통해서만 연결된다. 

> 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 한다.

### 퍼블릭 인터페이스와 오퍼레이션

**객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.** 외부에서는 오직 객체가 공개하는 `메시지`를 통해서만 객체와 상호작용 할 수 있다. 이처럼 **객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.**

프로그래밍 언어의 관점에서 `퍼블릭 인터페이스에 포함된 메시지`를 `오퍼레이션`이라고 부른다. **오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.** 흔히 `오퍼레이션`이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 `메시지와 관련된 시그니처`를 가리키는 경우가 많다.  예로 `isSatisfiedBy`가 오퍼레이션에 해당한다.

그에 비해 **메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.** `SequenceCondition`과 `PeriodCondition`의 두 메서드는 `DiscountCondition` 인터페이스에 정의된 `isSatisfiedBy` 오퍼레이션의 여러 가능한 구현 중 하나이다.

> 인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화다. 

> 메서드는 오퍼레이션을 구현한 것이다. 

프로그래밍 언어의 관점에서 객체가 다른 객체에게 `메시지를 전송`하면 런타임 시스템은 `오퍼레이션 호출로 해석`하고 메시지를 수신한 객체의 실제 타입을 기반으로 `적절한 메서드를 찾아 실행`한다. 따라서 **퍼블릭 인터페이스와 메시지의 관점에서 보면 메서드 호출보다는 오퍼레이션 호출이라는 용어가 적절하다.**

`오퍼레이션`의 관점에서 `다형성`이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.

**_용어 정리_** 

- **메시지** : 객체의 `오퍼레이션`이 호출되도록 요청하는 것을 `메시지 전송`이라고 부른다. **메시지는 협력에 참여하는 전송자(클라이언트)와 수신자(서버) 양쪽 모두를 포함하는 개념이다.**
- **오퍼레이션** : **객체가 다른 객체에게 제공하는 추상적인 서비스다.** 메시지가 전송자와 수신자 사이의 협력 관계를 강조하는데 비해 `오퍼레이션`은 메시지를 수신하는 `객체의 인터페이스`를 강조한다. 다시말해서 메시지 전송자는 고려하지 않은 채 **메시지 수신자의 관점만을 다룬다.** **메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것을 의미한다.**
- **메서드** : 메시지에 응답하기 위해 실행되는 `코드 블럭`을 의미한다. **메서드는 오퍼레이션의 구현이다.** **동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.**
- **퍼블릭 인터페이스** : **객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음.** 클래스의 퍼블릭 메서드들의 집합이나 메시지의 집합을 가리키는데 사용된다. 

> 중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다는 것이다. 

> 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 볼 수 있다.

## 인터페이스와 설계 품질

앞서 살펴본 바와 같이 좋은 인터페이스란 `최소한의 인터페이스`와 `충분히 추상적인 인터페이스`라는 조건을 만족해야 한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. 추상적인 인터페이스는 `어떻게`가 아니라 `무엇`을 하는지를 표현한다.

**최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다.** 책임 주도 설계 방법은 `메시지를 먼저 선택`함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는것을 방지한다. 또한 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 `클라이언트의 의도를 메시지에 표현`할 수 있게 한다. 따라서 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.

여기서 `퍼블릭 인터페이스`의 품질에 영향을 미치는 다음과 같은 원칙과 기법에 관해 살펴보자.

- **디미터 법칙**
- **묻지 말고 시켜라**
- **의도를 드러내는 인터페이스**
- **명령-쿼리 분리**

아래 코드는 앞선 장에서 **절차적인 방식의 영화 예매 시스템 코드 중 할인 가능 여부를 체크하는 코드** 를 가져온 것이다.

<script src="https://gist.github.com/BongHoLee/5a351d7d9afc8e65dd557b0df8efdbeb.js"></script>

이 코드의 가장 큰 단점은 `ReservationAgency`와 인자로 전달된 `Screening` 사이의 `결합도`가 너무 높기 때문에 `Screening`의 내부 구현을 변경할 때 마다 `ReservationAgency`도 함께 변경된다는 것이다. 문제의 원인은 `ReservationAgency`가 `Screening` 뿐 아니라 `Movie`와 `DiscountCondition`에도 직접 접근하기 때문이다.

이처럼 **협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙이다.** 

`디미터 법칙`을 간단하게 요약하면 **객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.** 디미터 법칙은 **낯선자에게 말하지 말라** 또는 **오직 인접한 이웃하고만 말하라** 로 요약할 수 있다. 자바에서는 **오직 하나의 도트만 이용하라** 라는 말로 요약되기도 한다.

`디미터 법칙`은 객체들의 협력 경로를 제한하면 `결합도`를 효과적으로 낮출 수 있다는 사실에 기반한다. 여기서 말하는 `협력 경로`란 아래와 같다.

- `this` 객체
-  `메서드의 매개 변수`로 전달된 객체
- `this의 속성(인스턴스 변수)`
- `this의 속성인 컬레션의 요소`
- 메서드 내에서 생성된 지역 객체

앞의 코드에서 `결합도` 문제를 해결하기 위해 수정된 `ReservationAgency`의 최종 코드를 보자.

<script src="https://gist.github.com/BongHoLee/459e409cd8ad3a0dd59d10c415cce0e9.js"></script>

위 코드에서 `ReservationAgency`는 메서드의 인자로 전달된 `Screening` 인스턴스에게만 메시지를 전송한다. `ReservationAgency`는 `Screening`의 내부에 대한 어떤 정보도 알지 못한다. `ReservationAgnecy`가 `Screening`의 내부 구조에 결합되어있지 않기 때문에 `Screening`의 내부 구현을 변경할 때 `ReservationAgency`를 함께 변경할 필요가 없다.

`디미터 법칙`을 따르면 `부끄럼타는 코드`를 작성할 수 있다. **부끄럼타는 코드란 (서버로써)불필요한 어떤것도 다른 객체에게 보여주지 않으며 (클라이언트로써)다른 객체의 구현에 의존하지 않는 코드를 의미한다.**

`디미터 법칙`을 따르는 코드는 메시지 수신자(`서버`)의 내부 구조가 메시지 송신자(`클라이언트`)에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. 따라서 **클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.**

> 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 디미터 법칙이 가치 있는 이유는 클래스를 캡슐화 하기 위해 따라야 하는 구체적인 지침을 제공하기 때문이다.
> 캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
> 디미터 법칙은 협력과 구현이라는 사뭇 달라 보이는 두 가지 문맥을 하나의 유기적인 개념으로 통합한다. 클래스의 내부 구현을 채워가는 동시에 현재 협력하고 있는 클래스에 관해서도 고민하도록 주의를 환기시키기 때문이다.

`디미터 법칙`을 따르도록 코드를 개선하면 메시지 전송자는 더 이상 메시지 수신자의 내부 구조에 대해 묻지 않게된다. **단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청한다.**
`screening.calculateFee(audienceCount);`

**디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조한다.** 정보를 처리하는데 필요한 책임을 정보를 알고있는 객체에게 할당하기 때문에 응집도가 높은 객체를 만들 확률이 높아진다.

**하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 응집도가 낮아질 수도 있다.** 이와 관련해서는 뒤에서 나온다.

### 묻지 말고 시켜라

`디미터 법칙`은 **객체 내부의 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지를 작성하도록 속삭인다.** 그리고 자연스럽게 이런 형태의 메시지를 장려하는 코딩 스타일이 나타났는데 그것이 바로 `묻지 말고 시켜라` 스타일이다.

> 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반하는 것이다.

> 절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.

`묻지 말고 시켜라` 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 즉, `묻지 말고 시켜라` 원칙을 따르게 되면 **객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.** 따라서 묻지 말고 시켜라 원칙을 따르도록 메시지를 결정하다 보면 자연스럽게 `정보 전문가`에게 책임을 할당하게 되고 `높은 응집도`를 가진 클래스를 얻게 될 확률이 높아진다.

`디미터 법칙`과 `묻지 말고 시켜라` 원칙이 이야기 하는 핵심은 **객체의 내부 상태를 이용하여 어떤 결정(or 행동)을 하는 로직이 해당 객체의 외부에 존재하지 않아야 한다는 것이다.** 이는 해당 객체가 책임져야할 어떤 행동이 객체 외부로 누수된 것이다.

> 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하여 인터페이스의 품질을 높여라. 

> 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올림으로써 퍼블릭 인터페이스의 품질을 높여라.

### 의도를 드러내는 인터페이스

하지만 단순하게 객체에게 묻지 않고 시킨다고 하여 모든 문제가 해결되는 것은 아니다. **훌륭한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안된다.** 즉, 인터페이스는 객체가 `어떻게` 하는지가 아니라 `무엇`을 하는지를 서술해야 한다(충분히 추상적인 인터페이스를 위하여).

메서드가 작업을 `어떻게` 수행하는지 드러내게 된다면 메서드의 이름에서 `내부의 구현 방법`을 드러내게 된다. 이런 스타일은 좋지 않은데 `메서드 수준에서 캡슐화를 위반`한다는 점이 가장 큰 문제점이다.

이를 해결하기 위한 방법은 메서드가 `어떻게`가 아니라 `무엇`을 하는지를 드러내는 것이다. **무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들 뿐 아니라 유연한 코드를 낳는 지름길이다.**










### 참고 및 출처

  - 오브젝트
