---
layout: post
title: Ch9 요약(유연한 설계)
author: Bong5
categories: [Java, Books/Object]
---

## Ch9 유연한 설계

[본문](https://bongholee.github.io/java/books/object/2020/02/23/%EC%9C%A0%EC%97%B0%ED%95%9C_%EC%84%A4%EA%B3%84.html)

---

## 들어가며

8장에서 우리는 올바른 객체지향 설계란 `의존성 관리`임을 학습했다.

`의존성 관리`란 **독립적인 컨텍스트에 의존함으로써 결합도를 낮추고 변경의 영향 범위를 통제하며 재사용 가능한 설계를 얻기 위해 반드시 고려해야하는 설계의 핵심 요소이다.**

그리고 `올바른 의존성 관리`를 위해 아래와 같은 소주제를 학습했다.

- **추상화에 의존하라**

- **인터페이스에 의존성을 명시적으로 드러내라**

- **생성과 사용의 책임을 분리하라**

이번 장에서는 이와같은 내용을 `원칙(개방-폐쇄 원칙, 의존성 역전 원칙)`이라는 관점에서 한번 더 정리한다.

---

## 핵심.

- 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나는 **개방-폐쇄 원칙** 이다.

- 소프트웨어 개체(클래스, 모듈, 함수 등)은 **확장에 대해서 열려있어야 하고 수정에 대해서 닫혀있어야 한다.**

- **개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.**

- `개방-폐쇄 원칙`을 수용하는 코드는 `컴파일타임 의존성`을 수정하지 않고도 `런타임 의존성`을 쉽게 변경할 수 있다.

- `의존성`의 관점에서 `개방-폐쇄 원칙`을 따르는 설계란 **컴파일타임 의존성을 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조** 라고 할 수 있다.

- **개방-폐쇄 원칙의 핵심은 '추상화'에 의존하는 것이다.**

- `추상화`란 **핵심적인 부분(공통적인 부분, 변경되지 않는 부분)만을 남기고 불필요한 부분(변경되는 부분, 세부적인 부분)을 생략함으로써 복잡성을 극복하는 방법이다.**

- `추상화` 과정을 거치게 되면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.

- `추상화`를 사용하면 **생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.**

- **공통적인 부분은 문맥에 바뀌더라도 변하지 않아야 한다. 다시말해서 수정할 필요가 없어야 한다.**

- 단순히 어떤 개념을 `추상화`했다고 해서 수정에 닫혀잇는 설계를 만들 수 있는 것은 아니다. `개방-폐쇄 원칙`에서 `폐쇄`를 가능하게 하는 것은 `의존성의 방향`이다. **수정에 대한 영향을 최소화 하기 위해서는 모든 요소가 추상화에 의존해야 한다.**

- `명시적 의존성`과 `의존성 해결`을 통해 컴파일타임 의존성을 런타임 의존성으로 대체함으로써 `실행 시에 객체의 행동을 확장`할 수 있다.

- **핵심은 추상화라는 것을 기억하라.**

- **올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.**

- 변경에 의한 파급효과를 최대한 피하기 위해서는 **변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야 한다.**

- **추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.**

- 결국 `추상화`에도 `올바른 추상화`가 있다.

- `객체 생성`에 대한 지식은 `과도한 결합도`를 초래하는 경향이 있다.

- 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임인 `생성`과 `사용`을 분리해야 한다.

- 전체적으로 `결합도`를 낮추고 `재사용성`을 높이기 위해 `도메인 개념`과는 아무런 상관이 없는 `가공의 객체에 책임을 할당`해야 하는 경우가 빈번하다.

- `도메인 모델, 도메인 개념`은 설계를 위한 중요한 `출발점`이지만 단지 `출발점`임을 명시해야한다.

- **모든 책임을 '도메인 객체'에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제가 야기될 가능성이 높다.**

- 설계자의 편의를 위해 임의로 만들어낸 `가공의 객체`에게 책임을 할당하여 문제를 해결할 수 있다.

- `도메인`과 무관한 인공적인 객체를 `PURE FABRICATION(순수한 가공물)`이라고 부른다.

- **어떤 행동을 추가하려고 하는데 이 행동을 책임질만한 마땅한 도메인 개념이 존재하지 않는다면 가공 객체를 추가하고 이 객체에게 책임을 할당하라.**

- 객체지향 어플리케이션의 대부분은 `가공 객체`들이 `도메인 개념 객체`보다 더 많은 비중을 차지하는 것이 일반적이다.

- **숨겨진 의존성은 코드를 이해하기 위해 내부 구현을 살펴봐야 한다는 측면에서 '캡슐화' 위반이다.**

- 객체 사이의 협력이 존재할 때 `협력의 본질`을 담고 있는 것은 `상위 수준의 정책`이다.

- **어떤 협력에서 중요한 정책이나 의사결정 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스다.**

- **상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안된다.**

- **상위 수준의 클래스와 하위 수준의 클래스 모두 추상화에 의존해야 한다. 이를 '의존성 역전 원칙'이라고 부른다.**

- **유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.**

- 구체 클래스는 의존성의 `시작점`이어야 한다. 의존성의 `목적지`가 돼서는 안된다.

- **추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.**

- 함께 재사용될 필요가 없는 클래스들은 `별도의 독립적인 패키지`에 모아야 한다.

- **인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시키는 것이 중요하다. 이는 객체지향 프레임워크의 모듈 구조를 설계하는 데 가장 중요한 핵심 원칙이다.**

- 유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 `의존성의 방향을 역전`시킨다.

- **상위 수준의 모듈과 하위 수준의 모듈이 모두 추상화에 의존하도록 설계하라.**

- **훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.**

- **유연한 설계는 유연성이 필요할때만 옳다.**


---

## 개방-폐쇄 원칙

> 소프트웨어 개체(클래스, 모듈, 함수 등)은 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다.

- **확장에 대해서 열려 있다** : 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작을 추가`해서 애플리케이션의 `기능을 확장`할 수 있다.

- **수정에 대해 닫혀있다.** : 기존의 `코드`를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

`개방-폐쇄 원칙`은 유연한 설계가 **기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계라고 이야기한다.**

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라.

> 개방-폐쇄 원칙은 사실 런타임의존성과 컴파일타임 의존성에 관한 이야기다.

유연하고 재사용 가능한 설계에서 `런타임 의존성`과 `컴파일타임 의존성`은 서로 다른 구조를 가진다.

`영화 예매 시스템의 할인 정책`을 `의존성 관점`에서 다시 살펴보자.

<p align="center">
<img src="/assets/img/object/ch9/img1.png" width="80%" height="auto">
</p>

컴파일타임 의존성 관점에서 `Movie` 클래스는 추상 클래스인 `DiscountPolicy`에 의존한다.

런타임 의존성 관점에서 `Movie` 인스턴스는 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 인스턴스에 의존한다.

위 그림에서 알 수 있듯이 **Movie의 관점에서 DiscountPolicy에 대한 컴파일타임 의존성과 런타임 의존성은 동일하지 않다.**

현재의 설계는 **새로운 할인 정책을 추가해서 기능을 확장할 수 있도록 허용한다.** 따라서 `확장에 대해서는 열려있다.`

또한 **기존 코드를 수정할 필요 없이 새로운 클래스릋 추가하는 것만으로 새로운 할인 정책을 확장할 수 있다.** 따라서 `수정에 대해서는 닫혀있다.` 이것이 `개방-폐쇄 원칙`이 의미하는 것이다.

> 개방-폐쇄 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.

> 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.

<p align="center">
<img src="/assets/img/object/ch9/img2.png" width="80%" height="auto">
</p>

### 추상화가 핵심이다.

**개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.**

`추상화`란 `핵심적인 부분(공통적인 부분, 변경되지 않는 부분)`만을 남기고 `불필요한 부분(세부적인 부분, 변경되는 부분)`을 생략함으로써 `복잡성을 극복`하는 기법이다.

**추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.** `추상화`를 사용하면 `생략된 부분을 문맥에 적합한 내용으로 채워넣음`으로써 각 문맥에 적합하게 `기능을 구체화하고 확장`할 수 있다.

> 개방-폐쇄 원칙의 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 변하지 않는 공통점을 반영한 추상화의 결과물이다.

**공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.** 다시 말해서 `수정`할 필요가 없어야 한다. 따라서 `추상화` 부분은 수정에 대해서 닫혀있다. **추상화를 통해 생략된 부분은 확장의 여지를 남긴다.**

이해를 돕기 위해 아래 코드(`DiscountPolicy`)를 살펴보자.

<script src="https://gist.github.com/BongHoLee/ce554c7b44152795a1179c7b106ea753.js"></script>

`DiscountPolicy`는 `추상화`다. 추상화 과정을 통해 생략된 부분은 `할인 요금을 계산하는 구체적인 방법`이다. **우리는 상속을 통해 생략된 부분을 구체화함으로써 할인 정책을 확장할 수 있는 것이다.**

여기서 **변하지 않는 부분은 고정하고 변하는 부분은 생략하는 추상화 메커니즘이 개방-폐쇄 원칙의 기반이 된다는 사실에 주목하자.** 언제라도 `추상화`의 생략된 부분을 채워넣음으로써 `새로운 문맥에 맞게 기능을 확장`할 수 있다. 따라서 **추상화는 설계의 확장을 가능하게 한다.**

> 개방-폐쇄 원칙에서 '폐쇄'를 가능하게 하는 것은 '의존성의 방향'이다.

**변경에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.**

<script src="https://gist.github.com/BongHoLee/c31223ae01da63260997cb5e07e6510e.js"></script>

위 코드에서 볼 수 있듯 `Movie`는 할인 정책을 추상화한 `DiscountPolicy`에만 의존한다. **의존성은 변경의 영향을 의미하고 DiscountPolicy는 변하지 않는 추상화라는 사실에 주목하자.**

`Movie`는 안정된 `추상화`인 `DiscountPolicy`에 의존하기 때문에 할인 정책을 추가하기 위해 `DiscountPolicy`의 자식 클래스를 추가하더라도 영향을 받지 않는다. 따라서 `Movie`와 `DiscountPolicy`는 `수정에 대해 닫혀있다.`

> 추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다.

앞서 8장에서 설명한 것 처럼 `명시적 의존성`과 `의존성 해결`을 통해 `컴파일 타임 의존성`을 `런타임 의존성`으로 대체함으로써 `실행 시에 객체의 행동을 확장`할 수 있다.

이런 것들이 가능한 이유의 중심에는 `추상화`가 있음을 기억하라.

> 올바른 추상화를 설계하고 추상화에만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

여기서 주의할 점은 추상화를 했다고 해서 모든 수정에 대해 설계가 폐쇄되는 것은 아니라는 것이다. 수정에 대해 닫혀있고 확장에 대해 열려있는 설계는 쉽게 얻어지지 않는다.

`변경`에 대한 파급효과를 최대한 피하기 위해서는 `변하는 것과 변하지 않는 것이 무엇인지를 이해`하고 이를 `추상화`의 목적으로 삼아야만 한다.

**추상화가 수정에 대해 닫혀있을 수 있는 이유(변경의 파급효과를 통제할 수 있는 이유)는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의깊게 선택했기 때문이라는 사실을 기억하자.**










### 참고 및 출처

  - 오브젝트
