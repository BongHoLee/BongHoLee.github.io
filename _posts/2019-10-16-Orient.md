---
layout: post
title: 객체, 설계
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

---

__객체지향의 사실과 오해__ 도서 1독 이후 개념적으로나마 객체지향 설계에 대한 맥락을 짚어보았다.

파편화된 개념들을 이제 코드를 예제로 학습하기 위해 동일 저자 __조영호__ 님의 두 번째 객체지향 도서 __오브젝트__ 를 선택했다.


챕터 1. __객체, 설계__ 시작해보자.
---

### 실무가 먼저다.

로버트 L. 글래스는 __<소프트웨어 크리에이티비티 2.0>__ 에서 '이론 대 실무'라는 흥미로운 주제에 관한 개인적인 견해를 밝히고 있다. 글래스가 그 글에서 우리이게 던진 질문을 한마디로 요약하면 다음과 같다. "이론이 먼저일까 실무가 먼저일까?"

대부분의 사람들은 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전한다고 생각한다. 글래스는 그 반대라고 주장한다. 글래스에 따르면 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다고 한다.

소프트웨어 개발에서 실무가 이론보다 앞서 있는 대표적인 분야로 __소프트웨어 설계__ 와 __소프트웨어 유지보수__ 를 들 수 있다. 대부분의 설계 원칙과 개념은 이론에서 출발해서 실무에 스며들었다기 보다는 실무에서 반복적으로 적용되던 기법들을 이론화 한 것들이 대부분이라는 것이다.

결론적으로 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 __실무에 초점__ 을 맞추는 것이 효과적이다.

그러니 우리는 이론과 개념은 잠시 뒤로 미루고 간단한 프로그램을 하나 살펴보는 것으로 시작하자.

---

#### 01 티켓 판매 어플리케이션 구현하기

상황
```
어느 소극장은 홍보도 할 겸 관람객들의 발길이 이어지도록 작은 이벤트를 기획하기로 했다.
이벤트의 내용은 간단한데 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송하는 것이다.

공연 당일, 관람객들이 입장하고 있다.
당연한 이야기겠지만 이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장시켜야 한다.

이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있다.
이벤트에 당첨되지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.

따라서 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고 이벤트 당처맞가 아닌 경우에는 티켓을 판매한 후에 입장시켜야 한다.

```

<script src="https://gist.github.com/BongHoLee/89641335278c05fe02b3447b235f634a.js"></script>

위의 코드는 정상적으로 작동한다.

코드의 흐름을 살펴보자.

1. __공연장__ 은 먼저 __관람객__ 의 __가방__ 안에 __초대장__ 이 들어있는지 확인한다.

2. 만약 __초대장__ 이 들어 있다면 이벤트에 당첨된 관람객이므로 __판매원__ 에게서 받은 __티켓__ 을 __관람객__ 의 __가방__ 안에 넣어준다.

3. __가방__ 안에 __초대장__ 이 없다면 __티켓__ 을 판매해야 한다. 이 경우 __공연장__ 은 __관람객__ 의 __가방__ 에서 __티켓__ 금액만큼을 차감한 후에 __매표소__ 에 금액을 증가시킨다.

4. 마지막으로 __공연장__ 은 __관람객__ 의 __가방__ 안에 __티켓__ 을 넣어줌으로써 __관람객__ 의 입장 절차를 끝낸다.

어떤가? 작성된 프로그램의 로직은 간단하고 예상대로 동작한다. 하지만 안타깝게도 이 작은 프로그램은 몇 가지 문제점을 가지고 있다.

---

#### 02. 무엇이 문제인가.

```
모든 소프트웨어 모듈에는 세 가지 목적이 있다.

첫 번째 : 실행중에 제대로 동작 하는 것이다. 이것은 모듈의 존재 이유라고 할 수 있다.

두 번째 : 소프트웨어 모듈은 변경을 위해 존재한다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.

세 번째 : 모듈의 세 번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통 할 수 없는 모듈은 개선해야 한다.

```

위 내용에 따르면 모듈은 __쉽게 실행__ 돼야 하고 __변경이 용이__ 해야 하며, __이해하기 쉬워야__ 한다.
앞에서 작성한 프로그램은 관람객을 입장시키는 데 필요한 기능을 오류없이 정확하게 수행한다. 따라서 제대로 동작해야 한다는 제약은 만족시킨다.

하지만 불행하게도 __변경 용이성__ 과 __읽는 사람과의 의사소통__ 이라는 목적은 만족시키지 못한다. 그 이유를 살펴보자.
<br><br>

#### 예상을 빗나가는 코드
마지막에 소개한 __Theater__ 클래스의 __etner()__ 메서드가 수행하는 일을 말로 풀어보자.

```
소극장은 관람객의 가방을 열어 그 안에 초대장이 들어있는지 살펴본다.

가방 안에 초대장이 들어있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.

가방 안에 초대장이 들어 있지 않다면 관람객의 가방에서 티켓 금액 만큼의 현금을 꺼내 매표소에 적립한 후에 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
```

무엇이 문제인지 눈치 챘다.
문제는 관람객과 판매원이 소극장의 통제를 받는 __수동적인 존재__ 라는 점이다.

관람객 입장에서 소극장이라는 제3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어본다?
판매원의 입장에서 소극장이 판매원의 허락도 없이 매표소에 보관 중인 티켓과 현금에 마음대로 접근한다?

확실히 뭔가 이상하다.

이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다. 안타깝게도 앞에서 살펴본 예제는 우리의 예상을 빗나간다.

현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다. 티켓을 구매하는 관람객은 가방 안에서 돈을 직접 꺼내 판매원에게 지불한다. 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에게서 직접 돈을 받아 매표소에 보관한다.
하지만 코드 안의 관람객, 판매원은 그렇게 하지 않는다. 현재의 코드는 우리의 상식과는 너무나도 다르게 동작하기 때문에 __코드를 읽는 사람과 제대로 의사소통 하지 못한다__

코드를 이해하기 어렵게 만드는 또 다른 이유가 있다. 이 코드를 이해하기 위해서는 여러가지 __세부적인 내용__ 들을 한꺼번에 기억하고 있어야 한다는 점이다.

앞의 __Theater__ 의 __etner()__ 메서드를 다시 살펴보자.

```javascript

public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) {
       Ticket ticket = ticketSeller.getTicketOffice().getTicket();
       audience.getBag().setTicket(ticket);
    } else {
        Ticket ticket = ticketSeller.getTicketOffice().getTicket();
        audience.getBag().minusAmount(ticket.getFee());
        ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
        audience.getBag().setTicket(ticket);
    }
}

```

제3자가 위 코드를 보고 이해하기 위해서는 __Audience__ 가 __Bag__ 을 가지고 있고, __Bag__ 안에는 현금과 티켓이 들어있으며 __TicketSeller__ 가 __TicketOffice__ 에서 티켓을 판매하고, __TicketOffice__ 안에 돈과 티켓이 보관돼 있다는 모든 사실을 동시에 기억하고 있어야 한다.

이 코드는 하나의 클래스나 메서드에서 __너무 많은 세부사항__ 을 다루기 때문에 코드를 작성하는 사람 뿐 아니라 코드를 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다.

하지만 가장 심각한 문제는 이것이 아니다. 그것은 __Audience__ 와 __TicketSeller__ 를 변경할 경우 __Theater__ 도 함께 변경해야 한다는 사실이다.

---

#### 변경에 취약한 코드

그렇다. 더 큰 문제는 __변경에 취약__ 하다는 것이다. 이 코드는 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다고 가정한다. 또한 판매원이 매표소에서만 티켓을 판매한다고 가정한다. 관람객이 가방을 들고 있지 않다면 어떻게 해야 할까? 관람객이 현금이 아니라 신용카드를 이용해서 결제해야 한다면 어떻게 해야 할까? 판매원이 매표소 밖에서 티켓을 판매해야 한다면 어떻게 해야 할까? 이런 가정이 꺠지는 순간 모든 코드가 일시에 흔들리게 된다.

관람객이 가방을 들고 있다는 가정이 바뀌었다고 상상해 보자 __Audience__ 클래스에서 __Bag__ 을 제거해야 할 뿐만 아니라 __Audience__ 의 __Bag__ 에 직접 접근하는 __Theater__ 의 __etner__ 메서드 역시 수정해야 한다.

__Theater__ 는 관람객이 가방을 들고 있고 판매원이 매표소에서만 티켓을 판매한다는 지나치게 세부적인 사실에 의존해서 동작한다. 이러한 __세부적인 사실 중 한 가지라도 바뀌면 해당 클래스 뿐만 아니라 이 클래스에 의존하는 Theater도 함꼐 변경__ 해야 한다. 이처럼 다른 클래스가 __Audience__ 내부에 대해 더 많이 알면 알수록 __Audience__ 를 변경하기 어려워진다.

이것은 객체 사이의 __의존성(Dependency)__ 와 관련된 문제다. 문제는 __의존성이 변경과 관련돼 있다는 점__ 이다.

__의존성은 변경에 대한 영향을 암시__ 한다. 의존성이라는 말 속에는 어떤 객체가 변경 될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

그렇다고 해서 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다. 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 따라서 우리의 목표는 애플리케이션의 기능을 구현하는데 필요한 __최소한의 의존성만 유지하고 불필요한 의존성을 제거__ 하는 것이다.

<img src="/assets/img/ClassDgrm.jpeg" width="100%" height="auto">

객체 사이의 의존성이 과한 경우를 가리켜 __결합도(coupling)__ 가 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.

__결합도는 의존성과 관련__ 돼 있기 때문에 결합도 역시 변경과 관련이 있다. 두 객체 사이의 결합도가 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다. 따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다.

---

### 03. 설계 개선하기

예제 코드는 세 가지 목적 중 한 가지는 만족시키지만 다른 두 조건은 만족시키지 못한다. 이 코드는 기능은 제대로 수행하지만 __이해하기 어렵고 변경하기가 쉽지 않다.__

여기서 변경과 의사소통이라는 문제가 __서로 엮여있음__ 에 주목하라. 코드를 이해하기 어려운 이유는 __Theater__ 가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. 이것은 관람객과 판매원이 __자신의 일을 스스로 처리해야 한다__ 는 우리의 직관을 벗어난다. 다시 말해서 의도를 정확하게 의사소통 하지 못하기 때문에 코드가 이해하기 어려워진 것이다.

__Theater__ 가 관람객의 가방과 판매원의 매표소에 직접 접근한다는 것은 __Theater__ 가 __Audience__ 와 __TicketSeller__ 에 __결합__  다는 것을 의미한다. 따라서 __Audience__ 와 __TicketSeller__ 를 변경할 때 __Theater__ 도 함꼐 변경해야 하기 때문에 전체적으로 코드를 변경하기도 어려워진다.

해결 방법은 간단하다. __Theater__ 가 __Audience__ 와 __TicketSeller__ 에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다. 사실 관람객이 가방을 가지고 있다는 사실과 판매원이 매표소에서 티켓을 파냄한다는 사실을 __Theater__ 가 알아야 할 필요가 없다. __Theater__ 가 원하는 것은 관람객이 소극장에 입장하는 것 뿐이다. 따라서 관람객이 스스로 가방 안의 현금과 초대장을 처리하고 판매원이 스스로 매표소의 티켓과 판매 요금을 다루게 한다면 이 모든 문제를 한 번에 해결할 수 있을 것이다.

다시말해서 관람객과 판매원을 __자율적인 존재__ 로 만들면 되는 것이다.

#### 자율성을 높이자.

설계를 변경하기 어려운 이유는 __Theater__ 가 __Audience__ 와 __TicketSeller__ 뿐 아니라 __Audience__ 소유의 __Bag__ 과 __TicketSeller__ 가 근무하는 __TicketOffice__ 까지 마음대로 접근할 수 있기 때문이다.

해결 방법은 __Audience__ 와 __TicketSeller__ 가 직접 __Bag__ 과 __TicketOffice__ 를 처리하는 __자율적인 존재__ 가 되도록 설계를 변경하는 것이다.

첫 번째 단계는 __Theater__ 의 __enter()__ 메서드에서 __TicketOffice__ 에 접근하는 모든 코드를 __TicketSeller__ 내부로 숨기는 것이다.
__TicketSeller__ 에 __sellTo()__ 메서드를 추가하고 __Theater__ 에 있던 로직을 이 메서드로 옮기자.














### 참고 및 출처
  - 오브젝트
