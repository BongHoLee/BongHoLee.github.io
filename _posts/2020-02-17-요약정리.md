---
layout: post
title: 요약 정리
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 들어가며

각 책의 챕터를 공부하며 옮겨쓰기 방식의 블로깅을 하고있다. 게시된 글 들은 시간이 많다면 찬찬히 읽어보며 복기하는게 목적이다.

반면 여기 작성된 `요약 정리`는 실무 개발을 진행하면서 내가 꼭 기억해야 할 내용들을 한 눈에 보기 위해 작성한다.

---

## 바람직한 의존성 (8장 의존성 관리)

`의존성`은 `변경`과 관련이 깊다. 의존하는 대상(**_의존 객체_**)이 변경 될 경우 함께 변경 될 가능성이 바로 `의존성`이다.

객체간의 협력을 설계하는데 있어 `의존성`은 반드시 필요하다. 하지만 너무 `구체적이고 과한 의존성`은 오히려 해가된다.

이렇게 `구체적이고 과한 의존성`을 일컬어 `높은 결합도`라고도 표현한다.

그렇다면 `바람직한 의존성`이란 무엇일까?

> 바람직한 의존성이란 다양한 컨텍스트에서 재사용 가능한 의존성을 의미한다.

다시말하면 `컨텍스트에 독립적`인 의존성을 의미한다. 그리고 `컨텍스트에 독립적`인 의존성을 얻기 위해서는 고려해야 할 점들이 있다.

> 1. 컴파일타임 의존성과 런타임 의존성을 다르게 설계한다.

`컴파일타임 의존성`은 `클래스`들의 의존성이고 `런타임 의존성`은 `객체`들간의 의존성이다. 두 의존성을 다르게 하기 위해서는 `추상화에 의존`해야 한다. 만일 구체적인 클래스에 의존하게 된다면 해당 클래스가 지니고 있는 구체적인 컨텍스트에 결합되게 되고 이는 결국 `높은 결합도`로 이어지게 된다.

생각해보면 간단하다. 의존하는 객체가 구체적인 클래스라면 클라이언트 객체는 구체적인 클래스의 인스턴스에게 메시지를 보낼 수밖에 없다. 해당 클래스의 인스턴스 외에는 협력이 어려워진다. 반면에 구체적인 클래스가 아니라 `추상화(추상클래스, 인터페이스)`에 의존하게 된다면 런타임에 `주입된 객체`에 따라 `다양한 컨텍스트`에서 재사용이 가능하다. 다시말해 **_구체적인 클래스가 아닌 다양한 클래스의 인스턴스와 협력이 가능하다._**

> 2. 퍼블릭 인터페이스(생성자, Setter)에 의존성을 명시적으로 표현한다.

구체 클래스가 아닌 `추상화`에 의존하는 것이 첫 걸음이라면 그 다음엔 해당 `추상화를 런타임에 구체적인 객체로 의존성을 변경(동적 바인딩)`시키기 위하여 퍼블릭 인터페이스에 의존성을 명시적으로 표현해야한다. 즉, `의존성 주입`이 필요한 것이다. 만일 클래스 내부에서 의존 객체를 직접 `new` 연산자를 이용하여 바인딩 한다면 이는 구체 클래스에 의존하는 것과 다름이 없다.

> 3. 생성과 사용의 책임을 분리한다.

생성과 사용의 책임을 분리하는 것은 `의존성을 명시적으로 표현`하는 것과 관련이 있다. 추상화에 의존한다면 의존 객체를 사용하는 클라이언트 객체는 의존 객체를 직접 생성해서는 안된다.

---

## 추상화 (9장 유연한 설계)

`개방-폐쇄 원칙`의 핵심은 `추상화에 의존하는 것`이다.

> 추상화란 '공통적'이고 핵심적인 부분만을 남기고 '세부적'이고 불필요한 부분을 생략함으로써 '복잡성을 극복'하는 기법이다.

따라서 `추상화` 과정을 거치면 **_문맥이 바뀌더라도 변하지 않는 공통적인 부분만 남게되고 문맥에 따라 변하는 세부적인 부분은 생략된다._**

`추상화`를 사용하면 **_생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다._**

`개방-폐쇄 원칙`의 관점에서 `생략되지 않고 남겨지는 공통적인 부분`은 다양한 상황(다양한 컨텍스트)에서의 `공통점을 반영`한 추상화의 결과물이다. **_공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다._** 다시말해서 수정할 필요가 없어야 한다. 따라서 **_추상화 부분은 수정에 대해 닫혀있다._**

**_추상화를 통해 생략된 부분은 확장의 여지를 남긴다._** 이것이 `추상화`가 `개방-폐쇄 원칙`을 가능하게 만드는 이유다.

`변하는 부분은 생략`하고 `변하지 않는 부분은 고정`하는 추상화 메커니즘이 `개방-폐쇄 원칙`의 기반이 된다.

> 추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다.

> 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

> 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분은 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.

유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 `객체를 생성하는 책임`과 `객체를 사용하는 책임`을 서로 분리해야 한다. 한 마디로 말해서 객체에 대한 `생성과 사용을 분리`해야 한다. 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 `객체를 생성할 책임을 클라이언트로 옮기는 것이다.`

또한 **_객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가할 수 있다._** 이처럼 `생성과 사용을 분리`하기 위해 `객체 생성에 특화된 객체를 FACTORY`라고 부른다.

 **_종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다._** 도메인 모델은 설계를 위한 중요한 출발점이지만 `단지 출발점`이라는 사실을 명심해야 한다. 실제로 동작하는 애플리케이션은 `데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념들을 필요`로 할 수 있다.

 >모든 책임을 도메인 객체에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제에 봉착하게 될 가능성이 높아진다.

 이 경우 도메인 개념을 표현한 객체가 아닌 `설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결`해야 한다.

 `의존성`은 명시적으로 드러내야 한다. `SERVICE LOCATOR` 패턴과 같이 의존성을 암시적으로 구현 내부의 깊숙한 곳에 숨겨둔다면 의존성과 관련된 문제가 `컴파일 타임이 아닌 런타임에 가서야 발견`된다는 사실을 알 수 있다. **_숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다._**

 `의존성 역전 원칙`과 관련하여 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 `상위 수준의 정책`이다. `Movie`와 `AmountDiscountPolicy` 사이의 협력이 가지는 본질은 `영화의 가격을 계산`하는 것이다. 어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다. 다시 말해서 **_어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스(Movie) 이다._**

 따라서 `상위 클래스`와 `하위 클래스` 모두 `추상화에 의존`해야 한다.

 > 가장 중요한 조언은 추상화에 의존하라는 것이다. 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.

---

### 중복 코드(10장 상속과 중복 코드)

> 중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.

**_중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다._**

모든 중복코드를 개별적으로 테스트해서 동일한 결과를 내놓는지 확인해야만 한다. 즉, **_중복 코드는 수정과 테스트에 드는 비용을 증가시킬 뿐 아니라 시스템과 개발자를 공황상태로 몰아넣는다._**

> 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면(의존성과 상관 없이) 이 코드는 중복이다. 함께 수정할 필요가 없다면 중복이 아니다. 중복 코드를 결정하는 기준은 코드의 모양이 아니다. 모양이 유사하다는 것은 단지 중복의 징후일 뿐이다. 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.

더 큰 문제는 `중복 코드를 서로 다르게 수정할 가능성이 크다는 것이다.` 중복 코드를 판별하고 변경에 따라 동일하게 수정하기 위해서는 하나하나 수정하는 수 밖에 없다. 이 과정에서 `휴면 에러`와 같이 서로 다르게 수정 할 가능성이 높다.

또한 `중복 코드는 새로운 중복 코드를 부른다.` 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 새로운 중복 코드를 추가하는 것이다.

### 타입 코드(10장 상속과 중복 코드)

**_중복 코드를 제거하기 위해 타입 코드를 추가하고 타입 코드 값에 따라 로직을 분기하여 중복을 제거할 수 있다. 하지만 타입 코드는 높은 결합도와 낮은 응집도 문제에 시달릴 수 있다._**

`객체지향` 프로그래밍 언어는 타입 코드를 사용하지 않고도 중복 코드를 관리할 수 있는 효과적인 방법을 제공한다. `상속`이 바로 그것이다.


### 상속과 결합도 (10장 상속과 중복 코드)

하지만 `상속`을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용 하는 것은 생각처럼 쉽지 않다. 개발자는 `재사용`을 위해 상속 계층 사이에 무수히 많은 `가정`을 세웠을지도 모른다. 그리고 그 가정은 코드를 이해하기 어렵게 만들 뿐 아니라 직관에도 어긋날 수 있다.

다시말해 **_상속을 이용하여 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다._** 이것은 `자식 클래스 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 함`을 의미한다.

따라서 `상속은 결합도를 높인다.` 그리고 이러한 결합도로 인해 **_코드 중복을 제거하기 위해 상속을 사용했음에도 로직을 추가하기 위해 새로운 중복 코드가 만들어지는 경우가 허다하다._**

특히나 이러한 결합은 `자식 클래스에서 super 참조로 부모 클래스의 메서드를 직접 호출할 때` 자주 보인다.

> 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

위와 같은 내용은 자식 클래스가 부모 클래스의 구현에 강하게 결합될 경우 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는다는 사실을 잘 보여준다.

이처럼 **_상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 부른다._** 취약한 기반 클래스 문제는 코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제다.

### 취약한 기반 클래스 문제 (10장 상속과 중복 코드)

**_상속은 자식 클래스와 부모 클래스의 결합도를 높인다._**

자식 클래스는 부모 클래스의 불필요한 세부 사항에 엮이게 된다. 부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 런타임 에러라는 고통에 시달려야 할 수도 있다.

이 문제는 상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.

**_취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다._** 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고있어야 한다. 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는데는 용이하지만 **_높은 결합도로 인해 부모클래스를 점진적으로 개선하는 것은 어렵게 만든다._**

**_취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다._** 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다. 이것이 상속이 위험한 이유인 동시에 상속을 피해야 하는 첫 번째 이유다.

> 객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화 할 수 있기 때문이다. 캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다. 객체는 변경될지도 모르는 불안정한 요소를 캡슐화 함으로써 파급효과를 걱정하지 않고도 자유롭게 내부를 변경할 수 있다.

안타깝게도 `상속`을 사용하면 부모 클래스의 `퍼블릭 인터페이스`가 아닌 `구현`을 변경할지라도 자식 클래스가 영향을 받기 쉬워진다.

> 객체지향의 기반은 캡슐화를 통한 변경의 통제다. 상속은 코드 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다. 














### 참고 및 출처
  - 오브젝트
