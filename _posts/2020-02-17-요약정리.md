---
layout: post
title: 요약 정리
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 들어가며

각 책의 챕터를 공부하며 옮겨쓰기 방식의 블로깅을 하고있다. 게시된 글 들은 시간이 많다면 찬찬히 읽어보며 복기하는게 목적이다.

반면 여기 작성된 `요약 정리`는 실무 개발을 진행하면서 내가 꼭 기억해야 할 내용들을 한 눈에 보기 위해 작성한다.

---

## 바람직한 의존성 (8장 의존성 관리)

`의존성`은 `변경`과 관련이 깊다. 의존하는 대상(**_의존 객체_**)이 변경 될 경우 함께 변경 될 가능성이 바로 `의존성`이다.

객체간의 협력을 설계하는데 있어 `의존성`은 반드시 필요하다. 하지만 너무 `구체적이고 과한 의존성`은 오히려 해가된다.

이렇게 `구체적이고 과한 의존성`을 일컬어 `높은 결합도`라고도 표현한다.

그렇다면 `바람직한 의존성`이란 무엇일까?

> 바람직한 의존성이란 다양한 컨텍스트에서 재사용 가능한 의존성을 의미한다.

다시말하면 `컨텍스트에 독립적`인 의존성을 의미한다. 그리고 `컨텍스트에 독립적`인 의존성을 얻기 위해서는 고려해야 할 점들이 있다.

> 1. 컴파일타임 의존성과 런타임 의존성을 다르게 설계한다.

`컴파일타임 의존성`은 `클래스`들의 의존성이고 `런타임 의존성`은 `객체`들간의 의존성이다. 두 의존성을 다르게 하기 위해서는 `추상화에 의존`해야 한다. 만일 구체적인 클래스에 의존하게 된다면 해당 클래스가 지니고 있는 구체적인 컨텍스트에 결합되게 되고 이는 결국 `높은 결합도`로 이어지게 된다.

생각해보면 간단하다. 의존하는 객체가 구체적인 클래스라면 클라이언트 객체는 구체적인 클래스의 인스턴스에게 메시지를 보낼 수밖에 없다. 해당 클래스의 인스턴스 외에는 협력이 어려워진다. 반면에 구체적인 클래스가 아니라 `추상화(추상클래스, 인터페이스)`에 의존하게 된다면 런타임에 `주입된 객체`에 따라 `다양한 컨텍스트`에서 재사용이 가능하다. 다시말해 **_구체적인 클래스가 아닌 다양한 클래스의 인스턴스와 협력이 가능하다._**

> 2. 퍼블릭 인터페이스(생성자, Setter)에 의존성을 명시적으로 표현한다.

구체 클래스가 아닌 `추상화`에 의존하는 것이 첫 걸음이라면 그 다음엔 해당 `추상화를 런타임에 구체적인 객체로 의존성을 변경(동적 바인딩)`시키기 위하여 퍼블릭 인터페이스에 의존성을 명시적으로 표현해야한다. 즉, `의존성 주입`이 필요한 것이다. 만일 클래스 내부에서 의존 객체를 직접 `new` 연산자를 이용하여 바인딩 한다면 이는 구체 클래스에 의존하는 것과 다름이 없다.

> 3. 생성과 사용의 책임을 분리한다.

생성과 사용의 책임을 분리하는 것은 `의존성을 명시적으로 표현`하는 것과 관련이 있다. 추상화에 의존한다면 의존 객체를 사용하는 클라이언트 객체는 의존 객체를 직접 생성해서는 안된다.

---

## 추상화 (9장 유연한 설계)

`개방-폐쇄 원칙`의 핵심은 `추상화에 의존하는 것`이다.

> 추상화란 '공통적'이고 핵심적인 부분만을 남기고 '세부적'이고 불필요한 부분을 생략함으로써 '복잡성을 극복'하는 기법이다.

따라서 `추상화` 과정을 거치면 **_문맥이 바뀌더라도 변하지 않는 공통적인 부분만 남게되고 문맥에 따라 변하는 세부적인 부분은 생략된다._**

`추상화`를 사용하면 **_생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다._**

`개방-폐쇄 원칙`의 관점에서 `생략되지 않고 남겨지는 공통적인 부분`은 다양한 상황(다양한 컨텍스트)에서의 `공통점을 반영`한 추상화의 결과물이다. **_공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다._** 다시말해서 수정할 필요가 없어야 한다. 따라서 **_추상화 부분은 수정에 대해 닫혀있다._**

**_추상화를 통해 생략된 부분은 확장의 여지를 남긴다._** 이것이 `추상화`가 `개방-폐쇄 원칙`을 가능하게 만드는 이유다.

`변하는 부분은 생략`하고 `변하지 않는 부분은 고정`하는 추상화 메커니즘이 `개방-폐쇄 원칙`의 기반이 된다.

> 추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다.

> 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

> 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분은 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.

유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 `객체를 생성하는 책임`과 `객체를 사용하는 책임`을 서로 분리해야 한다. 한 마디로 말해서 객체에 대한 `생성과 사용을 분리`해야 한다. 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 `객체를 생성할 책임을 클라이언트로 옮기는 것이다.`

또한 **_객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가할 수 있다._** 이처럼 `생성과 사용을 분리`하기 위해 `객체 생성에 특화된 객체를 FACTORY`라고 부른다.

 **_종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다._** 도메인 모델은 설계를 위한 중요한 출발점이지만 `단지 출발점`이라는 사실을 명심해야 한다. 실제로 동작하는 애플리케이션은 `데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념들을 필요`로 할 수 있다.

 >모든 책임을 도메인 객체에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제에 봉착하게 될 가능성이 높아진다.

 이 경우 도메인 개념을 표현한 객체가 아닌 `설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결`해야 한다.

 `의존성`은 명시적으로 드러내야 한다. `SERVICE LOCATOR` 패턴과 같이 의존성을 암시적으로 구현 내부의 깊숙한 곳에 숨겨둔다면 의존성과 관련된 문제가 `컴파일 타임이 아닌 런타임에 가서야 발견`된다는 사실을 알 수 있다. **_숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다._**

 `의존성 역전 원칙`과 관련하여 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 `상위 수준의 정책`이다. `Movie`와 `AmountDiscountPolicy` 사이의 협력이 가지는 본질은 `영화의 가격을 계산`하는 것이다. 어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다. 다시 말해서 **_어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스(Movie) 이다._**

 따라서 `상위 클래스`와 `하위 클래스` 모두 `추상화에 의존`해야 한다.

 > 가장 중요한 조언은 추상화에 의존하라는 것이다. 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.

---

### 중복 코드(10장 상속과 중복 코드)

> 중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.

**_중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다._**

모든 중복코드를 개별적으로 테스트해서 동일한 결과를 내놓는지 확인해야만 한다. 즉, **_중복 코드는 수정과 테스트에 드는 비용을 증가시킬 뿐 아니라 시스템과 개발자를 공황상태로 몰아넣는다._**

> 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면(의존성과 상관 없이) 이 코드는 중복이다. 함께 수정할 필요가 없다면 중복이 아니다. 중복 코드를 결정하는 기준은 코드의 모양이 아니다. 모양이 유사하다는 것은 단지 중복의 징후일 뿐이다. 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.

더 큰 문제는 `중복 코드를 서로 다르게 수정할 가능성이 크다는 것이다.` 중복 코드를 판별하고 변경에 따라 동일하게 수정하기 위해서는 하나하나 수정하는 수 밖에 없다. 이 과정에서 `휴면 에러`와 같이 서로 다르게 수정 할 가능성이 높다.

또한 `중복 코드는 새로운 중복 코드를 부른다.` 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 새로운 중복 코드를 추가하는 것이다.

### 타입 코드(10장 상속과 중복 코드)

**_중복 코드를 제거하기 위해 타입 코드를 추가하고 타입 코드 값에 따라 로직을 분기하여 중복을 제거할 수 있다. 하지만 타입 코드는 높은 결합도와 낮은 응집도 문제에 시달릴 수 있다._**

`객체지향` 프로그래밍 언어는 타입 코드를 사용하지 않고도 중복 코드를 관리할 수 있는 효과적인 방법을 제공한다. `상속`이 바로 그것이다.


### 상속과 결합도 (10장 상속과 중복 코드)

하지만 `상속`을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용 하는 것은 생각처럼 쉽지 않다. 개발자는 `재사용`을 위해 상속 계층 사이에 무수히 많은 `가정`을 세웠을지도 모른다. 그리고 그 가정은 코드를 이해하기 어렵게 만들 뿐 아니라 직관에도 어긋날 수 있다.

다시말해 **_상속을 이용하여 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다._** 이것은 `자식 클래스 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 함`을 의미한다.

따라서 `상속은 결합도를 높인다.` 그리고 이러한 결합도로 인해 **_코드 중복을 제거하기 위해 상속을 사용했음에도 로직을 추가하기 위해 새로운 중복 코드가 만들어지는 경우가 허다하다._**

특히나 이러한 결합은 `자식 클래스에서 super 참조로 부모 클래스의 메서드를 직접 호출할 때` 자주 보인다.

> 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

위와 같은 내용은 자식 클래스가 부모 클래스의 구현에 강하게 결합될 경우 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는다는 사실을 잘 보여준다.

이처럼 **_상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 부른다._** 취약한 기반 클래스 문제는 코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제다.

### 취약한 기반 클래스 문제 (10장 상속과 중복 코드)

**_상속은 자식 클래스와 부모 클래스의 결합도를 높인다._**

자식 클래스는 부모 클래스의 불필요한 세부 사항에 엮이게 된다. 부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 런타임 에러라는 고통에 시달려야 할 수도 있다.

이 문제는 상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.

**_취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다._** 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고있어야 한다. 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는데는 용이하지만 **_높은 결합도로 인해 부모클래스를 점진적으로 개선하는 것은 어렵게 만든다._**

**_취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다._** 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다. 이것이 상속이 위험한 이유인 동시에 상속을 피해야 하는 첫 번째 이유다.

> 객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화 할 수 있기 때문이다. 캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다. 객체는 변경될지도 모르는 불안정한 요소를 캡슐화 함으로써 파급효과를 걱정하지 않고도 자유롭게 내부를 변경할 수 있다.

안타깝게도 `상속`을 사용하면 부모 클래스의 `퍼블릭 인터페이스`가 아닌 `구현`을 변경할지라도 자식 클래스가 영향을 받기 쉬워진다.

> 객체지향의 기반은 캡슐화를 통한 변경의 통제다. 상속은 코드 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.

퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 이용하는 것은 위험하다. 객체지향의 핵심은 객체들의 협력이다. **_단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 포함되도록 해서는 안된다._**

> 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다. (Stack과 Properties를 기억하라.)

### 메서드 오버라이딩 오작용 문제 (10장 상속과 중복 코드)

> 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

예를 들면 부모 클래스의 특정 메서드를 오버라이딩 했는데 부모 클래스의 특정 오퍼레이션이 해당 메서드를 호출(메시지 전송) 하는 경우, 자식 클래스 개발자는 오버라이딩 시 해당 부분까지 파악하지 못한다면 (부모 클래스의 내부 구현을 자세하게 알지 못한다면) 기대하는 것과 다르게 작동할 수 있다. (`InstrumentedHashSet 사용 문제를 기억`)

> 메서드 오버라이딩으로 인한 파급 효과를 분명하게 문서화 해야한다. 달리말해 오버라이딩 가능한 메서드들의 자체 사용(self-use), 즉, 오버라이딩 하려는 메서드들이 같은 클래스의 다른 메서드를 호출하거나 호출받는지에 대해 반드시 문서화 해야한다. 더 일반적으로 말하면 오버라이딩 하려는 메서드를 호출할 수 있는 어떤 상황에 대해서도 문서화 해야한다는 것이다.

`설계는 트레이드 오프 활동`이라는 사실을 기억하라. **_상속은 코드 재사용을 위해 캡슐화를 희생한다._** 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야 한다.

### 부모 클래스와 자식 클래스 동시 수정 문제 (10장 상속과 중복 코드)

자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도 부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있다. 상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문에 이 문제를 피하기는 어렵다.

`결합도`란 다른 대상에 대해 알고 있는 지식의 양이다. 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다. 따라서 **_코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 함께 수정해야 하는 상황 역시 빈번하게 발생할 수 밖에 없다._**

> 서브 클래스는 올바른 기능을 위해 슈퍼 클래스의 세부적인 구현에 의존한다. 슈퍼 클래스의 구현은 릴리스를 거치면서 변경될 수 있고, 그에 따라 서브클래스의 코드를 변경하지 않더라도 깨질 수 있다. 결과적으로 슈퍼클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야 한다.(함께 수정되어야 한다.)

> 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

`취약한 기반 클래스 문제`를 완전히 없앨 수는 없지만 어느 정도 까지 위험을 완화시키는 것은 가능하다. 문제 해결의 열쇠는 바로 `추상화`다.

### 추상화에 의존하자 (10장 상속과 중복 코드)

문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 `추상화`에 의존하도록 만드는 것이다. 정확하게 말하면 **_부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다._**

개인적으로 `코드 중복 제거`를 위해 상속을 도입할 때 따르는 두 가지 원칙이 있다.

- 두 메서드가 유사하게 보인다면 `차이점`을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.

- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것 보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.











### 참고 및 출처
  - 오브젝트
