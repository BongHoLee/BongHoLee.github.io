---
layout: post
title: 요약 정리
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 들어가며

각 책의 챕터를 공부하며 옮겨쓰기 방식의 블로깅을 하고있다. 게시된 글 들은 시간이 많다면 찬찬히 읽어보며 복기하는게 목적이다.

반면 여기 작성된 `요약 정리`는 실무 개발을 진행하면서 내가 꼭 기억해야 할 내용들을 한 눈에 보기 위해 작성한다.

---

## 바람직한 의존성 (8장 의존성 관리)

`의존성`은 `변경`과 관련이 깊다. 의존하는 대상(**_의존 객체_**)이 변경 될 경우 함께 변경 될 가능성이 바로 `의존성`이다.

객체간의 협력을 설계하는데 있어 `의존성`은 반드시 필요하다. 하지만 너무 `구체적이고 과한 의존성`은 오히려 해가된다.

이렇게 `구체적이고 과한 의존성`을 일컬어 `높은 결합도`라고도 표현한다.

그렇다면 `바람직한 의존성`이란 무엇일까?

> 바람직한 의존성이란 다양한 컨텍스트에서 재사용 가능한 의존성을 의미한다.

다시말하면 `컨텍스트에 독립적`인 의존성을 의미한다. 그리고 `컨텍스트에 독립적`인 의존성을 얻기 위해서는 고려해야 할 점들이 있다.

> 1. 컴파일타임 의존성과 런타임 의존성을 다르게 설계한다.

`컴파일타임 의존성`은 `클래스`들의 의존성이고 `런타임 의존성`은 `객체`들간의 의존성이다. 두 의존성을 다르게 하기 위해서는 `추상화에 의존`해야 한다. 만일 구체적인 클래스에 의존하게 된다면 해당 클래스가 지니고 있는 구체적인 컨텍스트에 결합되게 되고 이는 결국 `높은 결합도`로 이어지게 된다.

생각해보면 간단하다. 의존하는 객체가 구체적인 클래스라면 클라이언트 객체는 구체적인 클래스의 인스턴스에게 메시지를 보낼 수밖에 없다. 해당 클래스의 인스턴스 외에는 협력이 어려워진다. 반면에 구체적인 클래스가 아니라 `추상화(추상클래스, 인터페이스)`에 의존하게 된다면 런타임에 `주입된 객체`에 따라 `다양한 컨텍스트`에서 재사용이 가능하다. 다시말해 **_구체적인 클래스가 아닌 다양한 클래스의 인스턴스와 협력이 가능하다._**

> 2. 퍼블릭 인터페이스(생성자, Setter)에 의존성을 명시적으로 표현한다.

구체 클래스가 아닌 `추상화`에 의존하는 것이 첫 걸음이라면 그 다음엔 해당 `추상화를 런타임에 구체적인 객체로 의존성을 변경(동적 바인딩)`시키기 위하여 퍼블릭 인터페이스에 의존성을 명시적으로 표현해야한다. 즉, `의존성 주입`이 필요한 것이다. 만일 클래스 내부에서 의존 객체를 직접 `new` 연산자를 이용하여 바인딩 한다면 이는 구체 클래스에 의존하는 것과 다름이 없다.

> 3. 생성과 사용의 책임을 분리한다.

생성과 사용의 책임을 분리하는 것은 `의존성을 명시적으로 표현`하는 것과 관련이 있다. 추상화에 의존한다면 의존 객체를 사용하는 클라이언트 객체는 의존 객체를 직접 생성해서는 안된다.

---

## 추상화 (9장 유연한 설계)

`개방-폐쇄 원칙`의 핵심은 `추상화에 의존하는 것`이다.

> 추상화란 '공통적'이고 핵심적인 부분만을 남기고 '세부적'이고 불필요한 부분을 생략함으로써 '복잡성을 극복'하는 기법이다.

따라서 `추상화` 과정을 거치면 **_문맥이 바뀌더라도 변하지 않는 공통적인 부분만 남게되고 문맥에 따라 변하는 세부적인 부분은 생략된다._**

`추상화`를 사용하면 **_생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다._**

`개방-폐쇄 원칙`의 관점에서 `생략되지 않고 남겨지는 공통적인 부분`은 다양한 상황(다양한 컨텍스트)에서의 `공통점을 반영`한 추상화의 결과물이다. **_공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다._** 다시말해서 수정할 필요가 없어야 한다. 따라서 **_추상화 부분은 수정에 대해 닫혀있다._**

**_추상화를 통해 생략된 부분은 확장의 여지를 남긴다._** 이것이 `추상화`가 `개방-폐쇄 원칙`을 가능하게 만드는 이유다.

`변하는 부분은 생략`하고 `변하지 않는 부분은 고정`하는 추상화 메커니즘이 `개방-폐쇄 원칙`의 기반이 된다.

> 추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다.

> 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

> 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분은 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.

유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 `객체를 생성하는 책임`과 `객체를 사용하는 책임`을 서로 분리해야 한다. 한 마디로 말해서 객체에 대한 `생성과 사용을 분리`해야 한다. 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 `객체를 생성할 책임을 클라이언트로 옮기는 것이다.`



---













### 참고 및 출처
  - 오브젝트
