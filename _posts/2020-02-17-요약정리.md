---
layout: post
title: 요약 정리
author: Bong5
categories: [Java, Books/Object]
---

## 오브젝트

## 들어가며

각 책의 챕터를 공부하며 옮겨쓰기 방식의 블로깅을 하고있다. 게시된 글 들은 시간이 많다면 찬찬히 읽어보며 복기하는게 목적이다.

반면 여기 작성된 `요약 정리`는 실무 개발을 진행하면서 내가 꼭 기억해야 할 내용들을 한 눈에 보기 위해 작성한다.

---

## 바람직한 의존성 (8장 의존성 관리)

`의존성`은 `변경`과 관련이 깊다. 의존하는 대상(**_의존 객체_**)이 변경 될 경우 함께 변경 될 가능성이 바로 `의존성`이다.

객체간의 협력을 설계하는데 있어 `의존성`은 반드시 필요하다. 하지만 너무 `구체적이고 과한 의존성`은 오히려 해가된다.

이렇게 `구체적이고 과한 의존성`을 일컬어 `높은 결합도`라고도 표현한다.

그렇다면 `바람직한 의존성`이란 무엇일까?

> 바람직한 의존성이란 다양한 컨텍스트에서 재사용 가능한 의존성을 의미한다.

다시말하면 `컨텍스트에 독립적`인 의존성을 의미한다. 그리고 `컨텍스트에 독립적`인 의존성을 얻기 위해서는 고려해야 할 점들이 있다.

> 1. 컴파일타임 의존성과 런타임 의존성을 다르게 설계한다.

`컴파일타임 의존성`은 `클래스`들의 의존성이고 `런타임 의존성`은 `객체`들간의 의존성이다. 두 의존성을 다르게 하기 위해서는 `추상화에 의존`해야 한다. 만일 구체적인 클래스에 의존하게 된다면 해당 클래스가 지니고 있는 구체적인 컨텍스트에 결합되게 되고 이는 결국 `높은 결합도`로 이어지게 된다.

생각해보면 간단하다. 의존하는 객체가 구체적인 클래스라면 클라이언트 객체는 구체적인 클래스의 인스턴스에게 메시지를 보낼 수밖에 없다. 해당 클래스의 인스턴스 외에는 협력이 어려워진다. 반면에 구체적인 클래스가 아니라 `추상화(추상클래스, 인터페이스)`에 의존하게 된다면 런타임에 `주입된 객체`에 따라 `다양한 컨텍스트`에서 재사용이 가능하다. 다시말해 **_구체적인 클래스가 아닌 다양한 클래스의 인스턴스와 협력이 가능하다._**

> 2. 퍼블릭 인터페이스(생성자, Setter)에 의존성을 명시적으로 표현한다.

구체 클래스가 아닌 `추상화`에 의존하는 것이 첫 걸음이라면 그 다음엔 해당 `추상화를 런타임에 구체적인 객체로 의존성을 변경(동적 바인딩)`시키기 위하여 퍼블릭 인터페이스에 의존성을 명시적으로 표현해야한다. 즉, `의존성 주입`이 필요한 것이다. 만일 클래스 내부에서 의존 객체를 직접 `new` 연산자를 이용하여 바인딩 한다면 이는 구체 클래스에 의존하는 것과 다름이 없다.

> 3. 생성과 사용의 책임을 분리한다.

생성과 사용의 책임을 분리하는 것은 `의존성을 명시적으로 표현`하는 것과 관련이 있다. 추상화에 의존한다면 의존 객체를 사용하는 클라이언트 객체는 의존 객체를 직접 생성해서는 안된다.

---

## 추상화 (9장 유연한 설계)

`개방-폐쇄 원칙`의 핵심은 `추상화에 의존하는 것`이다.

> 추상화란 '공통적'이고 핵심적인 부분만을 남기고 '세부적'이고 불필요한 부분을 생략함으로써 '복잡성을 극복'하는 기법이다.

따라서 `추상화` 과정을 거치면 **_문맥이 바뀌더라도 변하지 않는 공통적인 부분만 남게되고 문맥에 따라 변하는 세부적인 부분은 생략된다._**

`추상화`를 사용하면 **_생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다._**

`개방-폐쇄 원칙`의 관점에서 `생략되지 않고 남겨지는 공통적인 부분`은 다양한 상황(다양한 컨텍스트)에서의 `공통점을 반영`한 추상화의 결과물이다. **_공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다._** 다시말해서 수정할 필요가 없어야 한다. 따라서 **_추상화 부분은 수정에 대해 닫혀있다._**

**_추상화를 통해 생략된 부분은 확장의 여지를 남긴다._** 이것이 `추상화`가 `개방-폐쇄 원칙`을 가능하게 만드는 이유다.

`변하는 부분은 생략`하고 `변하지 않는 부분은 고정`하는 추상화 메커니즘이 `개방-폐쇄 원칙`의 기반이 된다.

> 추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다.

> 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

> 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분은 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.

유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 `객체를 생성하는 책임`과 `객체를 사용하는 책임`을 서로 분리해야 한다. 한 마디로 말해서 객체에 대한 `생성과 사용을 분리`해야 한다. 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 `객체를 생성할 책임을 클라이언트로 옮기는 것이다.`

또한 **_객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가할 수 있다._** 이처럼 `생성과 사용을 분리`하기 위해 `객체 생성에 특화된 객체를 FACTORY`라고 부른다.

 **_종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다._** 도메인 모델은 설계를 위한 중요한 출발점이지만 `단지 출발점`이라는 사실을 명심해야 한다. 실제로 동작하는 애플리케이션은 `데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념들을 필요`로 할 수 있다.

 >모든 책임을 도메인 객체에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제에 봉착하게 될 가능성이 높아진다.

 이 경우 도메인 개념을 표현한 객체가 아닌 `설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결`해야 한다.

 `의존성`은 명시적으로 드러내야 한다. `SERVICE LOCATOR` 패턴과 같이 의존성을 암시적으로 구현 내부의 깊숙한 곳에 숨겨둔다면 의존성과 관련된 문제가 `컴파일 타임이 아닌 런타임에 가서야 발견`된다는 사실을 알 수 있다. **_숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다._**

 `의존성 역전 원칙`과 관련하여 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 `상위 수준의 정책`이다. `Movie`와 `AmountDiscountPolicy` 사이의 협력이 가지는 본질은 `영화의 가격을 계산`하는 것이다. 어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다. 다시 말해서 **_어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스(Movie) 이다._**

 따라서 `상위 클래스`와 `하위 클래스` 모두 `추상화에 의존`해야 한다.

 > 가장 중요한 조언은 추상화에 의존하라는 것이다. 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.

---

### 중복 코드(10장 상속과 중복 코드)

> 중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.

**_중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다._**

모든 중복코드를 개별적으로 테스트해서 동일한 결과를 내놓는지 확인해야만 한다. 즉, **_중복 코드는 수정과 테스트에 드는 비용을 증가시킬 뿐 아니라 시스템과 개발자를 공황상태로 몰아넣는다._**

> 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면(의존성과 상관 없이) 이 코드는 중복이다. 함께 수정할 필요가 없다면 중복이 아니다. 중복 코드를 결정하는 기준은 코드의 모양이 아니다. 모양이 유사하다는 것은 단지 중복의 징후일 뿐이다. 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.















### 참고 및 출처
  - 오브젝트
