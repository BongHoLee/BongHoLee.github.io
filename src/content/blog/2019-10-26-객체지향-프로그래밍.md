---
title: "객체지향 프로그래밍"
description: "앞선 챕터에서 살펴본 내용의 주된 키워드를 살펴보면 다음과 같다."
pubDate: 2019-10-26
author: "Bong5"
categories: ["OOP"]
tags: ["Java", "Object"]
---


## 오브젝트

---


앞선 챕터에서 살펴본 내용의 주된 키워드를 살펴보면 다음과 같다.

1. 자율적인 객체

2. 인터페이스와 구현의 분리

3. 캡슐화를 통한 낮은 결합도와 높은 응집도의 객체지향 설계

위의 세 가지 키워드 모두 __캡슐화__ 와 관련이 깊다고 하였다.

이번에는 __객체지향 프로그래밍__ 이라는 주제로 하나의 예제를 살펴보며 예제에 적용된 객체지향의 주 개념과 왜 이 개념들이 객체지향 패러다임에서 중요한 자리를 차지하게 되었는지 살펴보자.


챕터 2. 객체지향 프로그래밍
---

#### 영화 예매 시스템

영화 예매 시스템 예제의 요구사항은 다음과 같다.

1. __특정한 조건__ 을 만족하는 예매자는 요금을 할인받을 수 있다. 할인액을 결정하는 두 가지 규칙이 존재하는데 하나는 __할인 조건__ 이라 부르고 다른 하나는 __할인 정책__ 이라 부른다.

2. 할인 조건은 __순번 조건__ 과 __시간 조건__ 이 있다.

3. 할인 정책은 __금액 할인 정책__ 과 __비율 할인 정책__ 이 있다.

4. 영화 별로 __하나의 할인 정책__ 만 할당할 수 있다. 물론 할인 정책을 지정하지 않는 것도 가능하다.

5. 할인 조건은 __다수의 할인 조건을 함께 지정__ 하는 것이 가능하다. 순번 조건과 시간 조건을 섞는 것도 가능하다.

6. 팔인을 적용하기 위해서는 __할인 조건__ 과 __할인 정책__ 을 조합하여 사용한다.

<img src="/assets/img/object/ch2/img1.jpeg" width="100%" height="auto">



| 할인 조건 | 할인 정책 |
|:--------|:--------|
| 순번 조건 | 금액 할인 정책 |
| 시간 조건 | 비율 할인 정책 |

---

#### 객체지향 프로그래밍을 향해

객체지향은 __객체__ 를 지향하는 것이다. 즉 __클래스가 아닌 객체에 초점__ 을 맞출 때에 비로소 객체지향 패러다임으로의 전환이 가능하다.

이를 위해서는 프로그래밍 하는 동안 두 가지를 집중한다.

> 어떤 클래스가 필요한지를 고민하기 전에 __어떤 객체들이 필요한지를 고민__

클래스는 공통적인 상태와 행동을 공유하는 객체들을 __추상화__ 한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

> 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 본다.

객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다. 객체지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라봐야 한다.

객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 __타입으로 분류__ 하고 이 타입을 기반으로 클래스를 구현한다. 훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.

---

#### 도메인의 구조를 따르는 프로그램 구조

소프트웨어는 사용자가 __어떤 문제를 해결하기 위해__ 만들어진다. 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다. 이처럼 __문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야__ 를 __도메인__ 이라고 부른다.

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 __객체__ 라는 동일한 __추상화 기법__ 을 사용할 수 있기 때문이다. 요구사항과 프로그램을 __객체__ 라는 동일한 관점에서 바라볼 수 있기 때문에 __도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결__ 될 수 있다.

<img src="/assets/img/object/ch2/img2.jpeg" width="100%" height="auto">

위의 사진은 __도메인을 구성하는 타입들의 구조__ 를 보여준다.

일반적으로 클래스의 이름은 대응되는 __도메인 개념(타입)__ 의 이름과 동일하게, 적어도 유사하게 지어야 한다. 또한 클래스 사이의 관계 역시 최대한 도메인 타입 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

<img src="/assets/img/object/ch2/img3.jpeg" width="100%" height="auto">

---

#### 클래스 구현하기

이제 위 구조를 한번 구현해보자. 객체지향 개념의 설명을 위해 설계 과정은 생략하고 최종 코드의 모습을 보고 개념의 의미를 하나하나 살펴보는 순서로 진행한다.

__Screening__ 클래스는 사용자들이 예매하는 대상인 __상영__ 을 구현한다.
<img src="/assets/img/object/ch2/img4.png" width="100%" height="auto">

>> 위 구현이 처음에는 막상 이해가 가지 않았다. 하지만 의문점에 대한 질문을 스스로에게 던져보고 그동안 배웠던 내용들을 복기하고보니 의문점에 대해 대부분 답변이 가능했다. 구현의 결과는 트레이드 오프의 산물임을 기억하고 이해가 가지 않아도 좋은 설계는 계속해서 보고 거의 암기하고 따라하려 노력하자.

주목할 점은 __인스턴스 변수의 가시성은 private 이고 메서드의 가시성은 public__ 이라는 것이다.

클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 __클래스의 경계를 구분 짓는 것__ 이다.

__클래스는 내부와 외부로 구분__ 되며 훌륭한 클래스를 설계하기 위한 핵심은 __어떤 부분을 공개하고 어떤 부분을 감출지 결정하는 것__ 이다.

__Screening__ 에서 알 수 있는 것 처럼 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야한다. (캡슐화)

클래스의 내부와 외부를 구분해야하는 중요한 이유(인터페이스와 구현을 분리해야하는 중요한 이유)는 __경계의 명확성이 객체의 자율성을 보장__ 하기 때문이다. 그리고 더 중요한 이유로 __프로그래머에게 구현의 자유를 제공하기 때문__ 이다.

---

#### 자율적인 객체

객체 내부에 대한 접근을 통제하는 이유는 __객체를 자율적인 존재로 만들기 위함__ 이다.

객체가 자율적인 존재로 존재하기 위해서는 __외부의 간섭을 최소화__ 해야 한다. 즉, 외부에서는 객체가 어떤 상태에 놓여있는지, 어떤 생각을 하고 있는지 알아서는 안되며 결정에 직접적으로 개입하려고 해서는 안된다.

객체에게 원하는 것을 __요청__ 하고는 객체가 스스로 최선의 방법을 결정할 수 있을 것이라는 점을 믿고 기다려야 한다.

캡슐화와 접근 제어는 __객체를 두 부분으로 나눈다.__

1. 외부에서 접근 가능한 부분(public 메서드). __퍼블릭 인터페이스__

2. 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분(private 메서드, protected 메서드, 속성) __구현__

전 챕터에서 간단하게 살펴봤지만 __인터페이스와 구현의 분리__ 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

---

#### 프로그래머의 자유

프로그래머의 역할을 두 부분으로 구분하는 것이 유용하다.

1. __클래스 작성자__ : 새로운 데이터 타입을 프로그램에 추가하는 역할

2. __클라이언트 프로그래머__ : 클래스 작성자가 추가한 데이터 타입을 __사용__ 하는 역할

클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것이다.

클래스 작성자는 클라이언트 프로그래머에게 __필요한 부분만 공개__ 하고 나머지는 꽁꽁 숨겨야 한다.

클라이언트 프로그래머는 숨겨놓은 부분에 마음대로 접근할 수 없기때문에 클래스 작성자는 __내부 구현을 마음대로 변경__ 할 수 있다. 이를 __구현 은닉__ 이라 한다.

__접근 제어 메커니즘__ 은 프로그래밍 언어 차원에서 클래스의 내부와 외부를 명확하게 경계 지을 수 있게 하는 동시에 __클래스 작성자가 내부 구현을 은닉__ 할 수 있게 해준다. 또한 클라이언트 프로그래머가 실수로 숨겨진 부분에 접근하는 것을 막아준다. 클라이언트 프로그래머가 private 속성이나 메서드에 접근하려고 시도하면 컴파일러는 오류를 내뱉을 것이다.

__구현 은닉__ 은 클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념이다. 클라이언트 프로그래머는 내부의 구현은 무시한 채 __인터페이스__ 만 알고있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.

클래스 작성작는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 __내부 구현을 마음대로 변경__ 할 수 있다.

다시말해 public 영역을 변경하지 않는다면 코드를 자유롭게 수정할 수 있다.

객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다. 따라서 __클래스를 개발할 때 마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력__ 해야한다.

객체의 변경을 관리할 수 있는 기법 중에서 가장 대표적인 것이 바로 __접근 제어__ 다. 변경될 가능성이 있는 세부적인 구현 내용을 __private__ 영역 안에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다.

>> 클래스의 내부와 외부를 분리한다는 것의 의미는 '극장' 예제를 다시한번 생각해 보자. Theater가 Audience의 가방에 티켓을 넣고 돈을 가져오는 프로세스는 Audience의 내부 구현과 Bag의 내부 구현이 Theater에게 드러나있기에 가능하다. 캡슐화와 책임의 이동을 통해 인터페이스와 구현을 분리함으로써 Theater는 TicketSeller의 SellTo() 인터페이스에만 의존함으로써 내부 구현은 신경쓰지 않아도 되게끔 구현되었다. 즉 클래스의 외부(공개된 퍼블릭 인터페이스)와 내부(TicketSeller가 Audience에게 어떤 메서드로 티켓을 파는지)를 분리하였다.

---

#### 협력하는 객체들의 공동체

이제 영화를 예매하는 기능을 구현하는 메서드를 살펴보자. __Screening__ 의 __reserve()__ 메서드는 영화를 예매한 후 예매 정보를 담고있는 __Reservation__ 의 인스턴스 변수를 생성해서 반환한다. 인자인 __customer__ 는 예매자에 대한 정보를 담고 있고 __audienceCount__ 는 인원수다.

<img src="/assets/img/object/ch2/img5.png" width="100%" height="auto">

위의 __reserve()__ 메서드를 보면 __calculateFee()__ 라는 __private__ 메서드를 호출해서 요금을 계산한 후 그 결과를 __Reservation__ 의 생성자에 전달하는 것을 알 수 있다.

__calculateFee()__ 메서드는 요금을 계산하기 위해 다시 __Movie__ 의 __calculateMovieFee()__  메서드를 호출한다. __Movie__ 의 __calculateMovieFee()__ 메서드의 반환 값은 1인당 예매 요금이다. 따라서 __Screening__ 은 전체 예매 요금을 구하기 위해 __calculateMovieFee()__ 메서드의 반환값에 인원수인 __audienceCount__ 를 곱한다.

__Money__ 는 __금액과 관련된 다양한 계산을 구현__ 하는 간단한 클래스다.

<img src="/assets/img/object/ch2/img6.png" width="100%" height="auto">

객체지향의 장점은 __객체를 이용해 도메인의 의미를 풍부하게 표현__ 할 수 있다는것이다. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 __객체를 사용해서 해당 개념을 구현__ 하라.

그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 __개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫 걸음__ 이다.

__Reservation__ 클래스는 고객(customer), 상영정보(screening), 예매 요금(fee), 인원 수 (audienceCount)를 속성으로 포함한다.

<img src="/assets/img/object/ch2/img7.png" width="100%" height="auto">

---

영화를 예매하기 위해 __Screening__ / __Movie__ / __Reservation__ 인스턴스들은 서로에게 메시지를 전송하며 상호작용 한다. 이처럼 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 __협력__ 이라고 부른다.

<img src="/assets/img/object/ch2/img8.jpeg" width="100%" height="auto

객체지향 프로그램을 작성할 때는 먼저 __협력__ 의 관점에서 __어떤 객체가 필요한지__ 를 결정하고 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.

>> 어떤 객체가 필요한지는 가장 먼저 '도메인 개념'으로부터 찾자.

>> 1. 개념 관점 설계 : 도메인 내 존재하는 개념들의 관계를 파악한다. 사용자가 도메인을 바라보는 관점을 반영한다.

>> 2. 명세 관점 설계 : 실제 객체들의 책임에 초점을 둔다. 객체들의 인터페이스를 바라보고 객체가 '무엇'을 할 수 있는가에 초점을 맞춘다.

>> 3. 구현 관점 설계 : 책임 수행에 필요한 코드를 작성한다. (인터페이스를 수행하는 책임) 책임을 '어떻게' 수행할지에 초점을 맞춘다.



---

#### 협력에 관한 짧은 이야기

객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 __메시지 전송__ 뿐이다.

다른 객체에게 요청이 도착할 때 해당 객체가 __메시지를 수신__ 했다고 말한다.

메시지를 수신한 객체는 __스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정__ 한다. 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 __메서드__ 라 한다.

__메시지와 메서드를 구분__ 하는 것은 매우 중요하다. 객체지향 패러다임이 유연하고 확장 가능하며 재사용 가능한 설계를 낳는다는 명성을 얻게 된 배경에는 __메시지와 메서드를 명확하게 구분__ 한 것도 단단히 한 몫 한다.

또한 __다형성__ 의 측면에서 __메시지와 메서드의 구분__ 이라는 개념이 명확히 드러난다.

지금까지 __Screening__ 이 __Movie__ 의 __calculateMovieFee()__ 메서드를 호출한다고 이야기 했지만 사실은 __Screening__ 이 __Movie__ 에게 __calculateMovieFee__ 메시지를 전송한다 가 더 적절한 표현이다.

사실 __Screening__ 은 __Movie__ 안에 __calculateMovieFee__ 메서드가 존재하는지 조차 모른다. 단지 __Movie__ 가 __calculateMovieFee__ 메시지에 응답할 수 있다고 믿고 메시지를 전송할 뿐이다.(메서드는 메시지를 처리하기 위한 내부 구현이기 때문에 Screening은 Movie의 메서드를 모른다.)

메시지를 수신한 __Movie__ 는 스스로 적절한 메서드를 선택한다. 결국 __메시지를 처리하는 방법을 결정하는 것은 Movie 스스로의 문제__ 인 것이다.

이것이 __객체가 메시지를 처리하는 방법을 자율적으로 결정__ 할 수 있다고 말했던 이유다.

---

#### 할인 요금 구하기.

계속해서 __예먜 요금을 계산하는 협력__ 에 대해서 살펴보자.

<img src="/assets/img/object/ch2/img9.png" width="100%" height="auto">

위 코드에서 알 수 있듯 __Movie__ 는 제목(title), 상영시간(runningTime), 기본요금(fee), 할인 정책(discountPolicy)을 속성으로 갖는다. 그리고 이 속성들의 값은 생성자를 통해 전달된다.

__calculateMovieFee()__ 메서드는 __discountPolicy__ 에 __caculateDiscountAmount()__ 메시지를 전송하여 할인 요금을 반환받는다.

이 메서드에서는 어디에도 어떤 할인정책인지(요금 할인정책, 비율 할인정책) 판단하는 코드는 존재하지 않는다. 단지 __discountPolicy__ 에게 메시지를 전송 할 뿐이다.

여기에는 객체지향에서 중요하다고 여겨지는 두 가지 개념이 숨겨져 있다. 하나는 __상속__ 이고 하나는 __다형성__ 이다. 그리고 그 기반에는 __추상화__ 라는 원리가 숨어있다. 먼저 코드를 살펴보고 개념들을 차례로 살펴본다.

---

#### 할인 정책과 할인 조건

| 도메인 | 구현 클래스 |
|:--------|:--------|
| 할인 정책| DiscountPolicy |
| 금액 할인 정책 | AmountDiscountPolicy |
| 비율 할인 정책 | PercentDiscountPolicy |

__할인 정책__ 은 __금액 할인 정책__ 과 __비율 할인 정책__ 으로 구분된다. 두 가지 할인 정책을 각각 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 라는 클래스로 구현한다.

두 클래스는 대부분의 코드가 유사하고 __할인 요금을 계산하는 방식__ 만 조금 다르다. 따라서 두 클래스 사이의 __중복 코드를 제거__ 하기 위해 공통 코드를 보관할 장소가 필요하다.

여기서는 부모 클래스인 __DiscountPolicy__ 안에 중복 코드를 두고 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 가 이 클래스를 __상속__ 받게 할 것이다. 실제 애플리케이션에서는 __DiscountPolicy__ 인스턴스를 생성할 필요가 없기 때문에 __추상 클래스__ 로 구현한다.

<img src="/assets/img/object/ch2/img10.png" width="100%" height="auto">

위 코드를 살펴보자.

하나의 할인 정책은 여러개의 할인 조건을 포함할 수 있다.

__caculateDiscountAmount()__ 메서드는 전체 할인 조건에 대해 차례대로 __DiscountCondition__ 의 __isSatisfiedBy()__ 메서드를 호출한다. __isSatisfiedBy()__ 메서드는 인자로 전달된 __Screening__ 이 할인 조건을 만족시킬 경우네는 true, 만족시키지 못할 경우에는 false를 반환한다.

할인 조건을 만족하는 __DiscountCondition__ 이 하나라도 존재하는 경우에는 __추상 메서드__ 인 __getDiscountAmount()__ 메서드를 호출해 할인 요금을 계산한다.

만족하는 할인 조건이 존재하지 않는다면 Money.Zero를 반환하여 할인된 요금이 0원임을 반환한다.

__DiscountPolicy__ 는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 __추상 메서드__ 인 __getDiscountAmount()__ 메서드에게 위임한다. 실제로는 __DiscountPolicy__ 를 상속받은 자식 클래스에서 __오버라이딩__ 한 메서드가 실행 될 것이다.

> 이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라 한다.


| 도메인 | 구현 클래스 |
|:--------|:--------|
| 할인 조건 | DiscountCondition |
| 순서 조건 | SequenceCondition |
| 기간 조건 | PeriodCondition |

__DiscountCondition__ 은 자바의 인터페이스를 이용해 선언되어 있다. __isSatisfiedBy()__ 오퍼레이션은 인자로 전달된 screening이 할인 가능한 경우 true를 반환하고 할인이 불가능한 경우에는 false를 반환한다.

<img src="/assets/img/object/ch2/img11.png" width="100%" height="auto">

영화 __할인 조건__ 에는 __순번 조건__ 과 __기간 조건__ 이 존재한다.

__SequenceCondition__ 은 할인 여부를 판단하기 위해 사용할 순번(sequence)을 인스턴스 변수로 포함한다. __isSatisfiedBy()__ 메서드는 파라미터로 전달된 __Screening__ 의 상영 순번과 일치할 경우 할인 가능한 것으로 판단해서 true를, 그렇지 않은 경우에는 false를 반환한다.

<img src="/assets/img/object/ch2/img12.png" width="100%" height="auto">

__PercentDiscountPolicy__ 은 상영 시작 시간이 특정한 기간 안에 포함되는지 여부를 판단해 할인 여부를 결정한다.
조건에 사용할 요일(dayOfWeek)과 시작 시간(startTime), 종료 시간(endTime)을 인스턴스 변수로 포함한다.
__isSatisfiedBy()__ 메서드는 인자로 전달된 __Screening__ 의 상영 요일이 dayOfWeek과 같고 상영 시작 시간이 startTime과 endTime 사이에 있을 경우에는 true를 반환하고, 그렇지 않은 경우에는 false를 반환한다.

<img src="/assets/img/object/ch2/img13.png" width="100%" height="auto">

이제 할인 정책을 구현하자 __AmountDiscountPolicy__ 는 __DiscountPolicy__ 의 자식 클래스로서 할인 조건을 만족 할 경우 일정한 금액을 할인해 주는 금액 할인 정책을 구현한다.
이 클래스는 __DiscountPolicy__ 의 __getDiscountAmount()__ 메서드를 __오버라이딩__ 한다. 할인 요금은 인스턴스 변수인 __discountAmount__ 에 저장한다.

<img src="/assets/img/object/ch2/img14.png" width="100%" height="auto">

__PercentDiscountPolicy__ 역시 __DiscountPolicy__ 의 자식 클래스로서 __getDiscountAmount()__ 메서드를 오버라이딩 한다.
__AmountDiscountPolicy__ 와 다른 점이라면 고정 금액이 아닌 일정 비율을 차감하는 방식이라는 것이다. 할인율은 인스턴스 변수인 __percent__ 에 저장한다.

<img src="/assets/img/object/ch2/img15.png" width="100%" height="auto">

아래 그림은 __영화 가격 계산__ 에 참여하는 모든 클래스 사이의 관계를 다이어그램으로 표현한 것이다.

<img src="/assets/img/object/ch2/img16.jpeg" width="100%" height="auto">

---

### 상속과 다형성

__의존성의 개념__ 을 먼저 살펴보고 __상속과 다형성__ 을 이용해 특정한 조건을 선택적으로 실행하는 방법을 알아보자.

#### 컴파일 시간 의존성과 실행 시간 의존성

<img src="/assets/img/object/ch2/img17.jpeg" width="100%" height="auto">

어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체에게 메시지를 전송할 경우 (메서드를 호출) 두 클래스 사이에 __의존성이 존재__ 한다고 말한다.

여기서 눈여겨 봐야 할 부분은 __Movie__ 클래스가 __DiscountPolicy__ 클래스와 연결돼 있다는 것이다. 문제는 영화 요금을 계산하기 위해서는 __추상 클래스__ 인 __DiscountPolicy__ 가 아니라 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 인스턴스가 필요하다는 것이다.
따라서 __Moive__ 인스턴스는 실행 시에 __AmountDiscountPolicy__ 나 __PercentDiscountPolicy__ 의 인스턴스에 의존해야 한다.
하지만 __코드 수준에서 Movie 클래스는 이 두 클래스 중 어떤 것에도 의존하지 않는다.__ 오직 추상 클래스인 __DiscountPolicy__ 에만 의존하고 있다.

그렇다면 __Movie__ 의 인스턴스가 __코드 작성 시점__ 에는 그 존재조차 알지 못했던 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 의 인스턴스와 __실행 시점에 협력__ 이 가능한 이유는 무엇일까?

__Movie__ 의 인스턴스를 생성하는 코드를 살펴보면 __Movie__ 의 생성자에서 __DiscountPolicy__ 타입의 객체를 인자로 넘겨준다. 이 떄에 __AmountDiscountPolicy__ 또는 __PercentDiscountPolicy__ 인스턴스를 전달하면 실행 시점에는 __DiscountPolicy__ 가 아닌 __AmountDiscountPolicy__ / __PercentDiscountPolicy__ 에 의존성을 갖고 협력을 하게 된다.

위의 내용을 다시 생각해보면 __코드__ 상에서 __Movie__ 는 __DiscountPolicy__ 에 의존한다.
그러나 __실행 시점__ 에는 __Movie__ 인스턴스는 __AmountDiscountPolicy__ 또는 __PercentDiscountPolicy__ 인스턴스에 의존하게 된다.

여기서 알 수 있는 것은 __코드의 의존성__ 과 __실행 시점의 의존성__ 이 서로 다를 수 있다는 것이다.
다시 말해 __클래스 사이의 의존성__ 과 __객체 사이의 의존성__ 은 동일하지 않을 수 있다.

유연하고 쉽게 재사용 가능하며 확장 가능한 객체지향 설계가 가지는 특징은 __코드의 의존성__ 과 __실행 시점의 의존성__ 이 다르다는 것이다.
유의해야 할 점은 __코드의 의존성__ 과 __실행 시점의 의존성__ 이 다를 수록 __코드를 이해하기가 어렵다__ 는 점이다. 코드를 이해하기 위해서는 코드 뿐 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다.

이와 같은 __의존성의 양면성__ 은 설계가 __트레이드 오프의 산물__ 이라는 점을 잘 보여준다.

설계가 유연해질수록 코드를 이해하고 디버깅 하기는 점점 더 어려워 진다는 사실을 기억하자. 반면 유연성을 억제하면 코드를 이해하고 디버깅 하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억하자. 우리가 더 좋은 객체지향 설계자로 성장하기 위해서는 항상 __유연성과 가독성 사이에서 고민__ 해야한다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다. 이것이 객체지향 설계가 어려우면서도 매력적인 이유다.

---

#### 상속과 인터페이스

__상속__ 이 가치가 있는 이유는 부모 클래스가 제공하는 __모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문__ 이다.
이것은 상속을 단순히 메서드나 인스턴스 변수를 __재사용__ 하기 위한 측면이 아니다.

__인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의__ 한다. 상속을 통해 자식 클래스는 __자신의 인터페이스에 부모 클래스의 인터페이스를 포함__ 하게 된다.
결과적으로 __자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신__ 할 수 있기 때문에 __외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주__ 할 수 있다.

<img src="/assets/img/object/ch2/img18.png" width="100%" height="auto">

위의 __Moive__ 가 __DiscountPolicy__ 인터페이스에 정의된 __caculateDiscountAmount()__ 메시지를 전송하고 있다.
__DiscountPolicy__ 를 상속받는 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 의 인터페이스에도 이 오퍼레이션이 포함돼있다.

__Movie__ 입장에서는 협력 객체가 어떤 클래스의 인스턴스인지가 중요한 것이 아니라 __caculateDiscountAmount()__ 메시지를 수신할 수 있다는 사실이 중요하다.
다시말해 __Moive__ 는 협력 객체가 __caculateDiscountAmount()__ 메시지를 이해할 수 만 있다면 그 객체가 어떤 클래스의 인스턴스인지 상관하지 않는다.

따라서 __caculateDiscountAmount()__ 메시지를 수신 할 수 있는 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 모두 __DiscountPolicy__ 를 대신해서 __Movie__ 와 협력할 수 있다.

정리하면 자식 클래스는 __상속을 통해 부모 클래스의 인터페이스를 물려받기__ 떄문에 부모 클래스 대신 사용될 수 있다.
컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용 하는 것을 허용한다.

---

#### 다형성

다시 한 번 강조하지만 __메시지와 메서드는 다른 개념__ 이다. __Movie__ 는 __DiscountPolicy__ 의 인스턴스에게 __caculateDiscountAmount()__ 메시지를 전송한다. 그렇다면 __실행되는 메서드__ 는 무엇인가? __Moive__ 와 상호작용하기 위해 __연결된 객체의 클래스가 무엇인가__ 에 따라 달라진다.

__Movie__ 와 협력하는 객체가 __AmountDiscountPolicy__ 의 인스턴스냐 __PercentDiscountPolicy__ 의 인스턴스냐에 따라 각 클래스가 오버라이딩 한 메서드가 실행될 것이다.

코드 상에서 __Movie__ 클래스는 __DiscountPolicy__ 클래스에게 메시지를 전송하지만 실행 시점에 실행되는 메서드는 __Movie__ 와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다.

다시 말해서 __Movie__ 는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

이를 __다형성__ 이라 한다.

즉, __동일한 메시지에 대해 다르게 응답할 수 있는 개념__ 이다.

__다형성__ 은 객체지향 프로그램의 __컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실__ 을 기반으로 한다.
프로그램을 작성할 때 __Movie__ 클래스는 추상 클래스인 __DiscountPolicy__ 클래스에 의존한다. 반면 실행 시점에 __Movie__ 의 인스턴스와 실제로 상호작용 하는 객체는 __AmountDiscountPolicy__ 또는 __PercentDiscountPolicy__ 의 인스턴스다.
다시 말해 __컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행 할 수 있게 한다.__

__다형성__ 이란 __동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력__ 을 의미한다.
따라서 다형적인 협력에 참여하는 객체들은 __모두 같은 메시지를 이해할 수 있어야 한다.__ 다시말해 __인터페이스가 동일__ 해야한다는 것이다.
__AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 가 다형적인 협력에 참여할 수 있는 이유는 이들이 __DiscountPolicy__ 로부터 __동일한 인터페이스를 물려받았기 때문__ 이다. 그리고 이 두 클래스의 __인터페이스를 통일하기 위해 사용한 구현 방법이 바로 상속__ 인 것이다.

다형성에는 __메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정__ 한다는 특징이 있다.
다시 말해 __메시지와 메서드를 실행 시점에 바인딩__ 한다는 것이다. 이를 __동적 바인딩__ 이라고 부른다.
객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고 __하나의 메시지를 선택적으로 서로 다른 메서드에 연결__ 할 수 있는 이유가 바로 동적 바인딩이라는 메커니즘을 사용하기 때문이다.

> 상속을 '구현 상속'과 '인터페이스 상속'으로 분류할 수 있다. 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 '구현 상속'이라 하고 다형적인 협력을 위해 부모 클래스와 자식 클래스가 '인터페이스를 공유'할 수 있도록 상속을 이용하는 것을 '인터페이스 상속'이라 한다.

상속은 __구현 상속__ 이 아니라 __인터페이스 상속__ 을 위해 사용해야한다. 대부분의 사람들은 코드 재사용이 상속의 주된 목적이라고 생각하지만 이것은 오해다. __인터페이스를 재사용__ 할 목적이 아니라 __구현을 재사용__ 할 목적으로 상속을 사용하게 되면 __변경에 취약한 코드__ 를 낳게 될 확률이 높다.

---

#### 인터페이스와 다형성

__DiscountPolicy__ 의 경우 __추상 클래스__ 로 구현함으로써 __내부 구현__ 과 __인터페이스__ 를 함께 상속하게끔 만들었다. 그러나 종종 구현은 공유할 필요가 없고 순수하게 __인터페이스__ 만 공유해야 할 때가 많다. 이를 위해 자바의 __인터페이스__ 라는 프로그래밍 요소를 사용한다.

<img src="/assets/img/object/ch2/img19.jpeg" width="100%" height="auto">

추상 클래스를 이용해 다형성을 구현했던 할인 정책과 달리 __할인 조건__ 은 구현을 공유할 필요가 없기 때문에 위 사진과 같이 자바의 인터페이스를 이용해 타입 계층을 구현했다.
__DiscountCondition__ 인터페이스를 실체화 하고 있는 __SequenceCondition__ 과 __PeriodCondition__ 은 __동일한 인터페이스를 공유__ 하며 다형적인 협력에 참여할 수 있다.

__SequenceCondition__ 과 __PeriodCondition__ 은 __isSatisfiedBy()__ 메시지를 이해할 수 있기 때문에 클라이언트인 __DiscountPolicy__ 입장에서 이 둘은 __DiscountCondition__ 과 아무런 차이가 없다. __DiscountCondition__ 을 실체화 하는 클래스들은 __동일한 인터페이스를 공유__ 하며 __DiscountCondition__ 을 대신해서 사용될 수 있다.

---

#### 추상화와 유연성

잠깐 추상화의 정의부터 살펴보고 가자.

>> 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복

복잡성을 다루기 위해 추상화는 __두 가지 차원__ 에서 이루어진다.

>> 1. 구체적인 사물(개체)들 간의 공통점은 취하고 차이점을 버리는 일반화를 통해 단순하게 만드는 것

>> 2. 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거함으로써 단순화.

즉, 모든 경우의 __추상화의 목적__ 은 __복잡성을 이해하기 쉬운 수준으로 단순화__ 시키는 것임을 기억하자.


- 할인 정책의 도메인 개념의 추상화 정도

| 도메인 | 구현 클래스 | 비고 |
|:--------|:--------|:--------|
| 할인 정책| DiscountPolicy | 추상적 |
| 금액 할인 정책 | AmountDiscountPolicy | 구체적 |
| 비율 할인 정책 | PercentDiscountPolicy | 구체적 |

<br><br>

- 할인 조건의 도메인 개념의 추상화 정도

| 도메인 | 구현 클래스 | 비고 |
|:--------|:--------|:--------|
| 할인 조건 | DiscountCondition | 추상적 |
| 순서 조건 | SequenceCondition | 구체적 |
| 기간 조건 | PeriodCondition | 구체적 |

지금까지 살펴본 것 처럼 __할인 정책__ 은 __할인 금액 정책__ 과 __비율 할인 정책__ 을 포괄하는 __추상적인 개념__ 이다.
__할인 조건__ 역시 더 구체적인 __순번 조건__ 과 __기간 조건__ 을 포괄하는 __추상적인 개념__ 이다.

다시말해 __DiscountPolicy__ 는 __AmountDiscountPolicy__ 와 __PercentDiscountPolicy__ 보다 추상적이고 __DiscountCondition__ 은 __SequenceCondition__ 과 __PeriodCondition__ 보다 추상적이다.

프로그래밍 언어 측면에서 __DiscountPolicy__ 와 __DiscountCondition__ 이 더 추상적인 이유는 __인터페이스에 초점을 맞추기 때문__ 이다. __DiscountPolicy__ 는 모든 할인 정책들이 수신할 수 있는 __caculateDiscountAmount()__ 메시지를 정의한다. 둘 다 __같은 계층에 속하는 클래스들이 공통으로 가질 수 있는 인터페이스를 정의__ 하며 구현의 일부(추상 클래스의 경우) 또는 전체(자바 인터페이스의 경우)를 __자식 클래스가 결정할 수 있도록 결정권을 위임__ 한다.

아래 사진은 __자식 클래스를 생략한 코드 구조__ 를 그림으로 표현한 것이다. 이 그림은 추상화를 사용 할 경우의 두 가지 장점을 보여준다.

<img src="/assets/img/object/ch2/img20.jpeg" width="100%" height="auto">

1. 추상화의 계층만 따로 뗴어놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술 할 수 있다는 것이다. (구체적인 금액 할인 정책, 순번 기간 조건이 아닌 보다 추상적이고 높은 수준인 할인 정책, 할인 조건에 대해서 서술 가능)

2. 추상화를 이용하면 설계가 좀 더 유연해진다.

첫 번째 장점을 하나의 문장으로 정리하면 __영화 예매 요금은 최대 하나의 할인 정책과 다수의 할인 조건을 이용해 계산 가능하다.__ 로 표현할 수 있다. 이 문장이 __영화 예매 요금은 '금액 할인 정책'과 '두개의 순서 조건, 한개의 기간 조건'을 이용해서 계산할 수 있다.__ 라는 문장을 포괄 할 수 있다는 사실이 중요하다. 이것은 __할인 정책__ 과 __할인 조건__ 이라는 좀 더 추상적인 개념들을 사용해서 문장을 작성했기 때문이다.

추상화를 사용하면 __세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현__ 할 수 있다. 추상화의 이런 특징은 __세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명__ 할 수 있게한다.

추상화를 이용해 상위 정책을 기술한다는 것은 __기본적인 애플리케이션의 협력 흐름을 기술__ 한다는 것을 의미한다.
할인 정책이나 할인 조건의 새로운 자식클래스들은 추상화를 이용해서 정의한 상위의 협력 흐름을 그대로 따르게 된다.
이 개념은 매우 중요한데, 재사용 가능한 설계의 기본을 이루는 __디자인 패턴__ 이나 __프레임워크__ 모두 추상화를 이용하여 상위 정책을 정의하는 객체지향 메커니즘을 활용하고 있기 때문이다.

---

#### 유연한 설계

만일 어떤 영화의 __할인 정책__ 이 적용되지 않은 경우는 어떻게 할까? 즉, 할인 요금을 계산 할 필요 없이 영화에 설정된 기본 금액을 그대로 사용하면 된다.

<img src="/assets/img/object/ch2/img21.png" width="100%" height="auto">

위 코드는 정상적으로 작동한다. __할인 정책__ 이 적용되지 않았으니 인스턴스 변수 __discountPolicy__ 는 __null__ 일 것이고 이 경우 단순히 현재 영화의 요금인 __fee__ 를 return 해준다.

하지만 협력의 측면에서 위 방식의 문제점을 살펴보자.

이 방식의 문제점은 할인 정책이 없는 경우를 __예외 케이스__ 로 취급하기 때문에 지금까지 __일관성 있던 협력 방식이 무너지게__ 된다는 것이다.
기존 할인 정책의 경우에는 할인할 금액을 계산하는 책임이 __DiscountPolicy__ 의 자식 클래스에 있었지만 할인 정책이 없는 경우에는 할인 금액이 0원이라는 사실을 결정하는 책임이 __DiscountPolicy__ 가 아닌 __Movie__ 쪽에 있기 때문이다.

> 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.

> 항상 예외 케이스를 최소화 하고 일관성을 유지할 수 있는 방법을 선택하라.

이 경우에 일관성을 지킬 수 있는 방법은 0원이라는 할인 요금을 계산할 책임을 그대로 __DiscountPolicy__ 계층에 유지시키는 것이다. __NoneDiscountPolicy__ 클래스를 추가하자.

<img src="/assets/img/object/ch2/img22.png" width="100%" height="auto">

중요한 것은 __Movie__ 와 __DiscountPolicy__ 는 수정하지 않고 __NoneDiscountPolicy__ 라는 새로운 클래스를 추가하는 것 만으로 애플리케이션의 기능을 확장시켰다는 것이다.

이처럼 __추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계__ 를 만들 수 있다.

추상화가 유연한 설계를 가능하게 하는 이유는 __설계가 구체적인 상황에 결합되는 것을 방지__ 하기 때문이다. __Movie__ 는 특정한 할인 정책에 묶이지 않는다. 할인 정책을 구현한 클래스가 __DiscountPolicy__ 를 상속받고 있다면 어떤 클래스와도 협력이 가능하다.

__DiscountPolicy__ 역시 특정한 할인 조건에 묶이지 않는다. __DiscountCondition__ 을 상속받은 어떤 클래스와도 협력이 가능하다.
이것은 __DiscountPolicy__ 와 __DiscountCondition__ 이 추상적이기 때문에 가능한 것이다.

결론은 간단하다.

> 유연성이 필요한 곳에 추상화를 사용하라.

<img src="/assets/img/object/ch2/img24.jpeg" width="100%" height="auto">

---

#### 추상 클래스와 인터페이스 트레이드 오프

앞의 __NoneDiscountPolicy__ 클래스의 코드와 __DiscountPolicy__ 코드를 자세히 살펴보면 __NoneDiscountPolicy__ 클래스의 __getDiscountAmount()__ 메서드가 어떤 값을 반환하더라도 상관이 없다는 사실을 알 수 있다. (호출이 되지 않기 때문)

부모 클래스인 __DiscountPolicy__ 에서 할인 조건이 없을 경우에는 __getDiscountAmount()__ 메서드를 호출하지 않기 때문이다. 이것은 부모 클래스인 __DiscountPolicy__ 와 __NoneDiscountPolicy__ 를 개념적으로 결합시킨다.

이 문제를 해결하는 방법은 __DiscountPolicy__ 를 __인터페이스__ 로 바꾸고 __NoneDiscountPolicy__ 가 __getDiscountAmount()__ 메서드가 아닌 __caculateDiscountAmount()__ 오퍼레이션을 오버라이딩 하도록 변경하는 것이다.


__DiscountPolicy__ 클래스를 __인터페이스__ 로 변경한다.

<img src="/assets/img/object/ch2/img25.png" width="100%" height="auto">

원래의 __DiscountPolicy__ 클래스의 이름을 __DefaultDscountPolicy__ 로 변경하고 인터페이스를 구현하도록 수정한다.

<img src="/assets/img/object/ch2/img26.png" width="100%" height="auto">

이제 __NoneDiscountPolicy__ 가 __DiscountPolicy__ 인터페이스를 구현하도록 변경하면 개념적인 혼란과 결합을 제거할 수 있다.

<img src="/assets/img/object/ch2/img27.png" width="100%" height="auto">

<img src="/assets/img/object/ch2/img23.jpeg" width="100%" height="auto">

어떤 설계가 더 좋을까? 이상적으로는 인터페이스를 사용하도록 변경한 설계가 더 좋을 것이다. 현실적으로는 __NoneDiscountPolicy__ 만을 위해 인터페이스를 추가하는 것이 과하다는 생각이 들 수 도 있다.

여기서 이야기 하고 싶은 사실은 __구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다__ 는사실이다. 우리가 작성하는 __모든 코드에는 합당한 이유가 있어야__ 한다. 비록 아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.

> 고민하고 트레이드오프 하라

---

#### 코드 재사용

__상속__ 은 코드를 재사용하기 위해 널리 사용되는 방법이다. 그러나 널리 사용되는 방법이라고 해서 좋은 방법인 것은 아니다.

> 코드 재사용을 위해서는 상속(is-a) 보다 합성(has-a)이 더 좋은 방법이다.

여기서 말하는 __합성__ 이란 __다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용__ 하는 방법을 말한다.

__Movie__ 가 __DiscountPolicy__ 의 코드를 재사용 하는 방법이 바로 __합성__ 이다. 이 설계를 상속을 사용하도록 변경할 수도 있다.

<img src="/assets/img/object/ch2/img28.jpeg" width="100%" height="auto">

위와 같이 __Movie__ 를 직접 상속받아 __AmmountDiscountMovie__ 와 __PercentDiscountMovie__ 라는 두 개의 클래스를 추가하면 합성을 사용한 기존 방법과 기능적인 관점에서 완벽히 동일하다.

그럼에도 많은 사람들이 상속 대신 합성을 선호하는 이유는 무엇일까?

---

#### 상속

__상속__ 은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이다. 하지만 두 가지 관점에서 __설계에 안좋은 영향__ 을 미친다.

1. __상속__ 은 캡슐화를 위반한다.

2. __상속__ 은 설계를 유연하지 못하게 만든다.

상속의 가장 큰 문제점은 __캡슐화__ 를 위반한다는 것이다. 상속을 이용하기 위해서는 __부모 클래스의 내부 구조__ 를 잘 알고있어야 한다. __AmmountDiscountMovie__ 와 __PercentDiscountMovie__ 를 구현하는 개발자는 부모 클래스인 __Movie__ 의 __calculateMovieFee()__ 메서드 안에서 추상 메서드인 __getDiscountAmount()__ 메서드를 호출한다는 사실을 알고있어야 한다.

결과적으로 __부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화__ 된다. __캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합__ 되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다.
결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.

상속의 두 번째 단점은 __설계가 유연하지 않다__ 는 점이다. 상속은 부모 클래스와 자식 클래스 사이의 관계를 __컴파일 시점에 결정__ 한다. 따라서 __실행 시점에 객체의 종류를 변경하는 것이 불가능__ 하다.

예를 들어, 실행 시점에 __금액 할인 정책 영화__ 를 __비율 할인 정책 영화__ 로 변경한다고 가정하자. 상속을 사용한 설계에서는 __AmmountDiscountMovie__ 인스턴스를 __PercentDiscountMovie__ 인스턴스로 변경해야 한다.

최선의 방법은 __PercentDiscountMovie__ 인스턴스를 생성한 후 __AmmountDiscountMovie__ 의 상태를 복사하는 것 뿐이다.

이것은 __부모 클래스와 자식 클래스가 강하게 결합돼 있기 때문에 발생하는 문제__ 이다.

만약 __인스턴스 변수로 연결__ 한 존 방법을 사용하면 __실행 시점에 할인 정책을 간단하게 변경__ 할 수 있다.
다음과 같이 __Movie__ 에 __DiscountPolicy__ 를 변경할 수 있는 __changeDiscountPolicy()__ 메서드를 추가하자.

<img src="/assets/img/object/ch2/img29.png" width="100%" height="auto">

금액 할인 정책이 적용된 영화에 비율 할인 정책이 적용되도록 변경하는 것은 새로운 __DiscountPolicy__ 인스턴스를 연결하는 간단한 작업으로 바뀐다.

위 예제를 통해 __상속__ 보다 __인스턴스 변수__ 로 관계를 연결한 서례가 더 유연하다는 사실을 알 수 있다.

__Movie__ 가 __DiscountPolicy__ 를 포함하는 이 방법 역시 __코드를 재사용 하는 방법__ 임을 눈여겨 보기 바란다.

> 왜 합성이 코드 재사용의 측면일까? 자세한 사항은 더 공부해봐야겠지만 참조되는 객체(합성 객체)의 인터페이스에 의존하여 접근하기 때문에 인터페이스를 활용한 재사용이 아닐까 싶다.

---

#### 합성

__Movie__ 는 요금을 계산하기 위해 참조 하는 객체(합성 객체)인 __DiscountPolicy__ 의 코드를 __재사용__ 한다. 이 방법이 __상속__ 과 다른 점이 있다. 상속이 부모 클래스의 코드와 자식 클래스의 코드를 __컴파일 시점에 하나의 단위로 강하게 결합__ 하는데 비해 __Movie__ 가 __DiscountPolicy__ 의 __인터페이스를 통해 약하게 결합__ 된다는 것이다.

> 상속은 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합한다.

> 합성은 인터페이스를 통해 약하게 결합된다.

실제로 __Movie__ 는 __DiscountPolicy__ 가 외부에 __caculateDiscountAmount()__ 메서드를 제공한다는 사실만 알고 내부 구현에 대해서는 알지 못한다. 이처럼 __인터페이스에 정의된 메시지를 통해서만 코드를 재사용 하는 방법__ 을 __합성__ 이라고 한다.

__합성__ 은 __상속__ 이 가지는 두 가지 문제점을 모두 해결한다.

__인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화__ 할 수 있다.
또한 __의존하는 인스턴스를 비교적 쉽게 교체__ 하기 때문에 __설계를 유연__ 하게 만든다.

> 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.

따라서 __코드 재사용__ 을 위해서는 __상속보다 합성을 선호__ 하는 것이 더 좋은 방법이다.

그렇다고 해서 상속을 절대 사용하지 말라는 것은 아니다. 대부분의 설계에서는 __상속과 합성을 함께__ 사용해야 한다. 이전 구현 코드를 살펴보면 __Moive__ 와 __DiscountPolicy__ 는 __합성 관계__ 로 연결되어 있고 __DiscountPolicy__ 와 __AmmountDiscountPolicy__ / __PercentDiscountPolicy__ 는 __상속 관계__ 로 연결되어 있다.

> 코드 재사용을 위해서는 합성이 옳지만 다형성을 위해 인터페이스를 재사용 하는 경우에는 상속과 합성을 함꼐 조합해서 사용할 수 밖에 없다.

---

지금까지 구체적인 예제를 통해 객체지향 프로그래밍과 관련된 다양한 개념을 살펴보았다.

__객체지향__ 이란 객체를 지향하는 것이다. 따라서 객체지향 패러다임의 중심에는 객체가 위치한다. 그러나 객체를 따로 떼어놓고 이야기하는 것은 무의미하다. 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 __협력에 참여하는 객체들 사이의 상호작용__ 이다. 객체들은 __협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행한다.__


### 참고 및 출처
  - 오브젝트
