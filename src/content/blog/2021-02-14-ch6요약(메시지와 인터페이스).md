---
title: "Ch6 요약(메시지와 인터페이스)"
description: "이전 장 까지 우리는 객체지향 설계에서 가장 중요한 것들을 살펴보았다."
pubDate: 2021-02-14
author: "Bong5"
categories: ["Programming"]
tags: ["Java", "Object"]
---


## Ch6 메시지와 인터페이스

[본문](https://bongholee.github.io/java/books/object/2020/01/17/메시지_인터페이스.html)

---

## 들어가며

이전 장 까지 우리는 객체지향 설계에서 가장 중요한 것들을 살펴보았다.

요약하자면 객체지향 설계란 **책임을 수행하는 자율적인 객체들과 역할 구성된 협력을 설계하는 것이다.**

결국 `객체`에게 가장 중요한 것은 `책임`이다. 객체에게 얼마나 품질 높은 책임을 할당했느냐에 따라 설계의 품질이 결정된다. 품질 높은 책임이란 어떤 책임을 의미하는가? 바로 `협력`에 어울리는 책임. 즉 **클라이언트의 관점을 반영한 책임** 을 의미한다.

우리는 위와 같이 `협력에 어울리는 책임`을 할당하기 위해 `책임 주도 설계`의 절차에 따라 `필요한 메시지를 식별`한 뒤 `객체를 선택`하였고, 그 결과로 `최소한의 인터페이스`와 `충분히 추상적인 인터페이스`를 얻을 수 있었다.

이와 같이 객체지향 설계에서 가장 중요한 것은 `품질 높은 책임`을 할당함으로써 `품질 높은 퍼블릭 인터페이스`를 구성하는 것이다.

이번 장에서는 `품질 높은 인터페이스`를 얻기 위해 `책임 주도 설계` 방법에 더불어 적용 할 수 있는 몇 가지 원칙들을 살펴볼 것이다.

기억해야 할 점은 **설계는 항상 트레이드오프가 존재한다는 사실이다.** 비록 `원칙`이라고 하더라도 현재의 설계에 적합하지 않다면 과감히 배제해야 한다는 사실을 기억하고 시작해 보자.


---

## 핵심.

- 훌륭한 객체지향 코드를 얻기 위해서는 **클래스가 아니라 객체를 지향해야 한다.**

- 객체를 지향한다는 문장의 의미는 **객체가 수행하는 책임에 초점을 맞춰야 한다는 것이다.**

- 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체가 주고받는 `메시지`이다.

- 애플리케이션은 클래스로 구성되지만 `메시지를 통해 정의`된다는 사실을 기억하자.

- 객체가 수신하는 `메시지`들이 객체의 `퍼블릭 인터페이스`를 구성한다.

- 협력에 적합한 객체를 설계하기 위해서는 **외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.**

- `메시지`는 **객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.**

- `메시지`를 수신했을 때 실제로 어떤 코드가 실행되는지는 `메시지 수신자의 실제 타입`이 무엇이냐에 달려있다.

- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 `메서드`라고 부른다.

- **메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결하기 때문에 컴파일 시점과 런타임 시점의 의미가 달라질 수 있다.**

- `메시지`와 `메서드`의 구분은 **메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.**

- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 `퍼블릭 인터페이스`라고 한다.

- `퍼블릭 인터페이스`에 속한 메시지의 집합을 `오퍼레이션`이라고 부른다.

- `메서드`는 `오퍼레이션`의 여러 가능한 구현 중 하나다.

- 인터페이스의 각 요소는 `오퍼레이션`이다. **오퍼레이션은 구현이 아닌 추상화다. 메서드는 오퍼레이션을 구현한 것이다.**

- 퍼블릭 인터페이스와 메시지의 관점에서 보면 `메서드 호춣`보다는 `오퍼레이션 호출`이 적합하다.

- 객체가 다른 객체에게 `메시지를 전송`하면 런타임 시스템은 `오퍼레이션 호출`로 해석하고 메시지를 수신한 객체의 `실제 타입을 기반`으로 하여 `적절한 메서드를 실행`한다.

- 오퍼레이션의 관점에서 `다형성`이란 **동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것으로 정의 할 수 있다.**

- `메시지`는 **협력에 참여하는 전송자와 수신자 양쪽 모두를 포함하는 개념이다.**

- `오퍼레이션`은 객체가 다른 객체에게 제공하는 `추상적인 서비스`이다.

- `메시지`가 클라이언트오 서버 사이의 협력 관계를 강조하는데 비해 `오퍼레이션`은 메시지를 수신하는 서버객체의 `인터페이스`를 강조한다. 다시말해서 **메시지 전송자는 고려하지 않은 채 메시지 수신자의 관점만을 다루는 것이 오퍼레이션이다.**

- `메서드`는 메시지에 응답하기 위해 실행되는 `코드 블럭`이다. **메서드는 오퍼레이션의 구현이다.**

- `퍼블릭 인터페이스`는 객체가 협력에 참여하기 위해 `외부에서 수신할 수 있는 메시지 묶음`이다. **클래스의 퍼블릭 메서드 집합이나 메시지의 집합을 가리키는데 사용된다.**

- 객체를 설계할 때 가장 중요한 것은 **품질 높은 퍼블릭 인터페이스를 설계하는 것이다.**

- `퍼블릭 인터페이스`의 품질에 영향을 미치는 몇 가지 원칙이 존재하는데 `디미터 법칙`, `묻지말고 시켜라`, `클라이언트의 의도를 드러내는 인터페이스`, `명령-쿼리 분리`로 나누어 볼 수 있다.

- `디미터 법칙`은 `협력하는 객체의 내부 구조에 대한 결합`으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.

- `디미터 법칙`을 간단하게 요약하면 **객체 내부의 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.**

- `디미터 법칙`은 `캡슐화`를 다른 관점에서 표현한 것이다. **클래스를 캡슐화 하기 위해 따라야 하는 구체적인 지침을 제공한다.**

- `디미터 법칙`은 훌륭한 메시지란 객체의 상태에 대해 묻지 말고 단지 **원하는 것을 시켜야 한다는 사실을 강조한다.**

- 메시지 전송자(`클라이언트`)는 메시지 수신자(`서버`)의 상태를 기반으로 결정을 내린 후 메시지 수신자(`서버`)의 상태를 바꿔서는 안된다. **객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.**

- `묻지말고 시켜라` 원칙을 따르면 **밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.**

- `묻지말고 시켜라` 원칙을 따르면 **객체의 정보를 이용하는 행동을 객체의 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.**

- **상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스의 품질을 향상시켜라.**

- 인터페이스는 `어떻게`가 아니라 `무엇`을 하는지를 드러내야 한다.

- `어떻게` 수행하는지 드러내는 인터페이스는 `내부 구현`을 설명하는(드러내는) 인터페이스다.

- `무엇`을 하는지 드러내는 인터페이스를 얻기 위해서는 **객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.**

- 가끔씩은 물어야 하는 경우도 존재한다.

- 원칙을 맹신하고 묻지도 따지지도 않고 `디미터 법칙`과 `묻지말고 시켜라 스타일`을 적용하면 `서로 연관 없는 책임`으로 점철된 `응집도 낮은 퍼블릭 인터페이스`가 될 수 있다.

- 객체에게 시키는 것이 항상 가능한 것은 아니다. **소프트웨어 설계에 있어서 법칙이란 존재하지 않는다.** 원칙을 맹신하지 말자.

- **원칙을 맹신하지 마라** 원칙이 적용될 수 있는 상황과 적용하면 안되는 상황을 판단할 수 있는 안목이 중요하다.!

- `명령`이란 객체의 `상태`를 수정하는 오퍼레이션을 의미한다.

- `쿼리`란 객체와 관련된 `정보`를 반환하는 오퍼레이션을 의미한다.

- `명령-쿼리 분리` 원칙의 요지는 **오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다.**

- **객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.**

- **객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.**

- **훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.**


---

## 협력과 메시지

### 클라이언트-서버 모델

두 객체 사이의 협력 관계를 설명하기 위해 사용되는 전통적인 메타포는 `클라이언트-서버` 모델이다. 협력 안에서 메시지를 전송하는 객체를 `클라이언트`, 메시지를 수신하는 객체를 `서버`라고 부른다. **협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.**

객체는 협력에 참여하는 동안 `클라이언트와 서버의 역할을 동시에 수행`하는 것이 일반적이다. 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다. 하나는 `객체가 수신하는 메시지 집합`이고 다른 하나는 `외부의 객체에게 전송하는 메시지의 집합`이다. **협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.**

요점은 **객체가 독립적으로 수행할 수 있는 것 보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것이다.**

### 메시지와 메시지 전송

`메시지(Message)`는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. 한 객체가 다른 객체에게 도움을 요청하는 것을 `메시지 전송`이라고 부른다. 이 때 메시지를 전송하는 객체를 `메시지 전송자`라고 부르고 메시지를 수신하는 객체를 `메시지 수신자`라고 부른다. `클라이언트-서버` 모델에서는 `메시지 전송자를 클라이언트`, `메시지 수신자를 서버`라고 부르기도 한다.

`메시지`는 `오퍼레이션`과 `인자`로 구성되며 `메시지 전송`은 여기에 `메시지 수신자를 추가`한 것이다. 따라서 메시지 전송은 `메시지 수신자`, `오퍼레이션 명`, `인자`의 조합이다.

- **메시지** : `isSatisfiedBy(screening)`
- **메시지 전송** : `condition.isSatisfiedBy(screening)`

### 메시지와 메서드

**메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인지에 달려있다.** 이처럼 **메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 한다.** 중요한 것은 코드 상에서 동일한 이름의 변수(`condition`)에게 동일한 메시지를 전송하더라도 `객체의 타입`에 따라 실행되는 메서드가 달라질 수 있다는 것이다.

> 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결(바인딩)해야 하기 때문에 컴파일 시점과 런타임 시점의 의미가 달라질 수 있다.

이처럼 `메시지 전송`을 코드 상에 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다.** 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 `적절한 메서드를 선택`해서 응답할 것이라고 믿을 수 밖에 없다.

**메시지와 메서드의 구분은 메시지 전송자(클라이언트)와 메시지 수신자(서버)가 느슨하게 결합할 수 있도록 한다.** 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다. **수신자가 어떤 클래스의 인스턴스인지 어떤 방식으로 요청을 처리하는지 모르더라도 원활한 협력이 가능하다.** 메시지 수신자 역시 누가 메시지를 전송하는지 알 필요가 없다. 단지 메시지가 도착했다는 사실만 알면 된다. **메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.**

> 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 가느다란 끈을 통해서만 연결된다.

> 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 한다.

### 퍼블릭 인터페이스와 오퍼레이션

**객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.** 외부에서는 오직 객체가 공개하는 `메시지`를 통해서만 객체와 상호작용 할 수 있다. 이처럼 **객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.**

프로그래밍 언어의 관점에서 `퍼블릭 인터페이스에 포함된 메시지`를 `오퍼레이션`이라고 부른다. **오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.** 흔히 `오퍼레이션`이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 `메시지와 관련된 시그니처`를 가리키는 경우가 많다.  예로 `isSatisfiedBy`가 오퍼레이션에 해당한다.

그에 비해 **메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.** `SequenceCondition`과 `PeriodCondition`의 두 메서드는 `DiscountCondition` 인터페이스에 정의된 `isSatisfiedBy` 오퍼레이션의 여러 가능한 구현 중 하나이다.

> 인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화다.

> 메서드는 오퍼레이션을 구현한 것이다.

프로그래밍 언어의 관점에서 객체가 다른 객체에게 `메시지를 전송`하면 런타임 시스템은 `오퍼레이션 호출로 해석`하고 메시지를 수신한 객체의 실제 타입을 기반으로 `적절한 메서드를 찾아 실행`한다. 따라서 **퍼블릭 인터페이스와 메시지의 관점에서 보면 메서드 호출보다는 오퍼레이션 호출이라는 용어가 적절하다.**

`오퍼레이션`의 관점에서 `다형성`이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.

**_용어 정리_**

- **메시지** : 객체의 `오퍼레이션`이 호출되도록 요청하는 것을 `메시지 전송`이라고 부른다. **메시지는 협력에 참여하는 전송자(클라이언트)와 수신자(서버) 양쪽 모두를 포함하는 개념이다.**
- **오퍼레이션** : **객체가 다른 객체에게 제공하는 추상적인 서비스다.** 메시지가 전송자와 수신자 사이의 협력 관계를 강조하는데 비해 `오퍼레이션`은 메시지를 수신하는 `객체의 인터페이스`를 강조한다. 다시말해서 메시지 전송자는 고려하지 않은 채 **메시지 수신자의 관점만을 다룬다.** **메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것을 의미한다.**
- **메서드** : 메시지에 응답하기 위해 실행되는 `코드 블럭`을 의미한다. **메서드는 오퍼레이션의 구현이다.** **동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.**
- **퍼블릭 인터페이스** : **객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음.** 클래스의 퍼블릭 메서드들의 집합이나 메시지의 집합을 가리키는데 사용된다.

> 중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다는 것이다.

> 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 볼 수 있다.

## 인터페이스와 설계 품질

앞서 살펴본 바와 같이 좋은 인터페이스란 `최소한의 인터페이스`와 `충분히 추상적인 인터페이스`라는 조건을 만족해야 한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. 추상적인 인터페이스는 `어떻게`가 아니라 `무엇`을 하는지를 표현한다.

**최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다.** 책임 주도 설계 방법은 `메시지를 먼저 선택`함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는것을 방지한다. 또한 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 `클라이언트의 의도를 메시지에 표현`할 수 있게 한다. 따라서 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.

여기서 `퍼블릭 인터페이스`의 품질에 영향을 미치는 다음과 같은 원칙과 기법에 관해 살펴보자.

- **디미터 법칙**
- **묻지 말고 시켜라**
- **의도를 드러내는 인터페이스**
- **명령-쿼리 분리**

아래 코드는 앞선 장에서 **절차적인 방식의 영화 예매 시스템 코드 중 할인 가능 여부를 체크하는 코드** 를 가져온 것이다.

<script src="https://gist.github.com/BongHoLee/5a351d7d9afc8e65dd557b0df8efdbeb.js"></script>

이 코드의 가장 큰 단점은 `ReservationAgency`와 인자로 전달된 `Screening` 사이의 `결합도`가 너무 높기 때문에 `Screening`의 내부 구현을 변경할 때 마다 `ReservationAgency`도 함께 변경된다는 것이다. 문제의 원인은 `ReservationAgency`가 `Screening` 뿐 아니라 `Movie`와 `DiscountCondition`에도 직접 접근하기 때문이다.

이처럼 **협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙이다.**

`디미터 법칙`을 간단하게 요약하면 **객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.** 디미터 법칙은 **낯선자에게 말하지 말라** 또는 **오직 인접한 이웃하고만 말하라** 로 요약할 수 있다. 자바에서는 **오직 하나의 도트만 이용하라** 라는 말로 요약되기도 한다.

`디미터 법칙`은 객체들의 협력 경로를 제한하면 `결합도`를 효과적으로 낮출 수 있다는 사실에 기반한다. 여기서 말하는 `협력 경로`란 아래와 같다.

- `this` 객체
-  `메서드의 매개 변수`로 전달된 객체
- `this의 속성(인스턴스 변수)`
- `this의 속성인 컬레션의 요소`
- 메서드 내에서 생성된 지역 객체

앞의 코드에서 `결합도` 문제를 해결하기 위해 수정된 `ReservationAgency`의 최종 코드를 보자.

<script src="https://gist.github.com/BongHoLee/459e409cd8ad3a0dd59d10c415cce0e9.js"></script>

위 코드에서 `ReservationAgency`는 메서드의 인자로 전달된 `Screening` 인스턴스에게만 메시지를 전송한다. `ReservationAgency`는 `Screening`의 내부에 대한 어떤 정보도 알지 못한다. `ReservationAgnecy`가 `Screening`의 내부 구조에 결합되어있지 않기 때문에 `Screening`의 내부 구현을 변경할 때 `ReservationAgency`를 함께 변경할 필요가 없다.

`디미터 법칙`을 따르면 `부끄럼타는 코드`를 작성할 수 있다. **부끄럼타는 코드란 (서버로써)불필요한 어떤것도 다른 객체에게 보여주지 않으며 (클라이언트로써)다른 객체의 구현에 의존하지 않는 코드를 의미한다.**

`디미터 법칙`을 따르는 코드는 메시지 수신자(`서버`)의 내부 구조가 메시지 송신자(`클라이언트`)에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. 따라서 **클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.**

> 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 디미터 법칙이 가치 있는 이유는 클래스를 캡슐화 하기 위해 따라야 하는 구체적인 지침을 제공하기 때문이다.
> 캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
> 디미터 법칙은 협력과 구현이라는 사뭇 달라 보이는 두 가지 문맥을 하나의 유기적인 개념으로 통합한다. 클래스의 내부 구현을 채워가는 동시에 현재 협력하고 있는 클래스에 관해서도 고민하도록 주의를 환기시키기 때문이다.

`디미터 법칙`을 따르도록 코드를 개선하면 메시지 전송자는 더 이상 메시지 수신자의 내부 구조에 대해 묻지 않게된다. **단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청한다.**
`screening.calculateFee(audienceCount);`

**디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조한다.** 정보를 처리하는데 필요한 책임을 정보를 알고있는 객체에게 할당하기 때문에 응집도가 높은 객체를 만들 확률이 높아진다.

**하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 응집도가 낮아질 수도 있다.** 이와 관련해서는 뒤에서 나온다.

### 묻지 말고 시켜라

`디미터 법칙`은 **객체 내부의 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지를 작성하도록 속삭인다.** 그리고 자연스럽게 이런 형태의 메시지를 장려하는 코딩 스타일이 나타났는데 그것이 바로 `묻지 말고 시켜라` 스타일이다.

> 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반하는 것이다.

> 절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.

`묻지 말고 시켜라` 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 즉, `묻지 말고 시켜라` 원칙을 따르게 되면 **객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.** 따라서 묻지 말고 시켜라 원칙을 따르도록 메시지를 결정하다 보면 자연스럽게 `정보 전문가`에게 책임을 할당하게 되고 `높은 응집도`를 가진 클래스를 얻게 될 확률이 높아진다.

`디미터 법칙`과 `묻지 말고 시켜라` 원칙이 이야기 하는 핵심은 **객체의 내부 상태를 이용하여 어떤 결정(or 행동)을 하는 로직이 해당 객체의 외부에 존재하지 않아야 한다는 것이다.** 이는 해당 객체가 책임져야할 어떤 행동이 객체 외부로 누수된 것이다.

> 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하여 인터페이스의 품질을 높여라.

> 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올림으로써 퍼블릭 인터페이스의 품질을 높여라.

### 의도를 드러내는 인터페이스

하지만 단순하게 객체에게 묻지 않고 시킨다고 하여 모든 문제가 해결되는 것은 아니다. **훌륭한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안된다.** 즉, 인터페이스는 객체가 `어떻게` 하는지가 아니라 `무엇`을 하는지를 서술해야 한다(충분히 추상적인 인터페이스를 위하여).

메서드가 작업을 `어떻게` 수행하는지 드러내게 된다면 메서드의 이름에서 `내부의 구현 방법`을 드러내게 된다. 이런 스타일은 좋지 않은데 `메서드 수준에서 캡슐화를 위반`한다는 점이 가장 큰 문제점이다.

이를 해결하기 위한 방법은 메서드가 `어떻게`가 아니라 `무엇`을 하는지를 드러내는 것이다. **무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들 뿐 아니라 유연한 코드를 낳는 지름길이다.**

`어떻게` 수행하는지를 드러내는 메서드 이름은 `메서드의 내부 구현을 설명`하는 이름이다. 이는 협력을 설계하기 시작하는 이른 시기부터 클래스의 `내부 구현`에 관해 고민하게 만든다. 반면 `무엇`을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 `객체가 협력 안에서 수행해야 하는 책임에 관해 고민`해야 한다. 이것은 **외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.**

> '무엇'을 하는지 드러내도록 메서드 명을 짓기 위해서는 클라이언트의 관점에서 협력을 바라봐야 한다.

ex : `isSatisfiedByPeriod() or isSatisfiedBySequence --> isSatisfiedBy()`

> 메시지의 이름을 일반화 할 수 있는 간단한 훈련 방법이 존재한다. "매우 다른 구현을 상상하라." 그리고 해당 메서드에 동일한 이름을 붙인다고 상상해보라. 그렇게 하면 우리는 할 수 있는 가장 추상적인 이름을 메서드에 붙일 것이다.

> 의도를 드러내는 퍼블릭 인터페이스를 얻기 위해서는 구현과 관련된 모든 정보를 캡슐화하고 협력과 관련된 의도만을 포함해야 한다.

> 타입 명, 메서드 명, 인자 명이 모두 결합되어 의도를 드러내는 인터페이스를 형성한다. ex : condition.isSatisfiedBy(screening)
> 그러므로 수행 방법에 관해서는 언급하지 말고 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라.
> 방법이 아닌 의도를 포현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화해야 한다.

결론은 **객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.**

### 함께 모으기

지금까지 `품질 높은 퍼블릭 인터페이스`를 얻기 위한 원칙들 중 `디미터 법칙`, `묻지말고 시켜라`, `의도를 드러내는 인터페이스`에 대해서 학습했다.

이제 코드 레벨에서 위 원칙들을 적용시켜보자.

아래 코드는 `디미터 법칙`을 위반한 코드의 전형적인 모습을 보여준다.

<script src="https://gist.github.com/BongHoLee/cd858fa281f11e0d69bd787137f26e9e.js"></script>

`디미터 법칙`에 따르면 `Theater`는 인자로 전달된 `audience`와 인스턴스 변수인 `ticketSeller`에게 메시지를 전송하는 것은 문제가 없다. 문제는 `audience`와 `ticketSeller`의 **내부에 포함된 객체에도 직접 접근** 한다는 것이다.

이로 인해 `Theater`는 `디미터 법칙`을 위반하게 된다.

**근본적으로 디미터 법칙을 위반한는 코드는 '인터페이스와 구현의 분리 원칙'을 위반한다.** 객체의 내부 구조는 구현에 해당한다. `Audience`가 `Bag`을 포함한다는 사실은 `Audience의 내부 구현`에 속하며 `Audience`는 자신의 내부 구현을 자유롭게 변경할 수 있어야 한다. 그러나 퍼블릭 인터페이스에 `getBag()`을 포함시키는 순간 **객체의 구현이 퍼블릭 인터페이스를 통해 외부로 새어나가게 된다.**

> 디미터 법칙을 위반한다는 것은 클라이언트에게 구현을 노출한다는 것을 의미하며, 그 걸과 작은 요구사항 변경에도 쉽게 무너지는 불안정한 코드를 얻게 된다.

`디미터 법칙`을 위반한 코드를 수정하는 일반적인 방법은 `Audience`와 `TicketSeller`의 내부 구조를 묻지 않고 `Audience`와 `TicketSeller`가 직접 자신의 책임을 수행하도록 시키는 것이다.

**_묻지말고 시켜라, 의도를 드러내는 인터페이스_**

`Theater`는 `TicketSeller`와 `Audience`의 내부 구조에 관해 묻지 말고 원하는 작업을 시켜야 한다. 다시말해 **TicketSeller와 Audience는 묻지말고 시켜라 스타일을 따르는 퍼블릭 인터페이스를 가져야 한다.**

이제 코드를 수정해보자.

1. `Theater`가 `TicketSeller`에게 시키고 싶은 일은 `Audience`에게 `Ticket`을 팔도록 하고싶은 것이다. `Theater(클라이언트)`가 `TicketSeller(서버)`에게 단지 원하는 것을 시키자.
2. `TicketSeller`가 `Audience`에게 시키고 싶은 일은 `Ticket`을 보유하는 것이다. `TicketSeller(클라이언트)`가 `Audience(서버)`에게 단지 원하는 것을 시키자.
3. `Audience`가 `Bag`에게 시키고 싶은 일은 `Ticket`을 보관하는 것이다. `Audience(클라이언트)`가 `Bag(서버)`에게 단지 원하는 것을 시키자.

<script src="https://gist.github.com/BongHoLee/70046fae75f31629f0612389647042a2.js"></script>

완성된 코드를 살펴보면 이제 `클라이언트`는 단지 원하는 것을 시킴으로써 메시지를 수신하는 객체(`서버`)가 `자율성`을 갖게되었다. 또한 `sellTo, buy, hold`와 같이 **클라이언트의 의도가 분명하게 드러나도록 객체의 퍼블릭 인터페이스를 개선하였다.**

설명을 생략하고 코드를 작성했지만, 위 간단한 코드는 `오퍼레이션의 이름을 짓는 방법에 관한 지침을 제공`한다.

> 오퍼레이션의 이름은 협력이라는 문맥을 반영해야 한다.

> 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야 한다. 다시말해 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다.

정리해보자.

`디미터 법칙`은 **객체간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다.**
`묻지말고 시켜라` 원칙은 **디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.**
`의도를 드러내는 인터페이스` 원칙은 **객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션 할 수 있게 해준다.**

## 원칙의 함정

잊지 말아야 할 사실이 있다. `설계는 트레이드 오프의 산물`이라는 것이다. **원칙이 현재 상황에 부적합하다고 판단되면 과감하게 원칙을 무시하라. 원칙을 아는 것 보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다.**

### 디미터 법칙은 하나의 도트(.)을 강제하는 규칙이 아니다.

앞서 설명했던 것과 같이 `디미터 법칙은 결합도와 관련`된 것이다. **이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.** 아래 코드를 보자.

<script src="https://gist.github.com/BongHoLee/6d89fa291dad46a4ec2cee948f8ed253.js"></script>

이 코드는 여러개의 도트(.)를 사용하기 때문에 자칫 `디미터 법칙`을 위반했다고 생각할 수 있다. 하지만 코드를 들여다 보면 `InputStream`의 내부 구조에 결합되지 않는다. `of, filter, distinct` 메서드는 `InputStream`의 내부 구조를 노출하지 않는다. 동일한 `InputStream` 클래스의 인스턴스를 반환할 뿐이다.

또한 위 메서드들은 객체 내부에 대한 어떤 내용도 묻지 않는다. 그저 객체를 다른 객체로 변환하는 작업을 수행하라고 시킬 뿐이다. 따라서 `묻지말고 시켜라` 원칙도 위반하지 않는다.

> 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다. 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.

### 결합도와 응집도의 충돌

**일반적으로 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 그 결정에 따라 객체의 상태를 변경하는 코드는 묻지말고 시켜라 스타일로 변경해야 한다.**

`Theater`의 `enter` 메서드를 다시 살펴보자.

<script src="https://gist.github.com/BongHoLee/cd858fa281f11e0d69bd787137f26e9e.js"></script>

`Theater`는 `Audience` 내부에 포함된 `Bag`에 대해 질문한 뒤(`getBag().hasInvitation()`) 그 결과를 이용해 `Bag`의 상태를 변경한다. 이 코드는 분명히 `Audience`의 캡슐화를 위반하기 때문에 `Theater`는 `Audience`의 내부 구조에 강하게 결합된다. **이 문제를 해결할 수 있는 방법은 질문하고, 판단하고, 상태를 변경하는 모든 코드를 Audience 내부로 옮기는 것이다. 다시말해 Audience에게 '위임 메서드'를 추가하는 것이다.**

<script src="https://gist.github.com/BongHoLee/f2ac30b6797269a791df293b9e56a119.js"></script>

이제 `Audience`는 상태와 함께 상태를 조작하는 행동도 포함하기 때문에 `응집도`가 높아졌다. 위 예에서 알 수 있는 것 처럼 **위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.**

하지만 모든 상황에서 맹목적으로 `위임 메서드`를 추가하게 되면 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다. 결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 응집도가 낮아지게 될 수 있다.

**클래스는 하나의 변경 원인만을 가져야 한다.** 서로 상관 없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다. 따라서 **디미터 법칙과 묻지말고 시켜라 원칙을 무작정 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다.**

영화 예매 시스템의 `PeriodCondition` 클래스를 살펴보자.

<script src="https://gist.github.com/BongHoLee/ab1afaaa3bceb07fd0e19dc269fe7df8.js"></script>

`isSatisfiedBy` 메서드는 `screening`에게 질의한 상영 시작 시간을 이용해 할인 여부를 결정한다. 이 코드는 얼핏 보기에 `Screening`의 내부 상태를 가져와서 사용하기 때문에 캡슐화를 위반한 것으로 보일 수 있다. 따라서 할인 여부를 판단하는 로직을 `Screening`의 `isDiscountable` 메서드로 옮기고 `PeriodCondition`이 이 메서드를 호출하도록 변경하면 `묻지말고 시켜라` 스타일을 준수하는 퍼블릭 인터페이스를 얻을 수 있을 것이라 생각할 수 있다.

<script src="https://gist.github.com/BongHoLee/e043881cfc22823b2dd33f30bffe97f7.js"></script>

**하지만 이렇게 하면 Screening은 기간에 따른 할인 조건을 판단하는 책임을 떠안게 된다.** 이것이 `Screening`이 담당하는 본질적인 책임인가? 그렇지 않다. **Screening의 본질적인 책임은 영화를 예매하는 것이다.** Screening이 직접 할인 조건을 판단하게 되면 객체의 응집도가 낮아지게 된다. 반면 `PeriodCondition`의 본질적인 책임은 `할인 조건을 판단`하는 것이다.

게다가 `Screening`은 `PeriodCondition`의 인스턴스 변수를 인자로 받기 때문에 `PeriodCondition`의 변수 목록이 변경될 경우에도 영향을 받게 된다. 이것은 `Screening`과 `PeriodCondition` 사이의 결합도를 높다는 의미이다.

**따라서 Screening의 캡슐화를 향상시키는 것 보다 Screening의 응집도를 높이고 PeriodCondition과의 결합도를 낮추는 것이 전체적인 관점에서 더 좋은 선택이다.**

> Screening의 캡슐화 향상 <--> Screening의 응집도 향상 + PeriodCondition과의 낮은 결합도

> 가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 있다.

이와 같이 **객체에게 묻지 않고 시키는 것이 항상 가능한 것은 아니다. 가끔씩은 물어야 한다.** 여기서 강조하고 싶은 것은 **소프트웨어 설계에 법칙이란 존재하지 않는다는 것이다. 원칙을 맹신하지 마라. 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라.**

## 명령-쿼리 분리 원칙

`가끔식은 물어야 한다`는 사실에 납득했다면 `명령-쿼리 분리 원칙`을 알아두면 도움이 된다.

- **명령(Command)** : 객체의 상태를 변경하고 반환값을 가질 수 없다.
- **쿼리(Query)** : 객체의 상태를 변경할 수 없고 정보를 반환한다.

요약한 바와 같이 **명령은 상태를 변경할 수 있지만 상태를 반환해서는 안된다. 쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안된다.**

> 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어려워 질 수 있다. 겉으로 보기에는 쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드는 이해하기 어렵고 잘못 사용하기 쉬우며 버그를 양산하는 경향이 있다.

> 해결책은 명령과 쿼리를 명확하게 분리하는 것이다.

### 책임에 초점을 맞춰라.

`디미터 법칙`을 준수하고 `묻지말고 시켜라` 스타일을 따르면서도 `의도를 드러내는 인터페이스`를 설계하는 아주 쉬운 방법이 있다. **메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것이다.**

`명령과 쿼리를 분리`하고 `계약에 의한 설계` 개념을 통해 `객체의 협력 방식을 명시적`으로 드러낼 수 있는 방법이 있다. **객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다.**

이 모든 방식의 중심에는 `객체가 수행할 책임`이 위치한다.

`메시지를 먼저 선택`하는 방식이 `디미터 법칙`, `묻지말고 시켜라 스타일`, `의도를 드러내는 인터페이스`, `명령-쿼리 분리 원칙`에 미치는 긍정적인 영향을 살펴보면 다음과 같다.

- **디미터 법칙** : 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다. `수신할 객체를 알지 못하는 상태에서 메시지를 먼저 선택`함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화 할 수 있다.
- **묻지말고 시켜라** : `메시지를 먼저 선택`하면 묻지말고 시켜라 스타일에 따라 협력을 구조화 하게 된다. `클라이언트의 관점에서 메시지를 선택`하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하기만 하면 된다.
- **의도를 드러내는 인터페이스** : **메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다.** 당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명히 드러날 수 밖에 없다.
- **명령-쿼리 분리 원칙** : 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 `객체의 인터페이스`에 관해 고민한다는 것을 의미한다. 객체가 단순히 어떤 일을 해야하는지 뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 **예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.**

> 훌륭한 메시지를 얻기 위한 출발점은 '책임 주도 설계' 원칙을 따르는 것이다. 책임 주도 설계에서는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하기 때문에 협력에 적합한 메시지를 결정할 수 있는 확률이 높아진다.

**책임 주도 설계 방법에 따라 메시지를 결정하자.**
















### 참고 및 출처

  - 오브젝트
