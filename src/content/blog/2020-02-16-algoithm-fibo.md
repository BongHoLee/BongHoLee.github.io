---
title: "Programmers(재귀/DP)_피보나치"
description: "`피보나치`는 `분기`가 필요한 재귀 알고리즘 중 가장 대표적인 문제이다."
pubDate: 2020-02-16
author: "Bong5"
tags: ["Algorithm", "Programmers"]
---
### 문제 설명

[문제 출처](https://programmers.co.kr/learn/courses/30/lessons/12945)

피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어
```
F(2) = F(0) + F(1) = 0 + 1 = 1
F(3) = F(1) + F(2) = 1 + 1 = 2
F(4) = F(2) + F(3) = 1 + 2 = 3
F(5) = F(3) + F(4) = 2 + 3 = 5
```
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

**_제한 사항_**

- n은 1이상, 100000이하인 자연수입니다.

**_예제 입출력_**

| n |	return |
|---|---|
| 3 | 2 |
| 5 | 5 |

**_입출력 예 설명_**

- 피보나치수는 0번째 부터 0, 1, 1, 2, 3, 5 ... 와 같이 이어집니다.

---

### Solution

`피보나치`는 `분기`가 필요한 재귀 알고리즘 중 가장 대표적인 문제이다.

그 만큼 어렵지 않으면서 분기 재귀의 특징을 잘 보여주기 때문이다.

난이도 자체도 평이하고 널리 알려져있는 이 `피보나치` 문제를 굳이 블로깅 하는 이유는 해당 문제가 `시간 초과`를 피하기 위해서는 `메모이제이션`을 활용해야 하기 때문이다.

만일 기존의 방식대로 `f(n) = f(n-2) + f(n-1)`과 같이 문제를 해결하려 한다면 절대 시간초과를 피할 수 없다.

그 이유는 `분기되는 재귀`가 갖게되는 특징일 수 있는데 (모든 분기 재귀과 그런것은 아니지만) `중복 계산`을 고려해야 하기 때문이다.

이를테면 `f(5)`에 대하여 계산을 해보자 그럼 아래와 같은 산술식이 나올 것이다.

```
1. f(5) = f(3) + f(4);

2. f(5) = (f(1) + f(2)) + (f(2) + f(3))

3. f(5) = (f(1) + f(2)) + (f(2) + (f(1) + f(2)))
```
즉, 같은 산술식을 사용하는 `중복 계산`이 눈에 띈다.

`f(n-2)`을 계산하기 위해 산술한 식이 그 다음 계산인 `f(n-1)`에서도 동일하게 사용된다는 말이다.

따라서 각 재귀 호출의 산술 결과를 적절한 자료구조에 저장 및 관리를 하게된다면 불필요한 loop 또는 재귀호출을 획기적으로 줄일 수 있다.

자세한 코드는 아래를 참고하자.
---

### Code

<script src="https://gist.github.com/BongHoLee/ad2864e5f13bb132e7128da0d4322984.js"></script>

---

### 몇줄 평


> 간단한 DP 문제 해결


---



### 참고 및 출처
